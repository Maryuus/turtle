GÉNÉRATION DU FICHIER CONCATÉNÉ LE ven. 30 janv. 2026 13:50:41 CET
.
./capteurs.o
./conditionBinaire.o
./constante.o
./contexte.o
./debug_scan_v2.py
./driver.o
./exemples
./exemples/exemple1.txt
./exemples/exemple2.txt
./exemples/exemple3.txt
./exemples/exemple4.txt
./exemples/exemple5.txt
./exemples/exemple6.txt
./exemples/exemple7.txt
./exemples/exemple8.txt
./exemples/exemple9.txt
./expressionBinaire.o
./expressions
./expressions/capteurs.cc
./expressions/capteurs.hh
./expressions/conditionBinaire.cc
./expressions/conditionBinaire.hh
./expressions/condition.hh
./expressions/constante.cc
./expressions/constante.hh
./expressions/contexte.cc
./expressions/contexte.hh
./expressions/expressionBinaire.cc
./expressions/expressionBinaire.hh
./expressions/expression.hh
./expressions/expressions.pro
./expressions/expressionTernaire.cc
./expressions/expressionTernaire.hh
./expressions/expressionUnaire.cc
./expressions/expressionUnaire.hh
./expressions/instructions.hh
./expressions/libexpressions.a
./expressions/Makefile
./expressions/testBinaire.cc
./expressions/testBinaire.hh
./expressions/types.hh
./expressions/variable.cc
./expressions/variable.hh
./expressionTernaire.o
./expressionUnaire.o
./fields
./fields/jardin0.txt
./fields/jardin1.txt
./fields/jardin2.txt
./fields/jardin3.txt
./fields/jardin4.txt
./final_expressions_fix.sh
./GUI
./GUI/IMG
./GUI/IMG/mur.jpg
./GUI/IMG/tortue.png
./GUI/IMG/vide.jpg
./GUI/jardin.cc
./GUI/jardinHandler.cc
./GUI/jardinHandler.hh
./GUI/jardin.hh
./GUI/jardinRendering.cc
./GUI/jardinRendering.hh
./GUI/tortue.cc
./GUI/tortue.hh
./jardinHandler.o
./jardin.o
./jardinRendering.o
./main.o
./Makefile
./moc_jardin.cpp
./moc_jardinHandler.cpp
./moc_jardinHandler.o
./moc_jardin.o
./moc_jardinRendering.cpp
./moc_jardinRendering.o
./moc_predefs.h
./nettoyage_final.sh
./parser
./parser.cc
./parser/driver.cc
./parser/driver.hh
./parser/location.hh
./parser/main.cc
./parser.o
./parser/parser.cc
./parser/parser.hh
./parser/parser.yy
./parser/position.hh
./parser/scanner.cc
./parser/scanner.hh
./parser/scanner.ll
./parser/stack.hh
./parser.tab.cc
./parser.tab.hh
./parser/test_file
./position.hh
./projet_complet.sh
./PROJET_COMPLET.txt
./projet.pro
./raz.sh
./scanner.cc
./scanner.o
./stack.hh
./testBinaire.o
./test_carre.txt
./test_visuel.txt
./tortue
./tortue.o
./tortue.pro
./variable.o



==================================================
FICHIER : ./exemples/exemple1.txt
==================================================
-- ceci est un commentaire
-- il y a 3 actions de base : avance, recule et saute
-- ces actions ont un argument facultatif qui est le nombre
-- de fois où l'action doit être répétée

avance 1 fois -- avance 1 fois
recule -- recule 1 fois
saute 2 fois
recule 2 -- "fois" est facultatif



==================================================
FICHIER : ./exemples/exemple2.txt
==================================================
avance 2 fois
si mur devant : -- une condition
-- il y a deux fonctions utilisables dans les conditions
-- mur <direction > et vide <direction >
-- avec <direction > = [à gauche |à droite | devant | derriere ]
  tourne à gauche
-- la tortue tourne d'un quart de cercle à gauche ou à droite
-- tourne <à gauche |à droite > [ nombre de fois ]
  avance
  si mur derriere :
    recule
    saute
  sinon : -- il est possible de donner un bloc 'sinon ' aux 'si '
    saute
    avance
  fin si
fin si
-- comme avance / recule / saute tourne prends un paramètre facultatif
tourne à gauche 2 fois
avance 3



==================================================
FICHIER : ./exemples/exemple3.txt
==================================================
si mur devant :
  tourne gauche
sinon :
  avance 1
  tourne droite
fin si



==================================================
FICHIER : ./exemples/exemple4.txt
==================================================
tant que pas de mur devant :
  -- les conditions peuvent être niées avec " pas de"
  foo 1 3 2
  -- appel de fonction
  -- pas de limite au nombre d'arguments
  -- /!\ contrairement aux fonctions prédéfinies
  -- /!\ 'foo' n'est pas équivalent à 'foo 1'
fin tant que

fonction foo : -- il est possible de créer des fonctions
  avance $1 fois
  -- $1 , $2 , .., $n , font références aux arguments de la fonction
  recule $2
  saute $3 fois
fin fonction



==================================================
FICHIER : ./exemples/exemple5.txt
==================================================
sauter 1/(2-3)
-- sauter de -1 est identique à reculer de 2
recule 2*(1+2) fois
bar 1 2+2 5

-- on peut utiliser des expressions à base de +,-,*,/ et ()
-- dans les arguments des actions / fonctions

fonction bar :
  avance $1 * ( $2 + $3 )
fin fonction



==================================================
FICHIER : ./exemples/exemple6.txt
==================================================
-- on peut changer la couleur de la tortue
-- les couleurs sont données en hexadécimal au format #RRGGBB
-- comme en CSS
couleur #aBcDeF



==================================================
FICHIER : ./exemples/exemple7.txt
==================================================
-- on peut gérer plusieurs tortues dans un même script
jardin '../fields/jardin1.jdn'
tortues 2 -- on définit le nombre de tortues
couleur #123456 @1 -- @n à la fin des instructions permet
avance 1 fois @2 -- de choisir la tortue affectée
tourne à droite @1
avance -- toutes les tortues sont affectées si rien n'est précisé



==================================================
FICHIER : ./exemples/exemple8.txt
==================================================
-- certaines actions ne peuvent pas avoir d'indications de tortue
tortues 2
si mur devant @2 :
-- on peut ajouter l'indication de tortues dans les conditions
  avance
  recule @1
fin si
si pas de vide devant @1 :
  avance
fin si
si mur à gauche :
  -- si on ne pré cise pas de tortue , la condition é quivaut à
  -- ( mur gauche @1) et ( mur gauche @2) et .. et ( mur gauche @n)
  avance
fin si

-- tortues 2 @2 -- interdit

-- si mur devant : @1 -- interdit
--   avance 2
-- fin si

-- repete 4 fois : @1 -- interdit
--   recule
-- fin repete

-- tant que vide derriere : @3 -- interdit
--   recule
-- fin tant que



==================================================
FICHIER : ./exemples/exemple9.txt
==================================================
avance fois -- il faut préciser un nombre avant 'fois'
recule avance -- une seule instrucion par ligne
recule 4+ -- expression arithmétique non correcte
couleur #1010EG -- pas au format hexadécimal
couleur 3 fois -- pas de 'fois' sur les couleurs
tortues 5 fois -- pas de 'fois ' sur le nombre de tortues
avance 4 fois @4 fois -- pas de 'fois ' après le @ tortue
si 4 : -- 4 n'est pas une condition valide
  avance 3
fin si

avance 4 fois + 2 fois -- ça c'est pas valide

mur devant -- une condition n'a rien à faire ici

avance 0xFF -- que des nombres en base 10

si mur devant : -- pas de 'fin si '
  avance

fonction foo : -- une fonction n'a rien à faire ici
  avance
fin fonction



==================================================
FICHIER : ./expressions/capteurs.cc
==================================================
#include "capteurs.hh"
#include "driver.hh"

ConditionCapteur::ConditionCapteur(TypeCapteur type, Direction direction, ExpressionPtr tortue)
    : m_type(type), m_direction(direction), m_tortue(tortue)
{}

bool ConditionCapteur::calculer(const Contexte & ctx, Driver& driver) const {
    // Si une tortue est spécifiée (@2), on calcule son ID
    int id = ctx.tortueCourante;
    if (m_tortue) {
        id = (int)m_tortue->calculer(ctx);
    }

    return driver.verifierCapteur(m_type, m_direction, id);
}



==================================================
FICHIER : ./expressions/capteurs.hh
==================================================
#ifndef CAPTEURS_HH
#define CAPTEURS_HH

#include "condition.hh"
#include "types.hh"
#include "expression.hh"
#include <memory>

class ConditionCapteur : public Condition {
public:
    // Constructeur étendu : accepte une expression "tortue" optionnelle
    ConditionCapteur(TypeCapteur type, Direction direction, ExpressionPtr tortue = nullptr);

    bool calculer(const Contexte & ctx, Driver& driver) const override;

private:
    TypeCapteur m_type;
    Direction m_direction;
    ExpressionPtr m_tortue; // Pointeur nul si c'est la tortue courante
};

#endif



==================================================
FICHIER : ./expressions/conditionBinaire.cc
==================================================
#include "conditionBinaire.hh"

bool ConditionBinaire::calculer(const Contexte & ctx, Driver & driver) const {
    bool g = _gauche->calculer(ctx, driver);

    // Optimisation lazy evaluation (court-circuit)
    if (_op == OperateurBinaireBool::ou && g) return true;
    if (_op == OperateurBinaireBool::et && !g) return false;

    bool d = _droite->calculer(ctx, driver);

    switch(_op) {
        case OperateurBinaireBool::et: return g && d;
        case OperateurBinaireBool::ou: return g || d;
    }
    return false;
}



==================================================
FICHIER : ./expressions/conditionBinaire.hh
==================================================
#ifndef CONDITIONBINAIRE_HH
#define CONDITIONBINAIRE_HH
#include "condition.hh"
#include "types.hh"

class ConditionBinaire : public Condition {
public:
    ConditionBinaire(ConditionPtr g, ConditionPtr d, OperateurBinaireBool op)
        : _gauche(g), _droite(d), _op(op) {}

    bool calculer(const Contexte & ctx, Driver & driver) const override;

private:
    ConditionPtr _gauche;
    ConditionPtr _droite;
    OperateurBinaireBool _op;
};
#endif



==================================================
FICHIER : ./expressions/condition.hh
==================================================
#pragma once

#include <memory> // <--- C'est cette ligne qui manquait souvent !
#include "contexte.hh"

class Driver; // Forward declaration pour éviter les inclusions cycliques

class Condition {
public:
    virtual ~Condition() = default;

    // Ancienne méthode (pour compatibilité)
    virtual bool calculer(const Contexte &) const { return false; }

    // Nouvelle méthode utilisée par le Driver
    virtual bool calculer(const Contexte & ctx, Driver& driver) const {
        return calculer(ctx);
    }
};

// C'est cette ligne qui définit ConditionPtr. Si elle manque, ExpressionTernaire plante.
using ConditionPtr = std::shared_ptr<Condition>;



==================================================
FICHIER : ./expressions/constante.cc
==================================================
#include "constante.hh"

Constante::Constante(double valeur) : _valeur(valeur) {
}

double Constante::calculer(const Contexte & ) const {
    return _valeur;
}



==================================================
FICHIER : ./expressions/constante.hh
==================================================
#pragma once
#include "expression.hh"

class Constante : public Expression {
public:
    Constante() = delete;
    Constante(const Constante&) = default;
    Constante(double valeur);


    double calculer(const Contexte& contexte) const override;

private:
    double _valeur;
};



==================================================
FICHIER : ./expressions/contexte.cc
==================================================
#include "contexte.hh"

Contexte::Contexte() : tortueCourante(0) {
}

double & Contexte::get(const std::string & nom) {
    return variables[nom];
}

const double & Contexte::get(const std::string & nom) const {
    if (variables.find(nom) == variables.end()) {
        static double zero = 0.0;
        return zero;
    }
    return variables.at(nom);
}

// Implémentation de l'opérateur []
double & Contexte::operator[](const std::string & nom) {
    return variables[nom];
}



==================================================
FICHIER : ./expressions/contexte.hh
==================================================
#ifndef CONTEXTE_HH
#define CONTEXTE_HH

#include <map>
#include <string>

class Contexte {
public:
    Contexte();

    // Accès standard
    double & get(const std::string & nom);
    const double & get(const std::string & nom) const;

    // LE SAUVEUR : L'opérateur [] pour que driver.cc soit content
    double & operator[](const std::string & nom);

    // Notre ajout précédent
    int tortueCourante;

private:
    std::map<std::string, double> variables;
};

#endif



==================================================
FICHIER : ./expressions/expressionBinaire.cc
==================================================
#include "expressionBinaire.hh"
#include <cmath>

// Note: Le constructeur est déjà défini inline dans le .hh ou doit l'être ici.
// Pour éviter la redéfinition, on ne met QUE la méthode calculer ici.

double ExpressionBinaire::calculer(const Contexte & contexte) const {
    double gauche = _gauche->calculer(contexte);
    double droite = _droite->calculer(contexte);

    switch(_op) {
        case OperateurBinaire::plus: return gauche + droite;
        case OperateurBinaire::moins: return gauche - droite;
        case OperateurBinaire::multiplie: return gauche * droite;
        case OperateurBinaire::divise:
            if (droite != 0) return gauche / droite;
            return 0; // Sécurité division par zéro
    }
    return 0;
}



==================================================
FICHIER : ./expressions/expressionBinaire.hh
==================================================
#ifndef EXPRESSIONBINAIRE_HH
#define EXPRESSIONBINAIRE_HH
#include "expression.hh"
#include "types.hh"

class ExpressionBinaire : public Expression {
public:
    ExpressionBinaire(ExpressionPtr g, ExpressionPtr d, OperateurBinaire op)
        : _gauche(g), _droite(d), _op(op) {}

    double calculer(const Contexte & ctx) const override; // Implémenté dans .cc

private:
    ExpressionPtr _gauche;
    ExpressionPtr _droite;
    OperateurBinaire _op;
};
#endif



==================================================
FICHIER : ./expressions/expression.hh
==================================================
#pragma once
#include <memory>
#include "contexte.hh"


class Expression {
public:
    virtual double calculer(const Contexte & contexte) const = 0;
};

using ExpressionPtr = std::shared_ptr<Expression>;




==================================================
FICHIER : ./expressions/expressions.pro
==================================================
TEMPLATE = lib
CONFIG += staticlib
#Input
HEADERS += ./constante.hh ./contexte.hh ./expression.hh ./expressionBinaire.hh ./expressionTernaire.hh ./expressionUnaire.hh ./variable.hh
SOURCES += ./constante.cc ./contexte.cc ./expressionBinaire.cc ./expressionTernaire.cc ./expressionUnaire.cc ./variable.cc
DEFINES += MAKE_TEST_LIB
QT += widgets



==================================================
FICHIER : ./expressions/expressionTernaire.cc
==================================================
#include "expressionTernaire.hh"

ExpressionTernaire::ExpressionTernaire(ConditionPtr condition, ExpressionPtr exp1, ExpressionPtr exp2):
    _condition(condition), _exp1(exp1), _exp2(exp2){
}

double ExpressionTernaire::calculer(const Contexte& contexte) const {
    
    bool resultatCondition = _condition->calculer(contexte);
    if (resultatCondition) return _exp1->calculer(contexte);
    else return _exp2->calculer(contexte);
}



==================================================
FICHIER : ./expressions/expressionTernaire.hh
==================================================
#pragma once
#include "expression.hh"
#include "condition.hh"

class ExpressionTernaire : public Expression {
public:
    ExpressionTernaire(const ExpressionTernaire &) = default;
    ExpressionTernaire(ConditionPtr condition, ExpressionPtr exp1, ExpressionPtr exp2);
    ~ExpressionTernaire() = default;

    double calculer(const Contexte& contexte) const;

private:
    ConditionPtr _condition;
    ExpressionPtr _exp1;
    ExpressionPtr _exp2;
};



==================================================
FICHIER : ./expressions/expressionUnaire.cc
==================================================
#include "expressionUnaire.hh"

double ExpressionUnaire::calculer(const Contexte & contexte) const {
    double val = _exp->calculer(contexte);
    if (_op == OperateurUnaire::neg) {
        return -val;
    }
    return val;
}



==================================================
FICHIER : ./expressions/expressionUnaire.hh
==================================================
#ifndef EXPRESSIONUNAIRE_HH
#define EXPRESSIONUNAIRE_HH
#include "expression.hh"
#include "types.hh"

class ExpressionUnaire : public Expression {
public:
    ExpressionUnaire(ExpressionPtr exp, OperateurUnaire op)
        : _exp(exp), _op(op) {}

    double calculer(const Contexte & ctx) const override;

private:
    ExpressionPtr _exp;
    OperateurUnaire _op;
};
#endif



==================================================
FICHIER : ./expressions/instructions.hh
==================================================
#ifndef INSTRUCTIONS_HH
#define INSTRUCTIONS_HH

#include "expression.hh"
#include "contexte.hh"
#include "types.hh"
#include "condition.hh"  // <--- L'AJOUT INDISPENSABLE EST ICI !
#include <vector>
#include <memory>
#include <string>

class Driver;

class Instruction {
public:
    virtual ~Instruction() {}
    virtual void executer(Contexte & contexte, Driver & driver) const = 0;
};

using InstructionPtr = std::shared_ptr<Instruction>;

class Bloc : public Instruction {
public:
    void ajouter(InstructionPtr instr) {
        _instructions.push_back(instr);
    }
    void executer(Contexte & contexte, Driver & driver) const override;

private:
    std::vector<InstructionPtr> _instructions;
};

class CommandeMouvement : public Instruction {
public:
    CommandeMouvement(ExpressionPtr valeur, TypeMouvement type)
        : _valeur(valeur), _type(type) {}

    void executer(Contexte & ctx, Driver & driver) const override {
        double val = _valeur->calculer(ctx);
        bouger(driver, _type, val);
    }

private:
    void bouger(Driver& driver, TypeMouvement type, double val) const;
    ExpressionPtr _valeur;
    TypeMouvement _type;
};

class CommandeCouleur : public Instruction {
public:
    CommandeCouleur(double r, double g, double b) : _r(r), _g(g), _b(b) {}

    void executer(Contexte &, Driver & driver) const override {
        changerCouleur(driver, _r, _g, _b);
    }
private:
    void changerCouleur(Driver& driver, double r, double g, double b) const;
    double _r, _g, _b;
};

class CommandeSelectionTortue : public Instruction {
public:
    CommandeSelectionTortue(ExpressionPtr id) : _id(id) {}
    void executer(Contexte & ctx, Driver &) const override {
        ctx.tortueCourante = (int)_id->calculer(ctx);
    }
private:
    ExpressionPtr _id;
};

class AppelFonction : public Instruction {
public:
    AppelFonction(const std::string & nom, const std::vector<ExpressionPtr> & args)
        : _nom(nom), _args(args) {}

    void executer(Contexte & ctx, Driver & driver) const override;

private:
    std::string _nom;
    std::vector<ExpressionPtr> _args;
};

// --- Structures de contrôle ---

class ControleSi : public Instruction {
public:
    ControleSi(std::shared_ptr<Condition> cond, InstructionPtr alors, InstructionPtr sinon = nullptr)
        : _condition(cond), _alors(alors), _sinon(sinon) {}

    void executer(Contexte & ctx, Driver & driver) const override {
        if (_condition->calculer(ctx, driver)) {
            _alors->executer(ctx, driver);
        } else if (_sinon) {
            _sinon->executer(ctx, driver);
        }
    }
private:
    std::shared_ptr<Condition> _condition;
    InstructionPtr _alors;
    InstructionPtr _sinon;
};

class ControleTantQue : public Instruction {
public:
    ControleTantQue(std::shared_ptr<Condition> cond, InstructionPtr bloc)
        : _condition(cond), _bloc(bloc) {}

    void executer(Contexte & ctx, Driver & driver) const override {
        while (_condition->calculer(ctx, driver)) {
            _bloc->executer(ctx, driver);
        }
    }
private:
    std::shared_ptr<Condition> _condition;
    InstructionPtr _bloc;
};

class ControleRepete : public Instruction {
public:
    ControleRepete(ExpressionPtr nb, InstructionPtr bloc)
        : _nb(nb), _bloc(bloc) {}

    void executer(Contexte & ctx, Driver & driver) const override {
        int n = (int)_nb->calculer(ctx);
        for(int i=0; i<n; ++i) _bloc->executer(ctx, driver);
    }
private:
    ExpressionPtr _nb;
    InstructionPtr _bloc;
};

inline void CommandeMouvement::bouger(Driver& d, TypeMouvement t, double v) const {
    extern void driver_bouger_wrapper(Driver&, TypeMouvement, double);
    driver_bouger_wrapper(d, t, v);
}

inline void CommandeCouleur::changerCouleur(Driver& d, double r, double g, double b) const {
    extern void driver_couleur_wrapper(Driver&, double, double, double);
    driver_couleur_wrapper(d, r, g, b);
}

#endif



==================================================
FICHIER : ./expressions/testBinaire.cc
==================================================
#include "testBinaire.hh"

bool TestBinaire::calculer(const Contexte & ctx, Driver &) const {
    double g = _gauche->calculer(ctx);
    double d = _droite->calculer(ctx);

    switch(_op) {
        case OperateurBool::egal: return g == d;
        case OperateurBool::different: return g != d;
        case OperateurBool::pluspetit: return g < d;
        case OperateurBool::plusgrand: return g > d;
    }
    return false;
}



==================================================
FICHIER : ./expressions/testBinaire.hh
==================================================
#ifndef TESTBINAIRE_HH
#define TESTBINAIRE_HH
#include "condition.hh"
#include "expression.hh"
#include "types.hh"

class TestBinaire : public Condition {
public:
    TestBinaire(ExpressionPtr g, ExpressionPtr d, OperateurBool op)
        : _gauche(g), _droite(d), _op(op) {}

    bool calculer(const Contexte & ctx, Driver &) const override;

private:
    ExpressionPtr _gauche;
    ExpressionPtr _droite;
    OperateurBool _op;
};
#endif



==================================================
FICHIER : ./expressions/types.hh
==================================================
#ifndef TYPES_HH
#define TYPES_HH

enum class TypeMouvement { AVANCE, RECULE, TOURNE, SAUTE };
enum class TypeCapteur { MUR, VIDE };
enum class Direction { DEVANT, DERRIERE, GAUCHE, DROITE };
enum class OperateurBinaire { plus, moins, multiplie, divise };
enum class OperateurUnaire { neg };
enum class OperateurBool { egal, different, pluspetit, plusgrand };
enum class OperateurBinaireBool { et, ou };

#endif



==================================================
FICHIER : ./expressions/variable.cc
==================================================
#include "variable.hh"
#include "contexte.hh"

Variable::Variable(const std::string & nom) : _nom(nom) {
}

double Variable::calculer(const Contexte & contexte) const {
    // CORRECTION : On utilise get() qui est compatible avec "const"
    return contexte.get(_nom);
}



==================================================
FICHIER : ./expressions/variable.hh
==================================================
#pragma once
#include <string>
#include "expression.hh"



class Variable : public Expression {
public:
    Variable() = delete;
    Variable(const Variable &) = default;
    Variable(const std::string & nom);
    
    double calculer(const Contexte& contexte) const override;


private:
    std::string _nom;
};



==================================================
FICHIER : ./fields/jardin0.txt
==================================================
____________________
____________________
____________________
____________________
____________________
____________________
____________________
_________T__________
____________________
____________________
____________________
____________________
____________________
____________________
____________________



==================================================
FICHIER : ./fields/jardin1.txt
==================================================
____________________
__T___________*_____
___*________________
____________________
_____________*______
____________________
____*_______________
_________T__________
__*_________________
____________________
______T______*______
_*__________________
____________________
______*_____________
____________________



==================================================
FICHIER : ./fields/jardin2.txt
==================================================
_____________________
__TT_***_____________
__TT*****____________
___T*****T___________
____TT_TT____________
____TT_TT___*__*___*_
_____________________




==================================================
FICHIER : ./fields/jardin3.txt
==================================================
     #####
    #  #  #
   #       #
   # # #   #
   # # #   ##
  ## # #   *#
 ##****   ***#        
 #*  *********#
#*# #*********#
#*************#
#*******#*****#
#*******#****#T##
 #****####***#T#T#
 ##**#******####  #
   #####***#  #T#TT#
      ###**##  #T#T#
     #  ### ####TT###
     #      #***##TT#
    ###     #****#TT#
    #*###   ###***#T#
    #**#   ##*****## 
    #**#### #*****# #
    #**#    #****#  #
    #**#    #########
     #####      ##  #
      ########### TTT#
     ##TTT#     ###TT#
    # TTTTT#   #  TT #
    #      #   #    #
    ########   #####



==================================================
FICHIER : ./fields/jardin4.txt
==================================================
____________________
____________________
________________*___
____________________
____________________
___*_____*______*___
_________*__________
________________*___
___*________________
_________*______T___
____________________
___T________________
____________________
_________T__________
____________________



==================================================
FICHIER : ./GUI/jardin.cc
==================================================
#include "jardin.hh"
#include "jardinHandler.hh"
#include <iostream>
#include <cmath>
#include <QPaintEvent>
#include <QResizeEvent>

Jardin::Jardin(const std::string & titre, QWidget *parent)
    : QWidget(parent), m_couleurCrayon(Qt::black)
{
    setWindowTitle(QString::fromStdString(titre.empty() ? "Tortue V4 - Precision Float" : titre));
    m_handler = new JardinHandler(this);
    resize(800, 600);

    TortueInfo t;
    t.x = 0; t.y = 0; t.angle = -90; // Regarde vers le haut
    t.couleur = Qt::red;
    m_tortues.push_back(t);
}

JardinHandler* Jardin::getHandler() { return m_handler; }

void Jardin::construction(std::string nom) {
    std::cout << "[Jardin] Chargement : " << nom << std::endl;
}

int Jardin::nombreTortues() { return m_tortues.size(); }

// Retourne des floats !
PointF Jardin::position(int id) {
    if(id < 0 || id >= (int)m_tortues.size()) return {0.0f, 0.0f};
    return {m_tortues[id].x, m_tortues[id].y};
}

float Jardin::orientation(int id) {
    if(id < 0 || id >= (int)m_tortues.size()) return 0.0f;
    return m_tortues[id].angle;
}

void Jardin::changePosition(int id, float x, float y) {
    if(id < 0 || id >= (int)m_tortues.size()) return;

    float oldX = m_tortues[id].x;
    float oldY = m_tortues[id].y;

    m_tortues[id].x = x;
    m_tortues[id].y = y;

    dessinerLigne(oldX, oldY, x, y);
}

void Jardin::changeOrientation(int id, float angle) {
    if(id < 0 || id >= (int)m_tortues.size()) return;
    m_tortues[id].angle = angle;
}

void Jardin::changeCouleur(int id, int r, int g, int b) {
    if(id < 0 || id >= (int)m_tortues.size()) return;
    m_tortues[id].couleur = QColor(r,g,b);
}

bool Jardin::estMur(int, int) { return false; }
bool Jardin::estVide(int, int) { return true; }

void Jardin::changerCouleur(int r, int g, int b) {
    m_couleurCrayon = QColor(r, g, b);
}

void Jardin::dessinerLigne(float x1, float y1, float x2, float y2) {
    // Affichage console précis
    std::cout << "[GUI] Ligne: (" << x1 << "," << y1 << ") -> (" << x2 << "," << y2 << ")" << std::endl;

    QPainter painter(&m_buffer);

    // CENTRE DE L'ECRAN (400, 300)
    float offsetX = 400;
    float offsetY = 300;

    QPen pen;
    pen.setColor(m_couleurCrayon);
    pen.setWidth(3);
    painter.setPen(pen);

    // Note: On n'applique plus de zoom ici car le Driver s'en charge
    painter.drawLine(x1 + offsetX, y1 + offsetY, x2 + offsetX, y2 + offsetY);
    update();
}

void Jardin::resizeEvent(QResizeEvent *event) {
    QPixmap newBuffer(event->size());
    newBuffer.fill(Qt::white);
    if (!m_buffer.isNull()) {
        QPainter p(&newBuffer);
        p.drawPixmap(0, 0, m_buffer);
    }
    m_buffer = newBuffer;
    QWidget::resizeEvent(event);
}

void Jardin::paintEvent(QPaintEvent *) {
    QPainter painter(this);
    painter.drawPixmap(0, 0, m_buffer);
}



==================================================
FICHIER : ./GUI/jardinHandler.cc
==================================================
#include "jardinHandler.hh"
#include <fstream>

JardinHandler::JardinHandler(JardinRendering * J, QObject *parent)
    : QThread(parent)
{
    restart = false;
    abort = false;
    driver = new Driver(this); 
    scanner = new Scanner(std::cin, std::cout);
    parser = new yy::Parser(*scanner, *driver);
    jardin = J;
}

JardinHandler::~JardinHandler()
{
    mutex.lock();
    abort = true;
    condition.wakeOne();
    mutex.unlock();

    wait();

    delete driver;
    delete scanner;
    delete parser;
}

void JardinHandler::parsingJardin()
{
    QMutexLocker locker(&mutex);

    if (!isRunning()) {
        start(LowPriority);
    } else {
        restart = true;
        condition.wakeOne();
    }
}

void JardinHandler::dessiner(){
    first = true;
}

void JardinHandler::run()
{
    if (first) {
        first = false;
        mutex.lock();
	
        parser->parse();

        mutex.unlock();
        emit parse();
        //emit parsingFinish();
    }
}



==================================================
FICHIER : ./GUI/jardinHandler.hh
==================================================
#ifndef JARDINHANDLER_H
#define JARDINHANDLER_H

#include "parser.hh"
#include "scanner.hh"
#include "driver.hh"
#include "jardinRendering.hh"
#include <queue>
#include <QMutex>
#include <QSize>
#include <QThread>
#include <QWaitCondition>

class JardinHandler : public QThread
{
    Q_OBJECT

public:
    JardinHandler(JardinRendering * J, QObject *parent = 0);
    ~JardinHandler();
    void parsingJardin();
    JardinRendering * getJardin() {return jardin;}
    void dessiner();
    
signals:
    void parse();

protected:
    void run() override;

private:
    Driver * driver;
    Scanner * scanner;
    yy::Parser * parser;

    JardinRendering * jardin;

    QMutex mutex;
    QWaitCondition condition;
    bool restart;
    bool abort;
    bool first = true;
};

#endif



==================================================
FICHIER : ./GUI/jardin.hh
==================================================
#ifndef JARDIN_HH
#define JARDIN_HH

#include <QWidget>
#include <QPixmap>
#include <QPainter>
#include <vector>
#include "jardinRendering.hh"

class JardinHandler;

struct TortueInfo {
    float x, y;
    float angle;
    QColor couleur;
};

class Jardin : public QWidget, public JardinRendering {
    Q_OBJECT

public:
    explicit Jardin(const std::string & titre, QWidget *parent = nullptr);
    ~Jardin() {}

    void construction(std::string nom) override;
    int nombreTortues() override;

    // Nouvelles signatures float
    PointF position(int id) override;
    float orientation(int id) override;
    void changePosition(int id, float x, float y) override;
    void changeOrientation(int id, float angle) override;
    void changeCouleur(int id, int r, int g, int b) override;

    void dessinerLigne(float x1, float y1, float x2, float y2) override;
    void changerCouleur(int r, int g, int b) override;

    bool estMur(int x, int y) override;
    bool estVide(int x, int y) override;

    JardinHandler* getHandler();

protected:
    void paintEvent(QPaintEvent *event) override;
    void resizeEvent(QResizeEvent *event) override;

private:
    QPixmap m_buffer;
    JardinHandler* m_handler;
    QColor m_couleurCrayon;
    std::vector<TortueInfo> m_tortues;
};

#endif



==================================================
FICHIER : ./GUI/jardinRendering.cc
==================================================
#include "jardinRendering.hh"



==================================================
FICHIER : ./GUI/jardinRendering.hh
==================================================
#ifndef JARDINRENDERING_HH
#define JARDINRENDERING_HH

#include <string>

// Structure simple pour gérer des coordonnées précises
struct PointF {
    float x;
    float y;
};

class JardinRendering {
public:
    virtual ~JardinRendering() {};

    virtual void construction(std::string nom) = 0;
    virtual int nombreTortues() = 0;

    // ON UTILISE MAINTENANT PointF (float) ET NON QPoint (int)
    virtual PointF position(int id) = 0;
    virtual float orientation(int id) = 0;

    virtual void changePosition(int id, float x, float y) = 0;
    virtual void changeOrientation(int id, float angle) = 0;
    virtual void changeCouleur(int id, int r, int g, int b) = 0;

    virtual void dessinerLigne(float x1, float y1, float x2, float y2) = 0;
    virtual void changerCouleur(int r, int g, int b) = 0;

    virtual bool estMur(int x, int y) = 0;
    virtual bool estVide(int x, int y) = 0;
};

#endif



==================================================
FICHIER : ./GUI/tortue.cc
==================================================
#include "tortue.hh"

Tortue::Tortue(int x, int y):posX(x),posY(y),width(35),height(35),orientation(0){
	imageTortue = QPixmap("../GUI/IMG/tortue.png");
	corps = imageTortue.createMaskFromColor(QColor(255, 200, 67),Qt::MaskOutColor);
	carapace = imageTortue.createMaskFromColor(QColor(0, 255, 0),Qt::MaskOutColor);
	motif = imageTortue.createMaskFromColor(QColor(0, 170, 0),Qt::MaskOutColor);
	couleurCorps = QColor(255,200,67);
	couleurCarapace = QColor(0,255,0);
	couleurMotif = QColor(0,170,0);
}

Tortue::~Tortue(){
}

int Tortue::getX(){
	return posX;
}

int Tortue::getY(){
	return posY;
}

int Tortue::getWidth(){
	return width;
}

int Tortue::getHeight(){
	return height;
}

QRect Tortue::getPos(){
	return QRect(posX*width,posY*height,width,height);
}

float Tortue::getOrientation(){
	return orientation;
}

void Tortue::poserStylo(){
        stylo = true;
}

void Tortue::leverStylo(){
        stylo = false;
}

QBitmap Tortue::getCorps(){
	return corps;
}

QBitmap Tortue::getCarapace(){
	return carapace;
}

QBitmap Tortue::getMotif(){
	return motif;
}

void Tortue::setCouleurCorps(QColor couleur){
	couleurCorps = couleur;
}

void Tortue::setCouleurCarapace(QColor couleur){
	couleurCarapace = couleur;
}

void Tortue::setCouleurMotif(QColor couleur){
	couleurMotif = couleur;
}

QColor Tortue::getCouleurCorps(){
	return couleurCorps;
}

QColor Tortue::getCouleurCarapace(){
	return couleurCarapace;
}

QColor Tortue::getCouleurMotif(){
	return couleurMotif;
}

void Tortue::setX(int x){
	posX=x;
}

void Tortue::setY(int y){
	posY=y;
}

void Tortue::setOrientation(float o){
	orientation=o;
}

bool Tortue::styloIsPose(){
       return stylo;
}



==================================================
FICHIER : ./GUI/tortue.hh
==================================================
#ifndef TORTUE_H
#define TORTUE_H

#include <QtGui>
#include <QtWidgets/QMainWindow>
#include <QtWidgets/QLayout>
#include <vector>

class Tortue
{
	private:
		int posX;
		int posY;
		int width;
		int height;
		float orientation;
        bool stylo = false;
		QPixmap imageTortue;
		QBitmap corps;
		QBitmap carapace;
		QBitmap motif;
		QColor couleurCorps;
		QColor couleurCarapace;
		QColor couleurMotif;

	public:
		int getX();
		int getY();
		int getWidth();
		int getHeight();
        QRect getPos();
		float getOrientation();
		QBitmap getCorps();
		QBitmap getCarapace();
		QBitmap getMotif();
		QColor getCouleurCorps();
		QColor getCouleurCarapace();
		QColor getCouleurMotif();
        bool styloIsPose();

		void setX(int x);
		void setY(int y);
		void setOrientation(float o);
		void setCouleurCorps(QColor);
		void setCouleurCarapace(QColor);
		void setCouleurMotif(QColor);
        void poserStylo();
        void leverStylo();
		Tortue(int x=0, int y=0);
		~Tortue();
};


#endif



==================================================
FICHIER : ./moc_jardin.cpp
==================================================
/****************************************************************************
** Meta object code from reading C++ file 'jardin.hh'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.15)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "GUI/jardin.hh"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'jardin.hh' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.15. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_Jardin_t {
    QByteArrayData data[1];
    char stringdata0[7];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_Jardin_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_Jardin_t qt_meta_stringdata_Jardin = {
    {
QT_MOC_LITERAL(0, 0, 6) // "Jardin"

    },
    "Jardin"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_Jardin[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

void Jardin::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

QT_INIT_METAOBJECT const QMetaObject Jardin::staticMetaObject = { {
    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),
    qt_meta_stringdata_Jardin.data,
    qt_meta_data_Jardin,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *Jardin::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *Jardin::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_Jardin.stringdata0))
        return static_cast<void*>(this);
    if (!strcmp(_clname, "JardinRendering"))
        return static_cast< JardinRendering*>(this);
    return QWidget::qt_metacast(_clname);
}

int Jardin::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QWidget::qt_metacall(_c, _id, _a);
    return _id;
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE



==================================================
FICHIER : ./moc_jardinHandler.cpp
==================================================
/****************************************************************************
** Meta object code from reading C++ file 'jardinHandler.hh'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.15)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <memory>
#include "GUI/jardinHandler.hh"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'jardinHandler.hh' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.15.15. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
struct qt_meta_stringdata_JardinHandler_t {
    QByteArrayData data[3];
    char stringdata0[21];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_JardinHandler_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_JardinHandler_t qt_meta_stringdata_JardinHandler = {
    {
QT_MOC_LITERAL(0, 0, 13), // "JardinHandler"
QT_MOC_LITERAL(1, 14, 5), // "parse"
QT_MOC_LITERAL(2, 20, 0) // ""

    },
    "JardinHandler\0parse\0"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_JardinHandler[] = {

 // content:
       8,       // revision
       0,       // classname
       0,    0, // classinfo
       1,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       1,       // signalCount

 // signals: name, argc, parameters, tag, flags
       1,    0,   19,    2, 0x06 /* Public */,

 // signals: parameters
    QMetaType::Void,

       0        // eod
};

void JardinHandler::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<JardinHandler *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->parse(); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (JardinHandler::*)();
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&JardinHandler::parse)) {
                *result = 0;
                return;
            }
        }
    }
    (void)_a;
}

QT_INIT_METAOBJECT const QMetaObject JardinHandler::staticMetaObject = { {
    QMetaObject::SuperData::link<QThread::staticMetaObject>(),
    qt_meta_stringdata_JardinHandler.data,
    qt_meta_data_JardinHandler,
    qt_static_metacall,
    nullptr,
    nullptr
} };


const QMetaObject *JardinHandler::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *JardinHandler::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_JardinHandler.stringdata0))
        return static_cast<void*>(this);
    return QThread::qt_metacast(_clname);
}

int JardinHandler::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QThread::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 1)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 1;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 1)
            *reinterpret_cast<int*>(_a[0]) = -1;
        _id -= 1;
    }
    return _id;
}

// SIGNAL 0
void JardinHandler::parse()
{
    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE



==================================================
FICHIER : ./moc_jardinRendering.cpp
==================================================



==================================================
FICHIER : ./moc_predefs.h
==================================================
#define __DBL_MIN_EXP__ (-1021)
#define __cpp_nontype_template_parameter_auto 201606L
#define __UINT_LEAST16_MAX__ 0xffff
#define __FLT16_HAS_QUIET_NAN__ 1
#define __ATOMIC_ACQUIRE 2
#define __FLT128_MAX_10_EXP__ 4932
#define __FLT_MIN__ 1.17549435082228750796873653722224568e-38F
#define __GCC_IEC_559_COMPLEX 2
#define __cpp_aggregate_nsdmi 201304L
#define __UINT_LEAST8_TYPE__ unsigned char
#define __SIZEOF_FLOAT80__ 16
#define __BFLT16_DENORM_MIN__ 9.18354961579912115600575419704879436e-41BF16
#define __INTMAX_C(c) c ## L
#define __CHAR_BIT__ 8
#define __UINT8_MAX__ 0xff
#define __SCHAR_WIDTH__ 8
#define __WINT_MAX__ 0xffffffffU
#define __FLT32_MIN_EXP__ (-125)
#define __cpp_static_assert 201411L
#define __BFLT16_MIN_10_EXP__ (-37)
#define __ORDER_LITTLE_ENDIAN__ 1234
#define __WCHAR_MAX__ 0x7fffffff
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
#define __GCC_ATOMIC_CHAR_LOCK_FREE 2
#define __GCC_IEC_559 2
#define __FLT32X_DECIMAL_DIG__ 17
#define __FLT_EVAL_METHOD__ 0
#define __cpp_binary_literals 201304L
#define __FLT64_DECIMAL_DIG__ 17
#define __cpp_noexcept_function_type 201510L
#define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2
#define __cpp_variadic_templates 200704L
#define __UINT_FAST64_MAX__ 0xffffffffffffffffUL
#define __SIG_ATOMIC_TYPE__ int
#define __DBL_MIN_10_EXP__ (-307)
#define __FINITE_MATH_ONLY__ 0
#define __cpp_variable_templates 201304L
#define __FLT32X_MAX_EXP__ 1024
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
#define __FLT32_HAS_DENORM__ 1
#define __UINT_FAST8_MAX__ 0xff
#define __cpp_rvalue_reference 200610L
#define __cpp_nested_namespace_definitions 201411L
#define __DEC64_MAX_EXP__ 385
#define __INT8_C(c) c
#define __LDBL_HAS_INFINITY__ 1
#define __INT_LEAST8_WIDTH__ 8
#define __cpp_variadic_using 201611L
#define __UINT_LEAST64_MAX__ 0xffffffffffffffffUL
#define __INT_LEAST8_MAX__ 0x7f
#define __cpp_attributes 200809L
#define __cpp_capture_star_this 201603L
#define __SHRT_MAX__ 0x7fff
#define __LDBL_MAX__ 1.18973149535723176502126385303097021e+4932L
#define __FLT64X_MAX_10_EXP__ 4932
#define __cpp_if_constexpr 201606L
#define __BFLT16_MAX_10_EXP__ 38
#define __BFLT16_MAX_EXP__ 128
#define __LDBL_IS_IEC_60559__ 1
#define __FLT64X_HAS_QUIET_NAN__ 1
#define __UINT_LEAST8_MAX__ 0xff
#define __GCC_ATOMIC_BOOL_LOCK_FREE 2
#define __FLT128_DENORM_MIN__ 6.47517511943802511092443895822764655e-4966F128
#define __UINTMAX_TYPE__ long unsigned int
#define __cpp_nsdmi 200809L
#define __BFLT16_DECIMAL_DIG__ 4
#define __linux 1
#define __DEC32_EPSILON__ 1E-6DF
#define __FLT_EVAL_METHOD_TS_18661_3__ 0
#define __OPTIMIZE__ 1
#define __UINT32_MAX__ 0xffffffffU
#define __GXX_EXPERIMENTAL_CXX0X__ 1
#define __DBL_DENORM_MIN__ double(4.94065645841246544176568792868221372e-324L)
#define __FLT128_MIN_EXP__ (-16381)
#define __WINT_MIN__ 0U
#define __FLT128_MIN_10_EXP__ (-4931)
#define __FLT32X_IS_IEC_60559__ 1
#define __INT_LEAST16_WIDTH__ 16
#define __SCHAR_MAX__ 0x7f
#define __FLT128_MANT_DIG__ 113
#define __WCHAR_MIN__ (-__WCHAR_MAX__ - 1)
#define __INT64_C(c) c ## L
#define __GCC_ATOMIC_POINTER_LOCK_FREE 2
#define __ATOMIC_SEQ_CST 5
#define __unix 1
#define __INT_LEAST64_MAX__ 0x7fffffffffffffffL
#define __FLT32X_MANT_DIG__ 53
#define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 2
#define __cpp_aligned_new 201606L
#define __FLT32_MAX_10_EXP__ 38
#define __FLT64X_EPSILON__ 1.08420217248550443400745280086994171e-19F64x
#define __STDC_HOSTED__ 1
#define __DEC64_MIN_EXP__ (-382)
#define __cpp_decltype_auto 201304L
#define __DBL_DIG__ 15
#define __FLT_EPSILON__ 1.19209289550781250000000000000000000e-7F
#define __GXX_WEAK__ 1
#define __SHRT_WIDTH__ 16
#define __FLT32_IS_IEC_60559__ 1
#define __LDBL_MIN__ 3.36210314311209350626267781732175260e-4932L
#define __DBL_IS_IEC_60559__ 1
#define __DEC32_MAX__ 9.999999E96DF
#define __cpp_threadsafe_static_init 200806L
#define __cpp_enumerator_attributes 201411L
#define __FLT64X_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951F64x
#define __FLT32X_HAS_INFINITY__ 1
#define __unix__ 1
#define __INT_WIDTH__ 32
#define __STDC_IEC_559__ 1
#define __STDC_ISO_10646__ 201706L
#define __DECIMAL_DIG__ 21
#define __STDC_IEC_559_COMPLEX__ 1
#define __FLT64_EPSILON__ 2.22044604925031308084726333618164062e-16F64
#define __gnu_linux__ 1
#define __INT16_MAX__ 0x7fff
#define __FLT64_MIN_EXP__ (-1021)
#define __FLT64X_MIN_10_EXP__ (-4931)
#define __LDBL_HAS_QUIET_NAN__ 1
#define __cpp_return_type_deduction 201304L
#define __FLT16_MIN_EXP__ (-13)
#define __FLT64_MANT_DIG__ 53
#define __FLT64X_MANT_DIG__ 64
#define __BFLT16_DIG__ 2
#define __GNUC__ 14
#define __GXX_RTTI 1
#define __pie__ 2
#define __MMX__ 1
#define __FLT_HAS_DENORM__ 1
#define __SIZEOF_LONG_DOUBLE__ 16
#define __BIGGEST_ALIGNMENT__ 16
#define __STDC_UTF_16__ 1
#define __FLT64_MAX_10_EXP__ 308
#define __BFLT16_IS_IEC_60559__ 0
#define __FLT16_MAX_10_EXP__ 4
#define __cpp_delegating_constructors 200604L
#define __DBL_MAX__ double(1.79769313486231570814527423731704357e+308L)
#define __cpp_raw_strings 200710L
#define __INT_FAST32_MAX__ 0x7fffffffffffffffL
#define __DBL_HAS_INFINITY__ 1
#define __INT64_MAX__ 0x7fffffffffffffffL
#define __SIZEOF_FLOAT__ 4
#define __HAVE_SPECULATION_SAFE_VALUE 1
#define __cpp_fold_expressions 201603L
#define __DEC32_MIN_EXP__ (-94)
#define __INTPTR_WIDTH__ 64
#define __UINT_LEAST32_MAX__ 0xffffffffU
#define __FLT32X_HAS_DENORM__ 1
#define __INT_FAST16_TYPE__ long int
#define __MMX_WITH_SSE__ 1
#define __LDBL_HAS_DENORM__ 1
#define __SEG_GS 1
#define __BFLT16_EPSILON__ 7.81250000000000000000000000000000000e-3BF16
#define __cplusplus 201703L
#define __cpp_ref_qualifiers 200710L
#define __DEC32_MIN__ 1E-95DF
#define __DEPRECATED 1
#define __cpp_rvalue_references 200610L
#define __DBL_MAX_EXP__ 1024
#define __WCHAR_WIDTH__ 32
#define __FLT32_MAX__ 3.40282346638528859811704183484516925e+38F32
#define __DEC128_EPSILON__ 1E-33DL
#define __FLT16_DECIMAL_DIG__ 5
#define __SSE2_MATH__ 1
#define __ATOMIC_HLE_RELEASE 131072
#define __PTRDIFF_MAX__ 0x7fffffffffffffffL
#define __amd64 1
#define __ATOMIC_HLE_ACQUIRE 65536
#define __GNUG__ 14
#define __LONG_LONG_MAX__ 0x7fffffffffffffffLL
#define __SIZEOF_SIZE_T__ 8
#define __BFLT16_HAS_INFINITY__ 1
#define __FLT64X_MIN_EXP__ (-16381)
#define __SIZEOF_WINT_T__ 4
#define __FLT32X_DIG__ 15
#define __LONG_LONG_WIDTH__ 64
#define __cpp_initializer_lists 200806L
#define __FLT32_MAX_EXP__ 128
#define __cpp_hex_float 201603L
#define __GXX_ABI_VERSION 1019
#define __FLT_MIN_EXP__ (-125)
#define __GCC_HAVE_DWARF2_CFI_ASM 1
#define __x86_64 1
#define __cpp_lambdas 200907L
#define __INT_FAST64_TYPE__ long int
#define __BFLT16_MAX__ 3.38953138925153547590470800371487867e+38BF16
#define __FLT64_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F64
#define __cpp_template_auto 201606L
#define __FLT16_DENORM_MIN__ 5.96046447753906250000000000000000000e-8F16
#define __FLT128_EPSILON__ 1.92592994438723585305597794258492732e-34F128
#define __FLT64X_NORM_MAX__ 1.18973149535723176502126385303097021e+4932F64x
#define __SIZEOF_POINTER__ 8
#define __SIZE_TYPE__ long unsigned int
#define __LP64__ 1
#define __DBL_HAS_QUIET_NAN__ 1
#define __FLT32X_EPSILON__ 2.22044604925031308084726333618164062e-16F32x
#define __LDBL_MAX_EXP__ 16384
#define __DECIMAL_BID_FORMAT__ 1
#define __FLT64_MIN_10_EXP__ (-307)
#define __FLT16_MIN_10_EXP__ (-4)
#define __FLT64X_DECIMAL_DIG__ 21
#define __DEC128_MIN__ 1E-6143DL
#define __REGISTER_PREFIX__ 
#define __UINT16_MAX__ 0xffff
#define __FLT128_HAS_INFINITY__ 1
#define __FLT32_MIN__ 1.17549435082228750796873653722224568e-38F32
#define __UINT8_TYPE__ unsigned char
#define __FLT_DIG__ 6
#define __DEC_EVAL_METHOD__ 2
#define __FLT_MANT_DIG__ 24
#define __LDBL_DECIMAL_DIG__ 21
#define __VERSION__ "14.2.0"
#define __UINT64_C(c) c ## UL
#define __cpp_unicode_characters 201411L
#define _STDC_PREDEF_H 1
#define __INT_LEAST32_MAX__ 0x7fffffff
#define __GCC_ATOMIC_INT_LOCK_FREE 2
#define __FLT128_MAX_EXP__ 16384
#define __FLT32_MANT_DIG__ 24
#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__
#define __FLT32X_MIN_EXP__ (-1021)
#define __STDC_IEC_60559_COMPLEX__ 201404L
#define __cpp_aggregate_bases 201603L
#define __BFLT16_MIN__ 1.17549435082228750796873653722224568e-38BF16
#define __FLT128_HAS_DENORM__ 1
#define __FLT32_DECIMAL_DIG__ 9
#define __FLT128_DIG__ 33
#define __INT32_C(c) c
#define __DEC64_EPSILON__ 1E-15DD
#define __ORDER_PDP_ENDIAN__ 3412
#define __DEC128_MIN_EXP__ (-6142)
#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
#define __INT_FAST32_TYPE__ long int
#define __UINT_LEAST16_TYPE__ short unsigned int
#define __DEC128_MAX_EXP__ 6145
#define unix 1
#define __DBL_HAS_DENORM__ 1
#define __cpp_rtti 199711L
#define __UINT64_MAX__ 0xffffffffffffffffUL
#define __FLT_IS_IEC_60559__ 1
#define __GNUC_WIDE_EXECUTION_CHARSET_NAME "UTF-32LE"
#define __FLT64X_DIG__ 18
#define __INT8_TYPE__ signed char
#define __cpp_digit_separators 201309L
#define __ELF__ 1
#define __GCC_ASM_FLAG_OUTPUTS__ 1
#define __UINT32_TYPE__ unsigned int
#define __BFLT16_HAS_QUIET_NAN__ 1
#define __FLT_RADIX__ 2
#define __INT_LEAST16_TYPE__ short int
#define __LDBL_EPSILON__ 1.08420217248550443400745280086994171e-19L
#define __UINTMAX_C(c) c ## UL
#define __FLT16_DIG__ 3
#define __k8 1
#define __FLT32X_MIN__ 2.22507385850720138309023271733240406e-308F32x
#define __SIG_ATOMIC_MAX__ 0x7fffffff
#define __cpp_constexpr 201603L
#define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2
#define __USER_LABEL_PREFIX__ 
#define __STDC_IEC_60559_BFP__ 201404L
#define __SIZEOF_PTRDIFF_T__ 8
#define __FLT64X_HAS_INFINITY__ 1
#define __SIZEOF_LONG__ 8
#define __LDBL_DIG__ 18
#define __FLT64_IS_IEC_60559__ 1
#define __x86_64__ 1
#define __FLT16_IS_IEC_60559__ 1
#define __FLT16_MAX_EXP__ 16
#define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF
#define __INT_FAST16_MAX__ 0x7fffffffffffffffL
#define __GCC_CONSTRUCTIVE_SIZE 64
#define __FLT64_DIG__ 15
#define __UINT_FAST32_MAX__ 0xffffffffffffffffUL
#define __UINT_LEAST64_TYPE__ long unsigned int
#define __FLT16_EPSILON__ 9.76562500000000000000000000000000000e-4F16
#define __FLT_HAS_QUIET_NAN__ 1
#define __FLT_MAX_10_EXP__ 38
#define __FLT64X_HAS_DENORM__ 1
#define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL
#define __FLT_HAS_INFINITY__ 1
#define __GNUC_EXECUTION_CHARSET_NAME "UTF-8"
#define __cpp_unicode_literals 200710L
#define __UINT_FAST16_TYPE__ long unsigned int
#define __DEC64_MAX__ 9.999999999999999E384DD
#define __INT_FAST32_WIDTH__ 64
#define __CHAR16_TYPE__ short unsigned int
#define __PRAGMA_REDEFINE_EXTNAME 1
#define __SIZE_WIDTH__ 64
#define __SEG_FS 1
#define __INT_LEAST16_MAX__ 0x7fff
#define __FLT16_NORM_MAX__ 6.55040000000000000000000000000000000e+4F16
#define __DEC64_MANT_DIG__ 16
#define __FLT32_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F32
#define __SIG_ATOMIC_WIDTH__ 32
#define __INT_LEAST64_TYPE__ long int
#define __INT16_TYPE__ short int
#define __INT_LEAST8_TYPE__ signed char
#define __FLT16_MAX__ 6.55040000000000000000000000000000000e+4F16
#define __FLT128_MIN__ 3.36210314311209350626267781732175260e-4932F128
#define __cpp_structured_bindings 201606L
#define __SIZEOF_INT__ 4
#define __DEC32_MAX_EXP__ 97
#define __INT_FAST8_MAX__ 0x7f
#define __FLT128_MAX__ 1.18973149535723176508575932662800702e+4932F128
#define __INTPTR_MAX__ 0x7fffffffffffffffL
#define __cpp_sized_deallocation 201309L
#define __cpp_guaranteed_copy_elision 201606L
#define linux 1
#define __FLT64_HAS_QUIET_NAN__ 1
#define __FLT32_MIN_10_EXP__ (-37)
#define __EXCEPTIONS 1
#define __UINT16_C(c) c
#define __PTRDIFF_WIDTH__ 64
#define __LDBL_MANT_DIG__ 64
#define __cpp_range_based_for 201603L
#define __INT_FAST16_WIDTH__ 64
#define __FLT64_HAS_INFINITY__ 1
#define __FLT64X_MAX__ 1.18973149535723176502126385303097021e+4932F64x
#define __FLT16_HAS_INFINITY__ 1
#define __STDCPP_DEFAULT_NEW_ALIGNMENT__ 16
#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)
#define __code_model_small__ 1
#define __GCC_ATOMIC_LONG_LOCK_FREE 2
#define __cpp_nontype_template_args 201411L
#define __DEC32_MANT_DIG__ 7
#define __k8__ 1
#define __INTPTR_TYPE__ long int
#define __UINT16_TYPE__ short unsigned int
#define __WCHAR_TYPE__ int
#define __pic__ 2
#define __UINTPTR_MAX__ 0xffffffffffffffffUL
#define __INT_FAST64_WIDTH__ 64
#define __cpp_decltype 200707L
#define __INT_FAST64_MAX__ 0x7fffffffffffffffL
#define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1
#define __FLT_NORM_MAX__ 3.40282346638528859811704183484516925e+38F
#define __FLT32_HAS_INFINITY__ 1
#define __FLT64X_MAX_EXP__ 16384
#define __UINT_FAST64_TYPE__ long unsigned int
#define __cpp_inline_variables 201606L
#define __BFLT16_MIN_EXP__ (-125)
#define __INT_MAX__ 0x7fffffff
#define __linux__ 1
#define __INT64_TYPE__ long int
#define __FLT_MAX_EXP__ 128
#define __ORDER_BIG_ENDIAN__ 4321
#define __DBL_MANT_DIG__ 53
#define __cpp_inheriting_constructors 201511L
#define __SIZEOF_FLOAT128__ 16
#define __BFLT16_MANT_DIG__ 8
#define __DEC64_MIN__ 1E-383DD
#define __WINT_TYPE__ unsigned int
#define __UINT_LEAST32_TYPE__ unsigned int
#define __SIZEOF_SHORT__ 2
#define __FLT32_NORM_MAX__ 3.40282346638528859811704183484516925e+38F32
#define __SSE__ 1
#define __LDBL_MIN_EXP__ (-16381)
#define __FLT64_MAX__ 1.79769313486231570814527423731704357e+308F64
#define __amd64__ 1
#define __WINT_WIDTH__ 32
#define __INT_LEAST64_WIDTH__ 64
#define __FLT32X_MAX_10_EXP__ 308
#define __cpp_namespace_attributes 201411L
#define __SIZEOF_INT128__ 16
#define __FLT16_MIN__ 6.10351562500000000000000000000000000e-5F16
#define __FLT64X_IS_IEC_60559__ 1
#define __LDBL_MAX_10_EXP__ 4932
#define __ATOMIC_RELAXED 0
#define __DBL_EPSILON__ double(2.22044604925031308084726333618164062e-16L)
#define __INT_LEAST32_TYPE__ int
#define _LP64 1
#define __UINT8_C(c) c
#define __FLT64_MAX_EXP__ 1024
#define __SIZEOF_WCHAR_T__ 4
#define __GNUC_PATCHLEVEL__ 0
#define __FLT128_NORM_MAX__ 1.18973149535723176508575932662800702e+4932F128
#define __FLT64_NORM_MAX__ 1.79769313486231570814527423731704357e+308F64
#define __FLT128_HAS_QUIET_NAN__ 1
#define __INTMAX_MAX__ 0x7fffffffffffffffL
#define __INT_FAST8_TYPE__ signed char
#define __FLT64X_MIN__ 3.36210314311209350626267781732175260e-4932F64x
#define __STDCPP_THREADS__ 1
#define __BFLT16_HAS_DENORM__ 1
#define __GNUC_STDC_INLINE__ 1
#define __FLT64_HAS_DENORM__ 1
#define __FLT32_EPSILON__ 1.19209289550781250000000000000000000e-7F32
#define __FLT16_HAS_DENORM__ 1
#define __DBL_DECIMAL_DIG__ 17
#define __STDC_UTF_32__ 1
#define __INT_FAST8_WIDTH__ 8
#define __FXSR__ 1
#define __FLT32X_MAX__ 1.79769313486231570814527423731704357e+308F32x
#define __DBL_NORM_MAX__ double(1.79769313486231570814527423731704357e+308L)
#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__
#define __GCC_DESTRUCTIVE_SIZE 64
#define __INTMAX_WIDTH__ 64
#define __cpp_runtime_arrays 198712L
#define __FLT32_DIG__ 6
#define __UINT64_TYPE__ long unsigned int
#define __UINT32_C(c) c ## U
#define __cpp_alias_templates 200704L
#define __FLT_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F
#define __FLT128_IS_IEC_60559__ 1
#define __INT8_MAX__ 0x7f
#define __LONG_WIDTH__ 64
#define __DBL_MIN__ double(2.22507385850720138309023271733240406e-308L)
#define __PIC__ 2
#define __INT32_MAX__ 0x7fffffff
#define __UINT_FAST32_TYPE__ long unsigned int
#define __FLT16_MANT_DIG__ 11
#define __FLT32X_NORM_MAX__ 1.79769313486231570814527423731704357e+308F32x
#define __CHAR32_TYPE__ unsigned int
#define __FLT_MAX__ 3.40282346638528859811704183484516925e+38F
#define __SSE2__ 1
#define __cpp_deduction_guides 201703L
#define __BFLT16_NORM_MAX__ 3.38953138925153547590470800371487867e+38BF16
#define __INT32_TYPE__ int
#define __SIZEOF_DOUBLE__ 8
#define __cpp_exceptions 199711L
#define __FLT_MIN_10_EXP__ (-37)
#define __FLT64_MIN__ 2.22507385850720138309023271733240406e-308F64
#define __INT_LEAST32_WIDTH__ 32
#define __INTMAX_TYPE__ long int
#define __GLIBCXX_BITSIZE_INT_N_0 128
#define __FLT32X_HAS_QUIET_NAN__ 1
#define __ATOMIC_CONSUME 1
#define __GNUC_MINOR__ 2
#define __GLIBCXX_TYPE_INT_N_0 __int128
#define __UINTMAX_MAX__ 0xffffffffffffffffUL
#define __PIE__ 2
#define __FLT32X_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F32x
#define __cpp_template_template_args 201611L
#define __DBL_MAX_10_EXP__ 308
#define __LDBL_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951L
#define __INT16_C(c) c
#define __STDC__ 1
#define __PTRDIFF_TYPE__ long int
#define __LONG_MAX__ 0x7fffffffffffffffL
#define __FLT32X_MIN_10_EXP__ (-307)
#define __UINTPTR_TYPE__ long unsigned int
#define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD
#define __DEC128_MANT_DIG__ 34
#define __LDBL_MIN_10_EXP__ (-4931)
#define __cpp_generic_lambdas 201304L
#define __SSE_MATH__ 1
#define __SIZEOF_LONG_LONG__ 8
#define __cpp_user_defined_literals 200809L
#define __FLT128_DECIMAL_DIG__ 36
#define __GCC_ATOMIC_LLONG_LOCK_FREE 2
#define __FLT32_HAS_QUIET_NAN__ 1
#define __FLT_DECIMAL_DIG__ 9
#define __UINT_FAST16_MAX__ 0xffffffffffffffffUL
#define __LDBL_NORM_MAX__ 1.18973149535723176502126385303097021e+4932L
#define __GCC_ATOMIC_SHORT_LOCK_FREE 2
#define __SIZE_MAX__ 0xffffffffffffffffUL
#define __UINT_FAST8_TYPE__ unsigned char
#define _GNU_SOURCE 1
#define __cpp_init_captures 201304L
#define __ATOMIC_ACQ_REL 4
#define __ATOMIC_RELEASE 3



==================================================
FICHIER : ./parser.cc
==================================================
// A Bison parser, made by GNU Bison 3.8.2.

// Skeleton implementation for Bison LALR(1) parsers in C++

// Copyright (C) 2002-2015, 2018-2021 Free Software Foundation, Inc.

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// As a special exception, you may create a larger work that contains
// part or all of the Bison parser skeleton and distribute that work
// under terms of your choice, so long as that work isn't itself a
// parser generator using the skeleton or a modified version thereof
// as a parser skeleton.  Alternatively, if you modify or redistribute
// the parser skeleton itself, you may (at your option) remove this
// special exception, which will cause the skeleton and the resulting
// Bison output files to be licensed under the GNU General Public
// License without this special exception.

// This special exception was added by the Free Software Foundation in
// version 2.2 of Bison.

// DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,
// especially those whose name start with YY_ or yy_.  They are
// private implementation details that can be changed or removed.





#include "parser.hh"


// Unqualified %code blocks.
#line 34 "parser/parser.yy"

    #include <iostream>
    #include "scanner.hh"
    #include "driver.hh"

    #undef  yylex
    #define yylex scanner.yylex

#line 55 "parser.cc"


#ifndef YY_
# if defined YYENABLE_NLS && YYENABLE_NLS
#  if ENABLE_NLS
#   include <libintl.h> // FIXME: INFRINGES ON USER NAME SPACE.
#   define YY_(msgid) dgettext ("bison-runtime", msgid)
#  endif
# endif
# ifndef YY_
#  define YY_(msgid) msgid
# endif
#endif


// Whether we are compiled with exception support.
#ifndef YY_EXCEPTIONS
# if defined __GNUC__ && !defined __EXCEPTIONS
#  define YY_EXCEPTIONS 0
# else
#  define YY_EXCEPTIONS 1
# endif
#endif

#define YYRHSLOC(Rhs, K) ((Rhs)[K].location)
/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
   If N is 0, then set CURRENT to the empty location which ends
   the previous symbol: RHS[0] (always defined).  */

# ifndef YYLLOC_DEFAULT
#  define YYLLOC_DEFAULT(Current, Rhs, N)                               \
    do                                                                  \
      if (N)                                                            \
        {                                                               \
          (Current).begin  = YYRHSLOC (Rhs, 1).begin;                   \
          (Current).end    = YYRHSLOC (Rhs, N).end;                     \
        }                                                               \
      else                                                              \
        {                                                               \
          (Current).begin = (Current).end = YYRHSLOC (Rhs, 0).end;      \
        }                                                               \
    while (false)
# endif


// Enable debugging if requested.
#if YYDEBUG

// A pseudo ostream that takes yydebug_ into account.
# define YYCDEBUG if (yydebug_) (*yycdebug_)

# define YY_SYMBOL_PRINT(Title, Symbol)         \
  do {                                          \
    if (yydebug_)                               \
    {                                           \
      *yycdebug_ << Title << ' ';               \
      yy_print_ (*yycdebug_, Symbol);           \
      *yycdebug_ << '\n';                       \
    }                                           \
  } while (false)

# define YY_REDUCE_PRINT(Rule)          \
  do {                                  \
    if (yydebug_)                       \
      yy_reduce_print_ (Rule);          \
  } while (false)

# define YY_STACK_PRINT()               \
  do {                                  \
    if (yydebug_)                       \
      yy_stack_print_ ();                \
  } while (false)

#else // !YYDEBUG

# define YYCDEBUG if (false) std::cerr
# define YY_SYMBOL_PRINT(Title, Symbol)  YY_USE (Symbol)
# define YY_REDUCE_PRINT(Rule)           static_cast<void> (0)
# define YY_STACK_PRINT()                static_cast<void> (0)

#endif // !YYDEBUG

#define yyerrok         (yyerrstatus_ = 0)
#define yyclearin       (yyla.clear ())

#define YYACCEPT        goto yyacceptlab
#define YYABORT         goto yyabortlab
#define YYERROR         goto yyerrorlab
#define YYRECOVERING()  (!!yyerrstatus_)

namespace yy {
#line 147 "parser.cc"

  /// Build a parser object.
   Parser :: Parser  (Scanner &scanner_yyarg, Driver &driver_yyarg)
#if YYDEBUG
    : yydebug_ (false),
      yycdebug_ (&std::cerr),
#else
    :
#endif
      scanner (scanner_yyarg),
      driver (driver_yyarg)
  {}

   Parser ::~ Parser  ()
  {}

   Parser ::syntax_error::~syntax_error () YY_NOEXCEPT YY_NOTHROW
  {}

  /*---------.
  | symbol.  |
  `---------*/

  // basic_symbol.
  template <typename Base>
   Parser ::basic_symbol<Base>::basic_symbol (const basic_symbol& that)
    : Base (that)
    , value ()
    , location (that.location)
  {
    switch (this->kind ())
    {
      case symbol_kind::S_programme: // programme
      case symbol_kind::S_liste_instructions: // liste_instructions
        value.copy< Bloc* > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_condition: // condition
      case symbol_kind::S_condition_base: // condition_base
        value.copy< ConditionPtr > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_direction: // direction
        value.copy< Direction > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_expression: // expression
        value.copy< ExpressionPtr > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_instruction: // instruction
      case symbol_kind::S_commande: // commande
      case symbol_kind::S_structure_controle: // structure_controle
        value.copy< InstructionPtr > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_NUMBER: // NUMBER
        value.copy< double > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_VAR_NAME: // VAR_NAME
        value.copy< std::string > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_args_appel: // args_appel
        value.copy< std::vector<ExpressionPtr> > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_COLOR_HEX: // COLOR_HEX
        value.copy< std::vector<double> > (YY_MOVE (that.value));
        break;

      default:
        break;
    }

  }




  template <typename Base>
   Parser ::symbol_kind_type
   Parser ::basic_symbol<Base>::type_get () const YY_NOEXCEPT
  {
    return this->kind ();
  }


  template <typename Base>
  bool
   Parser ::basic_symbol<Base>::empty () const YY_NOEXCEPT
  {
    return this->kind () == symbol_kind::S_YYEMPTY;
  }

  template <typename Base>
  void
   Parser ::basic_symbol<Base>::move (basic_symbol& s)
  {
    super_type::move (s);
    switch (this->kind ())
    {
      case symbol_kind::S_programme: // programme
      case symbol_kind::S_liste_instructions: // liste_instructions
        value.move< Bloc* > (YY_MOVE (s.value));
        break;

      case symbol_kind::S_condition: // condition
      case symbol_kind::S_condition_base: // condition_base
        value.move< ConditionPtr > (YY_MOVE (s.value));
        break;

      case symbol_kind::S_direction: // direction
        value.move< Direction > (YY_MOVE (s.value));
        break;

      case symbol_kind::S_expression: // expression
        value.move< ExpressionPtr > (YY_MOVE (s.value));
        break;

      case symbol_kind::S_instruction: // instruction
      case symbol_kind::S_commande: // commande
      case symbol_kind::S_structure_controle: // structure_controle
        value.move< InstructionPtr > (YY_MOVE (s.value));
        break;

      case symbol_kind::S_NUMBER: // NUMBER
        value.move< double > (YY_MOVE (s.value));
        break;

      case symbol_kind::S_VAR_NAME: // VAR_NAME
        value.move< std::string > (YY_MOVE (s.value));
        break;

      case symbol_kind::S_args_appel: // args_appel
        value.move< std::vector<ExpressionPtr> > (YY_MOVE (s.value));
        break;

      case symbol_kind::S_COLOR_HEX: // COLOR_HEX
        value.move< std::vector<double> > (YY_MOVE (s.value));
        break;

      default:
        break;
    }

    location = YY_MOVE (s.location);
  }

  // by_kind.
   Parser ::by_kind::by_kind () YY_NOEXCEPT
    : kind_ (symbol_kind::S_YYEMPTY)
  {}

#if 201103L <= YY_CPLUSPLUS
   Parser ::by_kind::by_kind (by_kind&& that) YY_NOEXCEPT
    : kind_ (that.kind_)
  {
    that.clear ();
  }
#endif

   Parser ::by_kind::by_kind (const by_kind& that) YY_NOEXCEPT
    : kind_ (that.kind_)
  {}

   Parser ::by_kind::by_kind (token_kind_type t) YY_NOEXCEPT
    : kind_ (yytranslate_ (t))
  {}



  void
   Parser ::by_kind::clear () YY_NOEXCEPT
  {
    kind_ = symbol_kind::S_YYEMPTY;
  }

  void
   Parser ::by_kind::move (by_kind& that)
  {
    kind_ = that.kind_;
    that.clear ();
  }

   Parser ::symbol_kind_type
   Parser ::by_kind::kind () const YY_NOEXCEPT
  {
    return kind_;
  }


   Parser ::symbol_kind_type
   Parser ::by_kind::type_get () const YY_NOEXCEPT
  {
    return this->kind ();
  }



  // by_state.
   Parser ::by_state::by_state () YY_NOEXCEPT
    : state (empty_state)
  {}

   Parser ::by_state::by_state (const by_state& that) YY_NOEXCEPT
    : state (that.state)
  {}

  void
   Parser ::by_state::clear () YY_NOEXCEPT
  {
    state = empty_state;
  }

  void
   Parser ::by_state::move (by_state& that)
  {
    state = that.state;
    that.clear ();
  }

   Parser ::by_state::by_state (state_type s) YY_NOEXCEPT
    : state (s)
  {}

   Parser ::symbol_kind_type
   Parser ::by_state::kind () const YY_NOEXCEPT
  {
    if (state == empty_state)
      return symbol_kind::S_YYEMPTY;
    else
      return YY_CAST (symbol_kind_type, yystos_[+state]);
  }

   Parser ::stack_symbol_type::stack_symbol_type ()
  {}

   Parser ::stack_symbol_type::stack_symbol_type (YY_RVREF (stack_symbol_type) that)
    : super_type (YY_MOVE (that.state), YY_MOVE (that.location))
  {
    switch (that.kind ())
    {
      case symbol_kind::S_programme: // programme
      case symbol_kind::S_liste_instructions: // liste_instructions
        value.YY_MOVE_OR_COPY< Bloc* > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_condition: // condition
      case symbol_kind::S_condition_base: // condition_base
        value.YY_MOVE_OR_COPY< ConditionPtr > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_direction: // direction
        value.YY_MOVE_OR_COPY< Direction > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_expression: // expression
        value.YY_MOVE_OR_COPY< ExpressionPtr > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_instruction: // instruction
      case symbol_kind::S_commande: // commande
      case symbol_kind::S_structure_controle: // structure_controle
        value.YY_MOVE_OR_COPY< InstructionPtr > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_NUMBER: // NUMBER
        value.YY_MOVE_OR_COPY< double > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_VAR_NAME: // VAR_NAME
        value.YY_MOVE_OR_COPY< std::string > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_args_appel: // args_appel
        value.YY_MOVE_OR_COPY< std::vector<ExpressionPtr> > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_COLOR_HEX: // COLOR_HEX
        value.YY_MOVE_OR_COPY< std::vector<double> > (YY_MOVE (that.value));
        break;

      default:
        break;
    }

#if 201103L <= YY_CPLUSPLUS
    // that is emptied.
    that.state = empty_state;
#endif
  }

   Parser ::stack_symbol_type::stack_symbol_type (state_type s, YY_MOVE_REF (symbol_type) that)
    : super_type (s, YY_MOVE (that.location))
  {
    switch (that.kind ())
    {
      case symbol_kind::S_programme: // programme
      case symbol_kind::S_liste_instructions: // liste_instructions
        value.move< Bloc* > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_condition: // condition
      case symbol_kind::S_condition_base: // condition_base
        value.move< ConditionPtr > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_direction: // direction
        value.move< Direction > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_expression: // expression
        value.move< ExpressionPtr > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_instruction: // instruction
      case symbol_kind::S_commande: // commande
      case symbol_kind::S_structure_controle: // structure_controle
        value.move< InstructionPtr > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_NUMBER: // NUMBER
        value.move< double > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_VAR_NAME: // VAR_NAME
        value.move< std::string > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_args_appel: // args_appel
        value.move< std::vector<ExpressionPtr> > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_COLOR_HEX: // COLOR_HEX
        value.move< std::vector<double> > (YY_MOVE (that.value));
        break;

      default:
        break;
    }

    // that is emptied.
    that.kind_ = symbol_kind::S_YYEMPTY;
  }

#if YY_CPLUSPLUS < 201103L
   Parser ::stack_symbol_type&
   Parser ::stack_symbol_type::operator= (const stack_symbol_type& that)
  {
    state = that.state;
    switch (that.kind ())
    {
      case symbol_kind::S_programme: // programme
      case symbol_kind::S_liste_instructions: // liste_instructions
        value.copy< Bloc* > (that.value);
        break;

      case symbol_kind::S_condition: // condition
      case symbol_kind::S_condition_base: // condition_base
        value.copy< ConditionPtr > (that.value);
        break;

      case symbol_kind::S_direction: // direction
        value.copy< Direction > (that.value);
        break;

      case symbol_kind::S_expression: // expression
        value.copy< ExpressionPtr > (that.value);
        break;

      case symbol_kind::S_instruction: // instruction
      case symbol_kind::S_commande: // commande
      case symbol_kind::S_structure_controle: // structure_controle
        value.copy< InstructionPtr > (that.value);
        break;

      case symbol_kind::S_NUMBER: // NUMBER
        value.copy< double > (that.value);
        break;

      case symbol_kind::S_VAR_NAME: // VAR_NAME
        value.copy< std::string > (that.value);
        break;

      case symbol_kind::S_args_appel: // args_appel
        value.copy< std::vector<ExpressionPtr> > (that.value);
        break;

      case symbol_kind::S_COLOR_HEX: // COLOR_HEX
        value.copy< std::vector<double> > (that.value);
        break;

      default:
        break;
    }

    location = that.location;
    return *this;
  }

   Parser ::stack_symbol_type&
   Parser ::stack_symbol_type::operator= (stack_symbol_type& that)
  {
    state = that.state;
    switch (that.kind ())
    {
      case symbol_kind::S_programme: // programme
      case symbol_kind::S_liste_instructions: // liste_instructions
        value.move< Bloc* > (that.value);
        break;

      case symbol_kind::S_condition: // condition
      case symbol_kind::S_condition_base: // condition_base
        value.move< ConditionPtr > (that.value);
        break;

      case symbol_kind::S_direction: // direction
        value.move< Direction > (that.value);
        break;

      case symbol_kind::S_expression: // expression
        value.move< ExpressionPtr > (that.value);
        break;

      case symbol_kind::S_instruction: // instruction
      case symbol_kind::S_commande: // commande
      case symbol_kind::S_structure_controle: // structure_controle
        value.move< InstructionPtr > (that.value);
        break;

      case symbol_kind::S_NUMBER: // NUMBER
        value.move< double > (that.value);
        break;

      case symbol_kind::S_VAR_NAME: // VAR_NAME
        value.move< std::string > (that.value);
        break;

      case symbol_kind::S_args_appel: // args_appel
        value.move< std::vector<ExpressionPtr> > (that.value);
        break;

      case symbol_kind::S_COLOR_HEX: // COLOR_HEX
        value.move< std::vector<double> > (that.value);
        break;

      default:
        break;
    }

    location = that.location;
    // that is emptied.
    that.state = empty_state;
    return *this;
  }
#endif

  template <typename Base>
  void
   Parser ::yy_destroy_ (const char* yymsg, basic_symbol<Base>& yysym) const
  {
    if (yymsg)
      YY_SYMBOL_PRINT (yymsg, yysym);
  }

#if YYDEBUG
  template <typename Base>
  void
   Parser ::yy_print_ (std::ostream& yyo, const basic_symbol<Base>& yysym) const
  {
    std::ostream& yyoutput = yyo;
    YY_USE (yyoutput);
    if (yysym.empty ())
      yyo << "empty symbol";
    else
      {
        symbol_kind_type yykind = yysym.kind ();
        yyo << (yykind < YYNTOKENS ? "token" : "nterm")
            << ' ' << yysym.name () << " ("
            << yysym.location << ": ";
        YY_USE (yykind);
        yyo << ')';
      }
  }
#endif

  void
   Parser ::yypush_ (const char* m, YY_MOVE_REF (stack_symbol_type) sym)
  {
    if (m)
      YY_SYMBOL_PRINT (m, sym);
    yystack_.push (YY_MOVE (sym));
  }

  void
   Parser ::yypush_ (const char* m, state_type s, YY_MOVE_REF (symbol_type) sym)
  {
#if 201103L <= YY_CPLUSPLUS
    yypush_ (m, stack_symbol_type (s, std::move (sym)));
#else
    stack_symbol_type ss (s, sym);
    yypush_ (m, ss);
#endif
  }

  void
   Parser ::yypop_ (int n) YY_NOEXCEPT
  {
    yystack_.pop (n);
  }

#if YYDEBUG
  std::ostream&
   Parser ::debug_stream () const
  {
    return *yycdebug_;
  }

  void
   Parser ::set_debug_stream (std::ostream& o)
  {
    yycdebug_ = &o;
  }


   Parser ::debug_level_type
   Parser ::debug_level () const
  {
    return yydebug_;
  }

  void
   Parser ::set_debug_level (debug_level_type l)
  {
    yydebug_ = l;
  }
#endif // YYDEBUG

   Parser ::state_type
   Parser ::yy_lr_goto_state_ (state_type yystate, int yysym)
  {
    int yyr = yypgoto_[yysym - YYNTOKENS] + yystate;
    if (0 <= yyr && yyr <= yylast_ && yycheck_[yyr] == yystate)
      return yytable_[yyr];
    else
      return yydefgoto_[yysym - YYNTOKENS];
  }

  bool
   Parser ::yy_pact_value_is_default_ (int yyvalue) YY_NOEXCEPT
  {
    return yyvalue == yypact_ninf_;
  }

  bool
   Parser ::yy_table_value_is_error_ (int yyvalue) YY_NOEXCEPT
  {
    return yyvalue == yytable_ninf_;
  }

  int
   Parser ::operator() ()
  {
    return parse ();
  }

  int
   Parser ::parse ()
  {
    int yyn;
    /// Length of the RHS of the rule being reduced.
    int yylen = 0;

    // Error handling.
    int yynerrs_ = 0;
    int yyerrstatus_ = 0;

    /// The lookahead symbol.
    symbol_type yyla;

    /// The locations where the error started and ended.
    stack_symbol_type yyerror_range[3];

    /// The return value of parse ().
    int yyresult;

#if YY_EXCEPTIONS
    try
#endif // YY_EXCEPTIONS
      {
    YYCDEBUG << "Starting parse\n";


    /* Initialize the stack.  The initial state will be set in
       yynewstate, since the latter expects the semantical and the
       location values to have been already stored, initialize these
       stacks with a primary value.  */
    yystack_.clear ();
    yypush_ (YY_NULLPTR, 0, YY_MOVE (yyla));

  /*-----------------------------------------------.
  | yynewstate -- push a new symbol on the stack.  |
  `-----------------------------------------------*/
  yynewstate:
    YYCDEBUG << "Entering state " << int (yystack_[0].state) << '\n';
    YY_STACK_PRINT ();

    // Accept?
    if (yystack_[0].state == yyfinal_)
      YYACCEPT;

    goto yybackup;


  /*-----------.
  | yybackup.  |
  `-----------*/
  yybackup:
    // Try to take a decision without lookahead.
    yyn = yypact_[+yystack_[0].state];
    if (yy_pact_value_is_default_ (yyn))
      goto yydefault;

    // Read a lookahead token.
    if (yyla.empty ())
      {
        YYCDEBUG << "Reading a token\n";
#if YY_EXCEPTIONS
        try
#endif // YY_EXCEPTIONS
          {
            yyla.kind_ = yytranslate_ (yylex (&yyla.value, &yyla.location));
          }
#if YY_EXCEPTIONS
        catch (const syntax_error& yyexc)
          {
            YYCDEBUG << "Caught exception: " << yyexc.what() << '\n';
            error (yyexc);
            goto yyerrlab1;
          }
#endif // YY_EXCEPTIONS
      }
    YY_SYMBOL_PRINT ("Next token is", yyla);

    if (yyla.kind () == symbol_kind::S_YYerror)
    {
      // The scanner already issued an error message, process directly
      // to error recovery.  But do not keep the error token as
      // lookahead, it is too special and may lead us to an endless
      // loop in error recovery. */
      yyla.kind_ = symbol_kind::S_YYUNDEF;
      goto yyerrlab1;
    }

    /* If the proper action on seeing token YYLA.TYPE is to reduce or
       to detect an error, take that action.  */
    yyn += yyla.kind ();
    if (yyn < 0 || yylast_ < yyn || yycheck_[yyn] != yyla.kind ())
      {
        goto yydefault;
      }

    // Reduce or error.
    yyn = yytable_[yyn];
    if (yyn <= 0)
      {
        if (yy_table_value_is_error_ (yyn))
          goto yyerrlab;
        yyn = -yyn;
        goto yyreduce;
      }

    // Count tokens shifted since error; after three, turn off error status.
    if (yyerrstatus_)
      --yyerrstatus_;

    // Shift the lookahead token.
    yypush_ ("Shifting", state_type (yyn), YY_MOVE (yyla));
    goto yynewstate;


  /*-----------------------------------------------------------.
  | yydefault -- do the default action for the current state.  |
  `-----------------------------------------------------------*/
  yydefault:
    yyn = yydefact_[+yystack_[0].state];
    if (yyn == 0)
      goto yyerrlab;
    goto yyreduce;


  /*-----------------------------.
  | yyreduce -- do a reduction.  |
  `-----------------------------*/
  yyreduce:
    yylen = yyr2_[yyn];
    {
      stack_symbol_type yylhs;
      yylhs.state = yy_lr_goto_state_ (yystack_[yylen].state, yyr1_[yyn]);
      /* Variants are always initialized to an empty instance of the
         correct type. The default '$$ = $1' action is NOT applied
         when using variants.  */
      switch (yyr1_[yyn])
    {
      case symbol_kind::S_programme: // programme
      case symbol_kind::S_liste_instructions: // liste_instructions
        yylhs.value.emplace< Bloc* > ();
        break;

      case symbol_kind::S_condition: // condition
      case symbol_kind::S_condition_base: // condition_base
        yylhs.value.emplace< ConditionPtr > ();
        break;

      case symbol_kind::S_direction: // direction
        yylhs.value.emplace< Direction > ();
        break;

      case symbol_kind::S_expression: // expression
        yylhs.value.emplace< ExpressionPtr > ();
        break;

      case symbol_kind::S_instruction: // instruction
      case symbol_kind::S_commande: // commande
      case symbol_kind::S_structure_controle: // structure_controle
        yylhs.value.emplace< InstructionPtr > ();
        break;

      case symbol_kind::S_NUMBER: // NUMBER
        yylhs.value.emplace< double > ();
        break;

      case symbol_kind::S_VAR_NAME: // VAR_NAME
        yylhs.value.emplace< std::string > ();
        break;

      case symbol_kind::S_args_appel: // args_appel
        yylhs.value.emplace< std::vector<ExpressionPtr> > ();
        break;

      case symbol_kind::S_COLOR_HEX: // COLOR_HEX
        yylhs.value.emplace< std::vector<double> > ();
        break;

      default:
        break;
    }


      // Default location.
      {
        stack_type::slice range (yystack_, yylen);
        YYLLOC_DEFAULT (yylhs.location, range, yylen);
        yyerror_range[1].location = yylhs.location;
      }

      // Perform the reduction.
      YY_REDUCE_PRINT (yyn);
#if YY_EXCEPTIONS
      try
#endif // YY_EXCEPTIONS
        {
          switch (yyn)
            {
  case 2: // root: programme
#line 73 "parser/parser.yy"
              {
        driver.executer(yystack_[0].value.as < Bloc* > ());
        delete yystack_[0].value.as < Bloc* > ();
        YYACCEPT;
    }
#line 921 "parser.cc"
    break;

  case 3: // programme: programme instruction NL
#line 81 "parser/parser.yy"
                               { yylhs.value.as < Bloc* > () = yystack_[2].value.as < Bloc* > (); yylhs.value.as < Bloc* > ()->ajouter(yystack_[1].value.as < InstructionPtr > ()); }
#line 927 "parser.cc"
    break;

  case 4: // programme: programme instruction END NL
#line 82 "parser/parser.yy"
                                   { yylhs.value.as < Bloc* > () = yystack_[3].value.as < Bloc* > (); yylhs.value.as < Bloc* > ()->ajouter(yystack_[2].value.as < InstructionPtr > ()); }
#line 933 "parser.cc"
    break;

  case 5: // programme: programme instruction END_OF_FILE
#line 83 "parser/parser.yy"
                                        { yylhs.value.as < Bloc* > () = yystack_[2].value.as < Bloc* > (); yylhs.value.as < Bloc* > ()->ajouter(yystack_[1].value.as < InstructionPtr > ()); }
#line 939 "parser.cc"
    break;

  case 6: // programme: programme NL
#line 84 "parser/parser.yy"
                   { yylhs.value.as < Bloc* > () = yystack_[1].value.as < Bloc* > (); }
#line 945 "parser.cc"
    break;

  case 7: // programme: programme definition_fonction NL
#line 85 "parser/parser.yy"
                                       { yylhs.value.as < Bloc* > () = yystack_[2].value.as < Bloc* > (); }
#line 951 "parser.cc"
    break;

  case 8: // programme: %empty
#line 86 "parser/parser.yy"
                 { yylhs.value.as < Bloc* > () = new Bloc(); }
#line 957 "parser.cc"
    break;

  case 9: // definition_fonction: FONCTION VAR_NAME DP NL liste_instructions END FONCTION
#line 90 "parser/parser.yy"
                                                            {
        driver.definirFonction(yystack_[5].value.as < std::string > (), yystack_[2].value.as < Bloc* > ());
    }
#line 965 "parser.cc"
    break;

  case 10: // liste_instructions: liste_instructions instruction NL
#line 96 "parser/parser.yy"
                                        { yylhs.value.as < Bloc* > () = yystack_[2].value.as < Bloc* > (); yylhs.value.as < Bloc* > ()->ajouter(yystack_[1].value.as < InstructionPtr > ()); }
#line 971 "parser.cc"
    break;

  case 11: // liste_instructions: instruction NL
#line 97 "parser/parser.yy"
                     { yylhs.value.as < Bloc* > () = new Bloc(); yylhs.value.as < Bloc* > ()->ajouter(yystack_[1].value.as < InstructionPtr > ()); }
#line 977 "parser.cc"
    break;

  case 12: // liste_instructions: liste_instructions NL
#line 98 "parser/parser.yy"
                            { yylhs.value.as < Bloc* > () = yystack_[1].value.as < Bloc* > (); }
#line 983 "parser.cc"
    break;

  case 13: // instruction: commande
#line 102 "parser/parser.yy"
               { yylhs.value.as < InstructionPtr > () = yystack_[0].value.as < InstructionPtr > (); }
#line 989 "parser.cc"
    break;

  case 14: // instruction: structure_controle
#line 103 "parser/parser.yy"
                         { yylhs.value.as < InstructionPtr > () = yystack_[0].value.as < InstructionPtr > (); }
#line 995 "parser.cc"
    break;

  case 15: // commande: AVANCE expression
#line 107 "parser/parser.yy"
                        { yylhs.value.as < InstructionPtr > () = std::make_shared<CommandeMouvement>(yystack_[0].value.as < ExpressionPtr > (), TypeMouvement::AVANCE); }
#line 1001 "parser.cc"
    break;

  case 16: // commande: RECULE expression
#line 108 "parser/parser.yy"
                        { yylhs.value.as < InstructionPtr > () = std::make_shared<CommandeMouvement>(yystack_[0].value.as < ExpressionPtr > (), TypeMouvement::RECULE); }
#line 1007 "parser.cc"
    break;

  case 17: // commande: TOURNE expression
#line 109 "parser/parser.yy"
                        { yylhs.value.as < InstructionPtr > () = std::make_shared<CommandeMouvement>(yystack_[0].value.as < ExpressionPtr > (), TypeMouvement::TOURNE); }
#line 1013 "parser.cc"
    break;

  case 18: // commande: TOURNE direction
#line 110 "parser/parser.yy"
                        {
        double angle = (yystack_[0].value.as < Direction > () == Direction::GAUCHE) ? -90.0 : 90.0;
        yylhs.value.as < InstructionPtr > () = std::make_shared<CommandeMouvement>(std::make_shared<Constante>(angle), TypeMouvement::TOURNE);
      }
#line 1022 "parser.cc"
    break;

  case 19: // commande: SAUTE expression
#line 114 "parser/parser.yy"
                        { yylhs.value.as < InstructionPtr > () = std::make_shared<CommandeMouvement>(yystack_[0].value.as < ExpressionPtr > (), TypeMouvement::SAUTE); }
#line 1028 "parser.cc"
    break;

  case 20: // commande: COULEUR COLOR_HEX
#line 115 "parser/parser.yy"
                        { yylhs.value.as < InstructionPtr > () = std::make_shared<CommandeCouleur>(yystack_[0].value.as < std::vector<double> > ()[0], yystack_[0].value.as < std::vector<double> > ()[1], yystack_[0].value.as < std::vector<double> > ()[2]); }
#line 1034 "parser.cc"
    break;

  case 21: // commande: JARDIN VAR_NAME
#line 116 "parser/parser.yy"
                        {
                          driver.nouveauJardin(yystack_[0].value.as < std::string > ());
                          yylhs.value.as < InstructionPtr > () = std::make_shared<Bloc>();
                        }
#line 1043 "parser.cc"
    break;

  case 22: // commande: VAR_NAME args_appel
#line 120 "parser/parser.yy"
                          { yylhs.value.as < InstructionPtr > () = std::make_shared<AppelFonction>(yystack_[1].value.as < std::string > (), yystack_[0].value.as < std::vector<ExpressionPtr> > ()); }
#line 1049 "parser.cc"
    break;

  case 23: // commande: commande AROBASE expression
#line 121 "parser/parser.yy"
                                  {
        Bloc* b = new Bloc();
        b->ajouter(std::make_shared<CommandeSelectionTortue>(yystack_[0].value.as < ExpressionPtr > ()));
        b->ajouter(yystack_[2].value.as < InstructionPtr > ());
        yylhs.value.as < InstructionPtr > () = std::shared_ptr<Instruction>(b);
    }
#line 1060 "parser.cc"
    break;

  case 24: // structure_controle: SI condition DP NL liste_instructions END SI
#line 130 "parser/parser.yy"
                                                   {
          yylhs.value.as < InstructionPtr > () = std::make_shared<ControleSi>(yystack_[5].value.as < ConditionPtr > (), std::shared_ptr<Instruction>(yystack_[2].value.as < Bloc* > ()));
      }
#line 1068 "parser.cc"
    break;

  case 25: // structure_controle: SI condition DP NL liste_instructions SINON DP NL liste_instructions END SI
#line 133 "parser/parser.yy"
                                                                                  {
          yylhs.value.as < InstructionPtr > () = std::make_shared<ControleSi>(yystack_[9].value.as < ConditionPtr > (), std::shared_ptr<Instruction>(yystack_[6].value.as < Bloc* > ()), std::shared_ptr<Instruction>(yystack_[2].value.as < Bloc* > ()));
      }
#line 1076 "parser.cc"
    break;

  case 26: // structure_controle: TANT QUE condition DP NL liste_instructions END TANT QUE
#line 136 "parser/parser.yy"
                                                               {
          /* Correction ici : $3 pour la condition au lieu de $2 */
          yylhs.value.as < InstructionPtr > () = std::make_shared<ControleTantQue>(yystack_[6].value.as < ConditionPtr > (), std::shared_ptr<Instruction>(yystack_[3].value.as < Bloc* > ()));
      }
#line 1085 "parser.cc"
    break;

  case 27: // structure_controle: REPETE expression DP NL liste_instructions END REPETE
#line 140 "parser/parser.yy"
                                                            {
          yylhs.value.as < InstructionPtr > () = std::make_shared<ControleRepete>(yystack_[5].value.as < ExpressionPtr > (), std::shared_ptr<Instruction>(yystack_[2].value.as < Bloc* > ()));
      }
#line 1093 "parser.cc"
    break;

  case 28: // args_appel: args_appel expression
#line 146 "parser/parser.yy"
                            { yylhs.value.as < std::vector<ExpressionPtr> > () = yystack_[1].value.as < std::vector<ExpressionPtr> > (); yylhs.value.as < std::vector<ExpressionPtr> > ().push_back(yystack_[0].value.as < ExpressionPtr > ()); }
#line 1099 "parser.cc"
    break;

  case 29: // args_appel: %empty
#line 147 "parser/parser.yy"
                 { }
#line 1105 "parser.cc"
    break;

  case 30: // condition: condition_base
#line 151 "parser/parser.yy"
                     { yylhs.value.as < ConditionPtr > () = yystack_[0].value.as < ConditionPtr > (); }
#line 1111 "parser.cc"
    break;

  case 31: // condition: PAS condition_base
#line 152 "parser/parser.yy"
                         {
        yylhs.value.as < ConditionPtr > () = yystack_[0].value.as < ConditionPtr > ();
    }
#line 1119 "parser.cc"
    break;

  case 32: // condition: condition ET condition
#line 155 "parser/parser.yy"
                             { yylhs.value.as < ConditionPtr > () = std::make_shared<ConditionBinaire>(yystack_[2].value.as < ConditionPtr > (), yystack_[0].value.as < ConditionPtr > (), OperateurBinaireBool::et); }
#line 1125 "parser.cc"
    break;

  case 33: // condition: condition OU condition
#line 156 "parser/parser.yy"
                             { yylhs.value.as < ConditionPtr > () = std::make_shared<ConditionBinaire>(yystack_[2].value.as < ConditionPtr > (), yystack_[0].value.as < ConditionPtr > (), OperateurBinaireBool::ou); }
#line 1131 "parser.cc"
    break;

  case 34: // condition: LPAR condition RPAR
#line 157 "parser/parser.yy"
                          { yylhs.value.as < ConditionPtr > () = yystack_[1].value.as < ConditionPtr > (); }
#line 1137 "parser.cc"
    break;

  case 35: // condition_base: MUR direction
#line 161 "parser/parser.yy"
                    { yylhs.value.as < ConditionPtr > () = std::make_shared<ConditionCapteur>(TypeCapteur::MUR, yystack_[0].value.as < Direction > ()); }
#line 1143 "parser.cc"
    break;

  case 36: // condition_base: VIDE direction
#line 162 "parser/parser.yy"
                     { yylhs.value.as < ConditionPtr > () = std::make_shared<ConditionCapteur>(TypeCapteur::VIDE, yystack_[0].value.as < Direction > ()); }
#line 1149 "parser.cc"
    break;

  case 37: // condition_base: PAS MUR direction
#line 163 "parser/parser.yy"
                        {
         yylhs.value.as < ConditionPtr > () = std::make_shared<ConditionCapteur>(TypeCapteur::VIDE, yystack_[0].value.as < Direction > ());
      }
#line 1157 "parser.cc"
    break;

  case 38: // condition_base: PAS VIDE direction
#line 166 "parser/parser.yy"
                         {
         yylhs.value.as < ConditionPtr > () = std::make_shared<ConditionCapteur>(TypeCapteur::MUR, yystack_[0].value.as < Direction > ());
      }
#line 1165 "parser.cc"
    break;

  case 39: // condition_base: expression EGAL expression
#line 169 "parser/parser.yy"
                                 { yylhs.value.as < ConditionPtr > () = std::make_shared<TestBinaire>(yystack_[2].value.as < ExpressionPtr > (), yystack_[0].value.as < ExpressionPtr > (), OperateurBool::egal); }
#line 1171 "parser.cc"
    break;

  case 40: // condition_base: expression DIFFERENT expression
#line 170 "parser/parser.yy"
                                      { yylhs.value.as < ConditionPtr > () = std::make_shared<TestBinaire>(yystack_[2].value.as < ExpressionPtr > (), yystack_[0].value.as < ExpressionPtr > (), OperateurBool::different); }
#line 1177 "parser.cc"
    break;

  case 41: // condition_base: expression INF expression
#line 171 "parser/parser.yy"
                                { yylhs.value.as < ConditionPtr > () = std::make_shared<TestBinaire>(yystack_[2].value.as < ExpressionPtr > (), yystack_[0].value.as < ExpressionPtr > (), OperateurBool::pluspetit); }
#line 1183 "parser.cc"
    break;

  case 42: // condition_base: expression SUP expression
#line 172 "parser/parser.yy"
                                { yylhs.value.as < ConditionPtr > () = std::make_shared<TestBinaire>(yystack_[2].value.as < ExpressionPtr > (), yystack_[0].value.as < ExpressionPtr > (), OperateurBool::plusgrand); }
#line 1189 "parser.cc"
    break;

  case 43: // direction: DEVANT
#line 176 "parser/parser.yy"
             { yylhs.value.as < Direction > () = Direction::DEVANT; }
#line 1195 "parser.cc"
    break;

  case 44: // direction: DERRIERE
#line 177 "parser/parser.yy"
               { yylhs.value.as < Direction > () = Direction::DERRIERE; }
#line 1201 "parser.cc"
    break;

  case 45: // direction: GAUCHE
#line 178 "parser/parser.yy"
             { yylhs.value.as < Direction > () = Direction::GAUCHE; }
#line 1207 "parser.cc"
    break;

  case 46: // direction: DROITE
#line 179 "parser/parser.yy"
             { yylhs.value.as < Direction > () = Direction::DROITE; }
#line 1213 "parser.cc"
    break;

  case 47: // expression: NUMBER
#line 183 "parser/parser.yy"
             { yylhs.value.as < ExpressionPtr > () = std::make_shared<Constante>(yystack_[0].value.as < double > ()); }
#line 1219 "parser.cc"
    break;

  case 48: // expression: VAR_NAME
#line 184 "parser/parser.yy"
               { yylhs.value.as < ExpressionPtr > () = std::make_shared<Variable>(yystack_[0].value.as < std::string > ()); }
#line 1225 "parser.cc"
    break;

  case 49: // expression: DOLLAR NUMBER
#line 185 "parser/parser.yy"
                    { yylhs.value.as < ExpressionPtr > () = std::make_shared<Variable>("$" + std::to_string((int)yystack_[0].value.as < double > ())); }
#line 1231 "parser.cc"
    break;

  case 50: // expression: expression PLUS expression
#line 186 "parser/parser.yy"
                                 { yylhs.value.as < ExpressionPtr > () = std::make_shared<ExpressionBinaire>(yystack_[2].value.as < ExpressionPtr > (), yystack_[0].value.as < ExpressionPtr > (), OperateurBinaire::plus); }
#line 1237 "parser.cc"
    break;

  case 51: // expression: expression MOINS expression
#line 187 "parser/parser.yy"
                                  { yylhs.value.as < ExpressionPtr > () = std::make_shared<ExpressionBinaire>(yystack_[2].value.as < ExpressionPtr > (), yystack_[0].value.as < ExpressionPtr > (), OperateurBinaire::moins); }
#line 1243 "parser.cc"
    break;

  case 52: // expression: expression MULT expression
#line 188 "parser/parser.yy"
                                 { yylhs.value.as < ExpressionPtr > () = std::make_shared<ExpressionBinaire>(yystack_[2].value.as < ExpressionPtr > (), yystack_[0].value.as < ExpressionPtr > (), OperateurBinaire::multiplie); }
#line 1249 "parser.cc"
    break;

  case 53: // expression: expression DIV expression
#line 189 "parser/parser.yy"
                                { yylhs.value.as < ExpressionPtr > () = std::make_shared<ExpressionBinaire>(yystack_[2].value.as < ExpressionPtr > (), yystack_[0].value.as < ExpressionPtr > (), OperateurBinaire::divise); }
#line 1255 "parser.cc"
    break;

  case 54: // expression: MOINS expression
#line 190 "parser/parser.yy"
                                 { yylhs.value.as < ExpressionPtr > () = std::make_shared<ExpressionUnaire>(yystack_[0].value.as < ExpressionPtr > (), OperateurUnaire::neg); }
#line 1261 "parser.cc"
    break;

  case 55: // expression: LPAR expression RPAR
#line 191 "parser/parser.yy"
                           { yylhs.value.as < ExpressionPtr > () = yystack_[1].value.as < ExpressionPtr > (); }
#line 1267 "parser.cc"
    break;


#line 1271 "parser.cc"

            default:
              break;
            }
        }
#if YY_EXCEPTIONS
      catch (const syntax_error& yyexc)
        {
          YYCDEBUG << "Caught exception: " << yyexc.what() << '\n';
          error (yyexc);
          YYERROR;
        }
#endif // YY_EXCEPTIONS
      YY_SYMBOL_PRINT ("-> $$ =", yylhs);
      yypop_ (yylen);
      yylen = 0;

      // Shift the result of the reduction.
      yypush_ (YY_NULLPTR, YY_MOVE (yylhs));
    }
    goto yynewstate;


  /*--------------------------------------.
  | yyerrlab -- here on detecting error.  |
  `--------------------------------------*/
  yyerrlab:
    // If not already recovering from an error, report this error.
    if (!yyerrstatus_)
      {
        ++yynerrs_;
        std::string msg = YY_("syntax error");
        error (yyla.location, YY_MOVE (msg));
      }


    yyerror_range[1].location = yyla.location;
    if (yyerrstatus_ == 3)
      {
        /* If just tried and failed to reuse lookahead token after an
           error, discard it.  */

        // Return failure if at end of input.
        if (yyla.kind () == symbol_kind::S_YYEOF)
          YYABORT;
        else if (!yyla.empty ())
          {
            yy_destroy_ ("Error: discarding", yyla);
            yyla.clear ();
          }
      }

    // Else will try to reuse lookahead token after shifting the error token.
    goto yyerrlab1;


  /*---------------------------------------------------.
  | yyerrorlab -- error raised explicitly by YYERROR.  |
  `---------------------------------------------------*/
  yyerrorlab:
    /* Pacify compilers when the user code never invokes YYERROR and
       the label yyerrorlab therefore never appears in user code.  */
    if (false)
      YYERROR;

    /* Do not reclaim the symbols of the rule whose action triggered
       this YYERROR.  */
    yypop_ (yylen);
    yylen = 0;
    YY_STACK_PRINT ();
    goto yyerrlab1;


  /*-------------------------------------------------------------.
  | yyerrlab1 -- common code for both syntax error and YYERROR.  |
  `-------------------------------------------------------------*/
  yyerrlab1:
    yyerrstatus_ = 3;   // Each real token shifted decrements this.
    // Pop stack until we find a state that shifts the error token.
    for (;;)
      {
        yyn = yypact_[+yystack_[0].state];
        if (!yy_pact_value_is_default_ (yyn))
          {
            yyn += symbol_kind::S_YYerror;
            if (0 <= yyn && yyn <= yylast_
                && yycheck_[yyn] == symbol_kind::S_YYerror)
              {
                yyn = yytable_[yyn];
                if (0 < yyn)
                  break;
              }
          }

        // Pop the current state because it cannot handle the error token.
        if (yystack_.size () == 1)
          YYABORT;

        yyerror_range[1].location = yystack_[0].location;
        yy_destroy_ ("Error: popping", yystack_[0]);
        yypop_ ();
        YY_STACK_PRINT ();
      }
    {
      stack_symbol_type error_token;

      yyerror_range[2].location = yyla.location;
      YYLLOC_DEFAULT (error_token.location, yyerror_range, 2);

      // Shift the error token.
      error_token.state = state_type (yyn);
      yypush_ ("Shifting", YY_MOVE (error_token));
    }
    goto yynewstate;


  /*-------------------------------------.
  | yyacceptlab -- YYACCEPT comes here.  |
  `-------------------------------------*/
  yyacceptlab:
    yyresult = 0;
    goto yyreturn;


  /*-----------------------------------.
  | yyabortlab -- YYABORT comes here.  |
  `-----------------------------------*/
  yyabortlab:
    yyresult = 1;
    goto yyreturn;


  /*-----------------------------------------------------.
  | yyreturn -- parsing is finished, return the result.  |
  `-----------------------------------------------------*/
  yyreturn:
    if (!yyla.empty ())
      yy_destroy_ ("Cleanup: discarding lookahead", yyla);

    /* Do not reclaim the symbols of the rule whose action triggered
       this YYABORT or YYACCEPT.  */
    yypop_ (yylen);
    YY_STACK_PRINT ();
    while (1 < yystack_.size ())
      {
        yy_destroy_ ("Cleanup: popping", yystack_[0]);
        yypop_ ();
      }

    return yyresult;
  }
#if YY_EXCEPTIONS
    catch (...)
      {
        YYCDEBUG << "Exception caught: cleaning lookahead and stack\n";
        // Do not try to display the values of the reclaimed symbols,
        // as their printers might throw an exception.
        if (!yyla.empty ())
          yy_destroy_ (YY_NULLPTR, yyla);

        while (1 < yystack_.size ())
          {
            yy_destroy_ (YY_NULLPTR, yystack_[0]);
            yypop_ ();
          }
        throw;
      }
#endif // YY_EXCEPTIONS
  }

  void
   Parser ::error (const syntax_error& yyexc)
  {
    error (yyexc.location, yyexc.what ());
  }

#if YYDEBUG || 0
  const char *
   Parser ::symbol_name (symbol_kind_type yysymbol)
  {
    return yytname_[yysymbol];
  }
#endif // #if YYDEBUG || 0









  const signed char  Parser ::yypact_ninf_ = -85;

  const signed char  Parser ::yytable_ninf_ = -1;

  const short
   Parser ::yypact_[] =
  {
     -85,     8,    87,   -85,   -85,   -14,   -14,   205,   -14,   -17,
     -30,   -13,   180,    15,   -14,   -85,    32,    45,    39,   -85,
       0,   -14,   -14,   -85,   -85,    33,    33,   -85,   -85,   -85,
     -85,   -85,    33,    33,   -85,   -85,    47,    84,    84,   184,
     180,   -15,   -85,   229,   180,    14,   -14,   -85,   -85,    76,
     -85,   -14,   -85,   -85,   210,   -14,   -14,   -14,   -14,    78,
     -85,   -85,    84,    84,     3,   -85,    21,   219,    82,   180,
     180,   -14,   -14,   -14,   -14,    -6,    85,    33,   -85,    33,
     -85,    27,    27,   -85,   -85,   178,   -85,   -85,    84,    84,
     -85,   178,   -85,    48,    33,    33,    33,    33,    86,   178,
     110,    88,   -85,   -85,    68,   178,   127,   -85,    79,   109,
     -85,   101,    97,   147,   107,   -85,   -85,   -85,   124,   116,
     -85,   178,   121,   164,   -85,   126,   -85
  };

  const signed char
   Parser ::yydefact_[] =
  {
       8,     0,     2,     1,     6,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,    29,     0,     0,    13,    14,
       0,     0,     0,    47,    48,    15,    16,    43,    44,    45,
      46,    18,    17,    19,    20,    21,     0,     0,     0,     0,
       0,     0,    30,     0,     0,     0,    22,     7,     3,     0,
       5,     0,    49,    54,     0,     0,     0,     0,     0,     0,
      35,    36,     0,     0,     0,    31,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    28,     4,    23,
      55,    50,    51,    52,    53,     0,    35,    36,     0,     0,
      34,     0,    32,    33,    39,    40,    41,    42,     0,     0,
       0,     0,    37,    38,     0,     0,     0,    12,     0,     0,
      11,     0,     0,     0,     0,     9,    10,    24,     0,     0,
      27,     0,     0,     0,    26,     0,    25
  };

  const signed char
   Parser ::yypgoto_[] =
  {
     -85,   -85,   -85,   -85,   -84,    -2,   -85,   -85,   -85,   -31,
     103,   -32,    -4
  };

  const signed char
   Parser ::yydefgoto_[] =
  {
       0,     1,     2,    16,   100,   101,    18,    19,    46,    41,
      42,    31,    43
  };

  const signed char
   Parser ::yytable_[] =
  {
      17,    25,    26,    32,    33,    60,    61,   104,     3,    66,
      45,    68,    35,    75,    20,   106,    21,    53,    54,    22,
      98,   113,    88,    89,    69,    70,    34,    23,    24,    36,
      86,    87,    44,    69,    70,    47,    67,   123,    92,    93,
      76,    52,    77,    55,    56,    57,    58,    79,    48,    49,
      50,    81,    82,    83,    84,    90,   102,   103,    57,    58,
      69,    70,    55,    56,    57,    58,    51,    94,    95,    96,
      97,   107,   111,    59,     5,     6,     7,     8,     9,    78,
      10,    85,    12,   112,    13,    91,    14,    69,    99,   105,
       4,   110,   115,     5,     6,     7,     8,     9,   109,    10,
      11,    12,   109,    13,   109,    14,    27,    28,    29,    30,
      15,   109,   116,   107,   108,   117,     5,     6,     7,     8,
       9,   109,    10,   118,    12,   120,    13,   121,    14,    15,
     107,   114,   122,     5,     6,     7,     8,     9,   124,    10,
     126,    12,    65,    13,     0,    14,     0,     0,     0,     0,
     107,   119,    15,     5,     6,     7,     8,     9,     0,    10,
       0,    12,     0,    13,     0,    14,     0,   107,   125,    15,
       5,     6,     7,     8,     9,     0,    10,     0,    12,     0,
      13,     0,    14,     0,     5,     6,     7,     8,     9,    15,
      10,     0,    12,     0,    13,     0,    14,     0,     0,    37,
      38,    39,     0,    62,    63,    64,    15,     0,    20,     0,
      21,     0,    20,    40,    21,     0,     0,    22,     0,     0,
      15,    23,    24,     0,     0,    23,    24,    27,    28,    29,
      30,     0,     0,    20,     0,    21,     0,     0,    22,    55,
      56,    57,    58,     0,    80,     0,    23,    24,    55,    56,
      57,    58,     0,    80,    71,    72,    73,    74,    55,    56,
      57,    58,     0,     0,    71,    72,    73,    74
  };

  const signed char
   Parser ::yycheck_[] =
  {
       2,     5,     6,     7,     8,    37,    38,    91,     0,    40,
      14,    26,    42,    44,    28,    99,    30,    21,    22,    33,
      26,   105,    19,    20,    39,    40,    43,    41,    42,    42,
      62,    63,    17,    39,    40,     3,    40,   121,    69,    70,
      26,    41,    46,    29,    30,    31,    32,    51,     3,     4,
       5,    55,    56,    57,    58,    34,    88,    89,    31,    32,
      39,    40,    29,    30,    31,    32,    27,    71,    72,    73,
      74,     3,     4,    26,     6,     7,     8,     9,    10,     3,
      12,     3,    14,    15,    16,     3,    18,    39,     3,     3,
       3,     3,    13,     6,     7,     8,     9,    10,   100,    12,
      13,    14,   104,    16,   106,    18,    22,    23,    24,    25,
      42,   113,     3,     3,     4,    14,     6,     7,     8,     9,
      10,   123,    12,    26,    14,    18,    16,     3,    18,    42,
       3,     4,    16,     6,     7,     8,     9,    10,    17,    12,
      14,    14,    39,    16,    -1,    18,    -1,    -1,    -1,    -1,
       3,     4,    42,     6,     7,     8,     9,    10,    -1,    12,
      -1,    14,    -1,    16,    -1,    18,    -1,     3,     4,    42,
       6,     7,     8,     9,    10,    -1,    12,    -1,    14,    -1,
      16,    -1,    18,    -1,     6,     7,     8,     9,    10,    42,
      12,    -1,    14,    -1,    16,    -1,    18,    -1,    -1,    19,
      20,    21,    -1,    19,    20,    21,    42,    -1,    28,    -1,
      30,    -1,    28,    33,    30,    -1,    -1,    33,    -1,    -1,
      42,    41,    42,    -1,    -1,    41,    42,    22,    23,    24,
      25,    -1,    -1,    28,    -1,    30,    -1,    -1,    33,    29,
      30,    31,    32,    -1,    34,    -1,    41,    42,    29,    30,
      31,    32,    -1,    34,    35,    36,    37,    38,    29,    30,
      31,    32,    -1,    -1,    35,    36,    37,    38
  };

  const signed char
   Parser ::yystos_[] =
  {
       0,    46,    47,     0,     3,     6,     7,     8,     9,    10,
      12,    13,    14,    16,    18,    42,    48,    50,    51,    52,
      28,    30,    33,    41,    42,    57,    57,    22,    23,    24,
      25,    56,    57,    57,    43,    42,    42,    19,    20,    21,
      33,    54,    55,    57,    17,    57,    53,     3,     3,     4,
       5,    27,    41,    57,    57,    29,    30,    31,    32,    26,
      56,    56,    19,    20,    21,    55,    54,    57,    26,    39,
      40,    35,    36,    37,    38,    54,    26,    57,     3,    57,
      34,    57,    57,    57,    57,     3,    56,    56,    19,    20,
      34,     3,    54,    54,    57,    57,    57,    57,    26,     3,
      49,    50,    56,    56,    49,     3,    49,     3,     4,    50,
       3,     4,    15,    49,     4,    13,     3,    14,    26,     4,
      18,     3,    16,    49,    17,     4,    14
  };

  const signed char
   Parser ::yyr1_[] =
  {
       0,    45,    46,    47,    47,    47,    47,    47,    47,    48,
      49,    49,    49,    50,    50,    51,    51,    51,    51,    51,
      51,    51,    51,    51,    52,    52,    52,    52,    53,    53,
      54,    54,    54,    54,    54,    55,    55,    55,    55,    55,
      55,    55,    55,    56,    56,    56,    56,    57,    57,    57,
      57,    57,    57,    57,    57,    57
  };

  const signed char
   Parser ::yyr2_[] =
  {
       0,     2,     1,     3,     4,     3,     2,     3,     0,     7,
       3,     2,     2,     1,     1,     2,     2,     2,     2,     2,
       2,     2,     2,     3,     7,    11,     9,     7,     2,     0,
       1,     2,     3,     3,     3,     2,     2,     3,     3,     3,
       3,     3,     3,     1,     1,     1,     1,     1,     1,     2,
       3,     3,     3,     3,     2,     3
  };


#if YYDEBUG
  // YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
  // First, the terminals, then, starting at \a YYNTOKENS, nonterminals.
  const char*
  const  Parser ::yytname_[] =
  {
  "\"end of file\"", "error", "\"invalid token\"", "NL", "END",
  "END_OF_FILE", "AVANCE", "RECULE", "TOURNE", "SAUTE", "COULEUR",
  "TORTUES", "JARDIN", "FONCTION", "SI", "SINON", "TANT", "QUE", "REPETE",
  "MUR", "VIDE", "PAS", "DEVANT", "DERRIERE", "GAUCHE", "DROITE", "DP",
  "AROBASE", "DOLLAR", "PLUS", "MOINS", "MULT", "DIV", "LPAR", "RPAR",
  "EGAL", "DIFFERENT", "INF", "SUP", "ET", "OU", "NUMBER", "VAR_NAME",
  "COLOR_HEX", "NEG", "$accept", "root", "programme",
  "definition_fonction", "liste_instructions", "instruction", "commande",
  "structure_controle", "args_appel", "condition", "condition_base",
  "direction", "expression", YY_NULLPTR
  };
#endif


#if YYDEBUG
  const unsigned char
   Parser ::yyrline_[] =
  {
       0,    73,    73,    81,    82,    83,    84,    85,    86,    90,
      96,    97,    98,   102,   103,   107,   108,   109,   110,   114,
     115,   116,   120,   121,   130,   133,   136,   140,   146,   147,
     151,   152,   155,   156,   157,   161,   162,   163,   166,   169,
     170,   171,   172,   176,   177,   178,   179,   183,   184,   185,
     186,   187,   188,   189,   190,   191
  };

  void
   Parser ::yy_stack_print_ () const
  {
    *yycdebug_ << "Stack now";
    for (stack_type::const_iterator
           i = yystack_.begin (),
           i_end = yystack_.end ();
         i != i_end; ++i)
      *yycdebug_ << ' ' << int (i->state);
    *yycdebug_ << '\n';
  }

  void
   Parser ::yy_reduce_print_ (int yyrule) const
  {
    int yylno = yyrline_[yyrule];
    int yynrhs = yyr2_[yyrule];
    // Print the symbols being reduced, and their result.
    *yycdebug_ << "Reducing stack by rule " << yyrule - 1
               << " (line " << yylno << "):\n";
    // The symbols being reduced.
    for (int yyi = 0; yyi < yynrhs; yyi++)
      YY_SYMBOL_PRINT ("   $" << yyi + 1 << " =",
                       yystack_[(yynrhs) - (yyi + 1)]);
  }
#endif // YYDEBUG

   Parser ::symbol_kind_type
   Parser ::yytranslate_ (int t) YY_NOEXCEPT
  {
    // YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to
    // TOKEN-NUM as returned by yylex.
    static
    const signed char
    translate_table[] =
    {
       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
      35,    36,    37,    38,    39,    40,    41,    42,    43,    44
    };
    // Last valid token kind.
    const int code_max = 299;

    if (t <= 0)
      return symbol_kind::S_YYEOF;
    else if (t <= code_max)
      return static_cast <symbol_kind_type> (translate_table[t]);
    else
      return symbol_kind::S_YYUNDEF;
  }

} // yy
#line 1734 "parser.cc"

#line 194 "parser/parser.yy"


void yy::Parser::error( const location_type &l, const std::string & err_msg) {
    std::cerr << "Erreur : " << l << ", " << err_msg << std::endl;
}



==================================================
FICHIER : ./parser/driver.cc
==================================================
#include "driver.hh"
#include "jardinHandler.hh"
#include "jardinRendering.hh"
#include <iostream>
#include <cmath>

#define ECHELLE 40.0

Driver::Driver(JardinHandler * jardin) : _jardin(jardin) {}
Driver::~Driver() {}

const Contexte & Driver::getContexte() const { return _contexte; }
Contexte & Driver::getContexteModifiable() { return _contexte; }
JardinRendering * Driver::getJardin() { return _jardin->getJardin(); }

// --- GESTION DES BLOCS ET FONCTIONS (C'est ce qui manquait !) ---

void Driver::executer(const Bloc * bloc) {
    if (bloc != nullptr) ((Bloc*)bloc)->executer(_contexte, *this);
}

void Driver::definirFonction(std::string nom, Bloc * instructions) {
    _fonctions[nom] = instructions;
}

Bloc* Driver::recupererFonction(std::string nom) {
    if (_fonctions.find(nom) != _fonctions.end()) {
        return _fonctions[nom];
    }
    return nullptr;
}

// IMPLÉMENTATION DE BLOC::EXECUTER (Indispensable pour le Linker)
void Bloc::executer(Contexte & ctx, Driver & driver) const {
    for (auto & instr : _instructions) {
        instr->executer(ctx, driver);
    }
}

// IMPLÉMENTATION DE APPELFONCTION::EXECUTER (L'erreur vtable venait d'ici !)
void AppelFonction::executer(Contexte & ctx, Driver & driver) const {
    // 1. On cherche la fonction
    Bloc* code = driver.recupererFonction(_nom);
    if (!code) {
        std::cerr << "Erreur: Fonction inconnue '" << _nom << "'" << std::endl;
        return;
    }

    // 2. On passe les arguments (simplifié : on écrase $1, $2...)
    // Note: Dans un vrai langage, on créerait un nouveau contexte (scope).
    // Ici, on utilise le contexte global comme demandé souvent en L3.
    Contexte& c = driver.getContexteModifiable();
    for(size_t i=0; i < _args.size(); ++i) {
        double val = _args[i]->calculer(ctx);
        c["$" + std::to_string(i+1)] = val;
    }

    // 3. On exécute le code de la fonction
    code->executer(ctx, driver);
}

// --- LOGIQUE TORTUE (MATHS FLOAT) ---

void Driver::bouger(TypeMouvement type, double valeur) {
    int id = _contexte.tortueCourante;
    if (id >= getJardin()->nombreTortues()) return;

    float angleDeg = getJardin()->orientation(id);
    float angleRad = angleDeg * M_PI / 180.0;
    PointF pos = getJardin()->position(id);
    float curX = pos.x;
    float curY = pos.y;

    float dist = (float)(valeur * ECHELLE);
    float dX = 0; float dY = 0;

    switch(type) {
        case TypeMouvement::AVANCE:
            dX = dist * cos(angleRad); dY = dist * sin(angleRad); break;
        case TypeMouvement::RECULE:
            dX = -dist * cos(angleRad); dY = -dist * sin(angleRad); break;
        case TypeMouvement::TOURNE:
            getJardin()->changeOrientation(id, angleDeg + (float)valeur); return;
        case TypeMouvement::SAUTE:
            dX = dist * cos(angleRad); dY = dist * sin(angleRad); break;
    }
    getJardin()->changePosition(id, curX + dX, curY + dY);
}

bool Driver::verifierCapteur(TypeCapteur type, Direction, int id) {
    PointF pos = getJardin()->position(id);
    int targetX = (int)(pos.x / ECHELLE);
    int targetY = (int)(pos.y / ECHELLE);

    if (type == TypeCapteur::MUR) return getJardin()->estMur(targetX, targetY);
    if (type == TypeCapteur::VIDE) return getJardin()->estVide(targetX, targetY);
    return false;
}

void Driver::nouveauJardin(std::string nomJardin){
    getJardin()->construction(nomJardin);
}

void Driver::changerCouleur(double r, double g, double b) {
    int tortueCourante = _contexte.tortueCourante;
    getJardin()->changerCouleur((int)r, (int)g, (int)b);
    getJardin()->changeCouleur(tortueCourante, (int)r, (int)g, (int)b);
}

// WRAPPERS POUR LES INSTRUCTIONS (Hack linkage)
void driver_bouger_wrapper(Driver& d, TypeMouvement t, double v) {
    d.bouger(t, v);
}
void driver_couleur_wrapper(Driver& d, double r, double g, double b) {
    d.changerCouleur(r, g, b);
}



==================================================
FICHIER : ./parser/driver.hh
==================================================
#ifndef DRIVER_HH
#define DRIVER_HH

#include <string>
#include <vector>
#include <map>
#include "contexte.hh"
#include "instructions.hh"
#include "types.hh"

// Forward declarations
class JardinHandler;
class JardinRendering;

class Driver {
public:
    Driver(JardinHandler* jardin);
    ~Driver();

    const Contexte& getContexte() const;
    Contexte& getContexteModifiable();
    JardinRendering* getJardin();

    void executer(const Bloc* bloc);
    void bouger(TypeMouvement type, double valeur);
    void changerCouleur(double r, double g, double b);

    bool verifierCapteur(TypeCapteur type, Direction dir, int id);

    // GESTION DES FONCTIONS
    void definirFonction(std::string nom, Bloc* instructions);
    Bloc* recupererFonction(std::string nom); // <-- Nouvelle méthode pour aider AppelFonction

    void nouveauJardin(std::string nom);

private:
    JardinHandler* _jardin;
    Contexte _contexte;

    // Stockage des fonctions définies par l'utilisateur
    std::map<std::string, Bloc*> _fonctions;
};

#endif



==================================================
FICHIER : ./parser/location.hh
==================================================
// A Bison parser, made by GNU Bison 3.8.2.

// Locations for Bison parsers in C++

// Copyright (C) 2002-2015, 2018-2021 Free Software Foundation, Inc.

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// As a special exception, you may create a larger work that contains
// part or all of the Bison parser skeleton and distribute that work
// under terms of your choice, so long as that work isn't itself a
// parser generator using the skeleton or a modified version thereof
// as a parser skeleton.  Alternatively, if you modify or redistribute
// the parser skeleton itself, you may (at your option) remove this
// special exception, which will cause the skeleton and the resulting
// Bison output files to be licensed under the GNU General Public
// License without this special exception.

// This special exception was added by the Free Software Foundation in
// version 2.2 of Bison.

/**
 ** \file parser/location.hh
 ** Define the yy::location class.
 */

#ifndef YY_YY_PARSER_LOCATION_HH_INCLUDED
# define YY_YY_PARSER_LOCATION_HH_INCLUDED

# include <iostream>
# include <string>

# ifndef YY_NULLPTR
#  if defined __cplusplus
#   if 201103L <= __cplusplus
#    define YY_NULLPTR nullptr
#   else
#    define YY_NULLPTR 0
#   endif
#  else
#   define YY_NULLPTR ((void*)0)
#  endif
# endif

namespace yy {
#line 58 "parser/location.hh"

  /// A point in a source file.
  class position
  {
  public:
    /// Type for file name.
    typedef const std::string filename_type;
    /// Type for line and column numbers.
    typedef int counter_type;

    /// Construct a position.
    explicit position (filename_type* f = YY_NULLPTR,
                       counter_type l = 1,
                       counter_type c = 1)
      : filename (f)
      , line (l)
      , column (c)
    {}


    /// Initialization.
    void initialize (filename_type* fn = YY_NULLPTR,
                     counter_type l = 1,
                     counter_type c = 1)
    {
      filename = fn;
      line = l;
      column = c;
    }

    /** \name Line and Column related manipulators
     ** \{ */
    /// (line related) Advance to the COUNT next lines.
    void lines (counter_type count = 1)
    {
      if (count)
        {
          column = 1;
          line = add_ (line, count, 1);
        }
    }

    /// (column related) Advance to the COUNT next columns.
    void columns (counter_type count = 1)
    {
      column = add_ (column, count, 1);
    }
    /** \} */

    /// File name to which this position refers.
    filename_type* filename;
    /// Current line number.
    counter_type line;
    /// Current column number.
    counter_type column;

  private:
    /// Compute max (min, lhs+rhs).
    static counter_type add_ (counter_type lhs, counter_type rhs, counter_type min)
    {
      return lhs + rhs < min ? min : lhs + rhs;
    }
  };

  /// Add \a width columns, in place.
  inline position&
  operator+= (position& res, position::counter_type width)
  {
    res.columns (width);
    return res;
  }

  /// Add \a width columns.
  inline position
  operator+ (position res, position::counter_type width)
  {
    return res += width;
  }

  /// Subtract \a width columns, in place.
  inline position&
  operator-= (position& res, position::counter_type width)
  {
    return res += -width;
  }

  /// Subtract \a width columns.
  inline position
  operator- (position res, position::counter_type width)
  {
    return res -= width;
  }

  /** \brief Intercept output stream redirection.
   ** \param ostr the destination output stream
   ** \param pos a reference to the position to redirect
   */
  template <typename YYChar>
  std::basic_ostream<YYChar>&
  operator<< (std::basic_ostream<YYChar>& ostr, const position& pos)
  {
    if (pos.filename)
      ostr << *pos.filename << ':';
    return ostr << pos.line << '.' << pos.column;
  }

  /// Two points in a source file.
  class location
  {
  public:
    /// Type for file name.
    typedef position::filename_type filename_type;
    /// Type for line and column numbers.
    typedef position::counter_type counter_type;

    /// Construct a location from \a b to \a e.
    location (const position& b, const position& e)
      : begin (b)
      , end (e)
    {}

    /// Construct a 0-width location in \a p.
    explicit location (const position& p = position ())
      : begin (p)
      , end (p)
    {}

    /// Construct a 0-width location in \a f, \a l, \a c.
    explicit location (filename_type* f,
                       counter_type l = 1,
                       counter_type c = 1)
      : begin (f, l, c)
      , end (f, l, c)
    {}


    /// Initialization.
    void initialize (filename_type* f = YY_NULLPTR,
                     counter_type l = 1,
                     counter_type c = 1)
    {
      begin.initialize (f, l, c);
      end = begin;
    }

    /** \name Line and Column related manipulators
     ** \{ */
  public:
    /// Reset initial location to final location.
    void step ()
    {
      begin = end;
    }

    /// Extend the current location to the COUNT next columns.
    void columns (counter_type count = 1)
    {
      end += count;
    }

    /// Extend the current location to the COUNT next lines.
    void lines (counter_type count = 1)
    {
      end.lines (count);
    }
    /** \} */


  public:
    /// Beginning of the located region.
    position begin;
    /// End of the located region.
    position end;
  };

  /// Join two locations, in place.
  inline location&
  operator+= (location& res, const location& end)
  {
    res.end = end.end;
    return res;
  }

  /// Join two locations.
  inline location
  operator+ (location res, const location& end)
  {
    return res += end;
  }

  /// Add \a width columns to the end position, in place.
  inline location&
  operator+= (location& res, location::counter_type width)
  {
    res.columns (width);
    return res;
  }

  /// Add \a width columns to the end position.
  inline location
  operator+ (location res, location::counter_type width)
  {
    return res += width;
  }

  /// Subtract \a width columns to the end position, in place.
  inline location&
  operator-= (location& res, location::counter_type width)
  {
    return res += -width;
  }

  /// Subtract \a width columns to the end position.
  inline location
  operator- (location res, location::counter_type width)
  {
    return res -= width;
  }

  /** \brief Intercept output stream redirection.
   ** \param ostr the destination output stream
   ** \param loc a reference to the location to redirect
   **
   ** Avoid duplicate information.
   */
  template <typename YYChar>
  std::basic_ostream<YYChar>&
  operator<< (std::basic_ostream<YYChar>& ostr, const location& loc)
  {
    location::counter_type end_col
      = 0 < loc.end.column ? loc.end.column - 1 : 0;
    ostr << loc.begin;
    if (loc.end.filename
        && (!loc.begin.filename
            || *loc.begin.filename != *loc.end.filename))
      ostr << '-' << loc.end.filename << ':' << loc.end.line << '.' << end_col;
    else if (loc.begin.line < loc.end.line)
      ostr << '-' << loc.end.line << '.' << end_col;
    else if (loc.begin.column < end_col)
      ostr << '-' << end_col;
    return ostr;
  }

} // yy
#line 303 "parser/location.hh"

#endif // !YY_YY_PARSER_LOCATION_HH_INCLUDED



==================================================
FICHIER : ./parser/main.cc
==================================================
#include <QApplication>
#include <QTimer>
#include <iostream>
#include <fstream>

#include "driver.hh"
#include "jardinHandler.hh"
#include "GUI/jardin.hh"
#include "scanner.hh"
#include "parser.hh"

struct Context {
    std::string filename;
    JardinHandler* handler;
};

void lancerAnalyse(Context* ctx) {
    std::cout << "--- DÉBUT DU DESSIN ---" << std::endl;
    Driver driver(ctx->handler);
    std::ifstream fichier(ctx->filename);
    if (!fichier.is_open()) {
        std::cerr << "Impossible d'ouvrir le fichier !" << std::endl;
        return;
    }
    Scanner scanner(fichier, std::cout);
    yy::Parser parser(scanner, driver);
    parser.parse();
    std::cout << "--- DESSIN TERMINÉ ---" << std::endl;
    delete ctx;
}

int main(int argc, char *argv[]) {
    QApplication app(argc, argv);
    if (argc < 2) {
        std::cerr << "Usage: ./tortue <fichier_script>" << std::endl;
        return 1;
    }
    Jardin * window = new Jardin("");
    window->resize(800, 600);
    window->show();
    Context* ctx = new Context;
    ctx->filename = argv[1];
    ctx->handler = window->getHandler();
    QTimer::singleShot(200, [ctx](){ lancerAnalyse(ctx); });
    return app.exec();
}



==================================================
FICHIER : ./parser/parser.cc
==================================================
// A Bison parser, made by GNU Bison 3.8.2.

// Skeleton implementation for Bison LALR(1) parsers in C++

// Copyright (C) 2002-2015, 2018-2021 Free Software Foundation, Inc.

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// As a special exception, you may create a larger work that contains
// part or all of the Bison parser skeleton and distribute that work
// under terms of your choice, so long as that work isn't itself a
// parser generator using the skeleton or a modified version thereof
// as a parser skeleton.  Alternatively, if you modify or redistribute
// the parser skeleton itself, you may (at your option) remove this
// special exception, which will cause the skeleton and the resulting
// Bison output files to be licensed under the GNU General Public
// License without this special exception.

// This special exception was added by the Free Software Foundation in
// version 2.2 of Bison.

// DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,
// especially those whose name start with YY_ or yy_.  They are
// private implementation details that can be changed or removed.





#include "parser.hh"


// Unqualified %code blocks.
#line 32 "parser/parser.yy"

    #include <iostream>
    #include "scanner.hh"
    #include "driver.hh"

    #undef  yylex
    #define yylex scanner.yylex

#line 55 "parser/parser.cc"


#ifndef YY_
# if defined YYENABLE_NLS && YYENABLE_NLS
#  if ENABLE_NLS
#   include <libintl.h> // FIXME: INFRINGES ON USER NAME SPACE.
#   define YY_(msgid) dgettext ("bison-runtime", msgid)
#  endif
# endif
# ifndef YY_
#  define YY_(msgid) msgid
# endif
#endif


// Whether we are compiled with exception support.
#ifndef YY_EXCEPTIONS
# if defined __GNUC__ && !defined __EXCEPTIONS
#  define YY_EXCEPTIONS 0
# else
#  define YY_EXCEPTIONS 1
# endif
#endif

#define YYRHSLOC(Rhs, K) ((Rhs)[K].location)
/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
   If N is 0, then set CURRENT to the empty location which ends
   the previous symbol: RHS[0] (always defined).  */

# ifndef YYLLOC_DEFAULT
#  define YYLLOC_DEFAULT(Current, Rhs, N)                               \
    do                                                                  \
      if (N)                                                            \
        {                                                               \
          (Current).begin  = YYRHSLOC (Rhs, 1).begin;                   \
          (Current).end    = YYRHSLOC (Rhs, N).end;                     \
        }                                                               \
      else                                                              \
        {                                                               \
          (Current).begin = (Current).end = YYRHSLOC (Rhs, 0).end;      \
        }                                                               \
    while (false)
# endif


// Enable debugging if requested.
#if YYDEBUG

// A pseudo ostream that takes yydebug_ into account.
# define YYCDEBUG if (yydebug_) (*yycdebug_)

# define YY_SYMBOL_PRINT(Title, Symbol)         \
  do {                                          \
    if (yydebug_)                               \
    {                                           \
      *yycdebug_ << Title << ' ';               \
      yy_print_ (*yycdebug_, Symbol);           \
      *yycdebug_ << '\n';                       \
    }                                           \
  } while (false)

# define YY_REDUCE_PRINT(Rule)          \
  do {                                  \
    if (yydebug_)                       \
      yy_reduce_print_ (Rule);          \
  } while (false)

# define YY_STACK_PRINT()               \
  do {                                  \
    if (yydebug_)                       \
      yy_stack_print_ ();                \
  } while (false)

#else // !YYDEBUG

# define YYCDEBUG if (false) std::cerr
# define YY_SYMBOL_PRINT(Title, Symbol)  YY_USE (Symbol)
# define YY_REDUCE_PRINT(Rule)           static_cast<void> (0)
# define YY_STACK_PRINT()                static_cast<void> (0)

#endif // !YYDEBUG

#define yyerrok         (yyerrstatus_ = 0)
#define yyclearin       (yyla.clear ())

#define YYACCEPT        goto yyacceptlab
#define YYABORT         goto yyabortlab
#define YYERROR         goto yyerrorlab
#define YYRECOVERING()  (!!yyerrstatus_)

namespace yy {
#line 147 "parser/parser.cc"

  /// Build a parser object.
   Parser :: Parser  (Scanner &scanner_yyarg, Driver &driver_yyarg)
#if YYDEBUG
    : yydebug_ (false),
      yycdebug_ (&std::cerr),
#else
    :
#endif
      scanner (scanner_yyarg),
      driver (driver_yyarg)
  {}

   Parser ::~ Parser  ()
  {}

   Parser ::syntax_error::~syntax_error () YY_NOEXCEPT YY_NOTHROW
  {}

  /*---------.
  | symbol.  |
  `---------*/

  // basic_symbol.
  template <typename Base>
   Parser ::basic_symbol<Base>::basic_symbol (const basic_symbol& that)
    : Base (that)
    , value ()
    , location (that.location)
  {
    switch (this->kind ())
    {
      case symbol_kind::S_programme: // programme
      case symbol_kind::S_liste_instructions: // liste_instructions
        value.copy< Bloc* > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_condition: // condition
      case symbol_kind::S_condition_base: // condition_base
        value.copy< ConditionPtr > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_direction: // direction
        value.copy< Direction > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_expression: // expression
        value.copy< ExpressionPtr > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_instruction: // instruction
      case symbol_kind::S_commande: // commande
      case symbol_kind::S_structure_controle: // structure_controle
        value.copy< InstructionPtr > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_NUMBER: // NUMBER
        value.copy< double > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_VAR_NAME: // VAR_NAME
        value.copy< std::string > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_args_appel: // args_appel
        value.copy< std::vector<ExpressionPtr> > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_COLOR_HEX: // COLOR_HEX
        value.copy< std::vector<double> > (YY_MOVE (that.value));
        break;

      default:
        break;
    }

  }




  template <typename Base>
   Parser ::symbol_kind_type
   Parser ::basic_symbol<Base>::type_get () const YY_NOEXCEPT
  {
    return this->kind ();
  }


  template <typename Base>
  bool
   Parser ::basic_symbol<Base>::empty () const YY_NOEXCEPT
  {
    return this->kind () == symbol_kind::S_YYEMPTY;
  }

  template <typename Base>
  void
   Parser ::basic_symbol<Base>::move (basic_symbol& s)
  {
    super_type::move (s);
    switch (this->kind ())
    {
      case symbol_kind::S_programme: // programme
      case symbol_kind::S_liste_instructions: // liste_instructions
        value.move< Bloc* > (YY_MOVE (s.value));
        break;

      case symbol_kind::S_condition: // condition
      case symbol_kind::S_condition_base: // condition_base
        value.move< ConditionPtr > (YY_MOVE (s.value));
        break;

      case symbol_kind::S_direction: // direction
        value.move< Direction > (YY_MOVE (s.value));
        break;

      case symbol_kind::S_expression: // expression
        value.move< ExpressionPtr > (YY_MOVE (s.value));
        break;

      case symbol_kind::S_instruction: // instruction
      case symbol_kind::S_commande: // commande
      case symbol_kind::S_structure_controle: // structure_controle
        value.move< InstructionPtr > (YY_MOVE (s.value));
        break;

      case symbol_kind::S_NUMBER: // NUMBER
        value.move< double > (YY_MOVE (s.value));
        break;

      case symbol_kind::S_VAR_NAME: // VAR_NAME
        value.move< std::string > (YY_MOVE (s.value));
        break;

      case symbol_kind::S_args_appel: // args_appel
        value.move< std::vector<ExpressionPtr> > (YY_MOVE (s.value));
        break;

      case symbol_kind::S_COLOR_HEX: // COLOR_HEX
        value.move< std::vector<double> > (YY_MOVE (s.value));
        break;

      default:
        break;
    }

    location = YY_MOVE (s.location);
  }

  // by_kind.
   Parser ::by_kind::by_kind () YY_NOEXCEPT
    : kind_ (symbol_kind::S_YYEMPTY)
  {}

#if 201103L <= YY_CPLUSPLUS
   Parser ::by_kind::by_kind (by_kind&& that) YY_NOEXCEPT
    : kind_ (that.kind_)
  {
    that.clear ();
  }
#endif

   Parser ::by_kind::by_kind (const by_kind& that) YY_NOEXCEPT
    : kind_ (that.kind_)
  {}

   Parser ::by_kind::by_kind (token_kind_type t) YY_NOEXCEPT
    : kind_ (yytranslate_ (t))
  {}



  void
   Parser ::by_kind::clear () YY_NOEXCEPT
  {
    kind_ = symbol_kind::S_YYEMPTY;
  }

  void
   Parser ::by_kind::move (by_kind& that)
  {
    kind_ = that.kind_;
    that.clear ();
  }

   Parser ::symbol_kind_type
   Parser ::by_kind::kind () const YY_NOEXCEPT
  {
    return kind_;
  }


   Parser ::symbol_kind_type
   Parser ::by_kind::type_get () const YY_NOEXCEPT
  {
    return this->kind ();
  }



  // by_state.
   Parser ::by_state::by_state () YY_NOEXCEPT
    : state (empty_state)
  {}

   Parser ::by_state::by_state (const by_state& that) YY_NOEXCEPT
    : state (that.state)
  {}

  void
   Parser ::by_state::clear () YY_NOEXCEPT
  {
    state = empty_state;
  }

  void
   Parser ::by_state::move (by_state& that)
  {
    state = that.state;
    that.clear ();
  }

   Parser ::by_state::by_state (state_type s) YY_NOEXCEPT
    : state (s)
  {}

   Parser ::symbol_kind_type
   Parser ::by_state::kind () const YY_NOEXCEPT
  {
    if (state == empty_state)
      return symbol_kind::S_YYEMPTY;
    else
      return YY_CAST (symbol_kind_type, yystos_[+state]);
  }

   Parser ::stack_symbol_type::stack_symbol_type ()
  {}

   Parser ::stack_symbol_type::stack_symbol_type (YY_RVREF (stack_symbol_type) that)
    : super_type (YY_MOVE (that.state), YY_MOVE (that.location))
  {
    switch (that.kind ())
    {
      case symbol_kind::S_programme: // programme
      case symbol_kind::S_liste_instructions: // liste_instructions
        value.YY_MOVE_OR_COPY< Bloc* > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_condition: // condition
      case symbol_kind::S_condition_base: // condition_base
        value.YY_MOVE_OR_COPY< ConditionPtr > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_direction: // direction
        value.YY_MOVE_OR_COPY< Direction > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_expression: // expression
        value.YY_MOVE_OR_COPY< ExpressionPtr > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_instruction: // instruction
      case symbol_kind::S_commande: // commande
      case symbol_kind::S_structure_controle: // structure_controle
        value.YY_MOVE_OR_COPY< InstructionPtr > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_NUMBER: // NUMBER
        value.YY_MOVE_OR_COPY< double > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_VAR_NAME: // VAR_NAME
        value.YY_MOVE_OR_COPY< std::string > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_args_appel: // args_appel
        value.YY_MOVE_OR_COPY< std::vector<ExpressionPtr> > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_COLOR_HEX: // COLOR_HEX
        value.YY_MOVE_OR_COPY< std::vector<double> > (YY_MOVE (that.value));
        break;

      default:
        break;
    }

#if 201103L <= YY_CPLUSPLUS
    // that is emptied.
    that.state = empty_state;
#endif
  }

   Parser ::stack_symbol_type::stack_symbol_type (state_type s, YY_MOVE_REF (symbol_type) that)
    : super_type (s, YY_MOVE (that.location))
  {
    switch (that.kind ())
    {
      case symbol_kind::S_programme: // programme
      case symbol_kind::S_liste_instructions: // liste_instructions
        value.move< Bloc* > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_condition: // condition
      case symbol_kind::S_condition_base: // condition_base
        value.move< ConditionPtr > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_direction: // direction
        value.move< Direction > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_expression: // expression
        value.move< ExpressionPtr > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_instruction: // instruction
      case symbol_kind::S_commande: // commande
      case symbol_kind::S_structure_controle: // structure_controle
        value.move< InstructionPtr > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_NUMBER: // NUMBER
        value.move< double > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_VAR_NAME: // VAR_NAME
        value.move< std::string > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_args_appel: // args_appel
        value.move< std::vector<ExpressionPtr> > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_COLOR_HEX: // COLOR_HEX
        value.move< std::vector<double> > (YY_MOVE (that.value));
        break;

      default:
        break;
    }

    // that is emptied.
    that.kind_ = symbol_kind::S_YYEMPTY;
  }

#if YY_CPLUSPLUS < 201103L
   Parser ::stack_symbol_type&
   Parser ::stack_symbol_type::operator= (const stack_symbol_type& that)
  {
    state = that.state;
    switch (that.kind ())
    {
      case symbol_kind::S_programme: // programme
      case symbol_kind::S_liste_instructions: // liste_instructions
        value.copy< Bloc* > (that.value);
        break;

      case symbol_kind::S_condition: // condition
      case symbol_kind::S_condition_base: // condition_base
        value.copy< ConditionPtr > (that.value);
        break;

      case symbol_kind::S_direction: // direction
        value.copy< Direction > (that.value);
        break;

      case symbol_kind::S_expression: // expression
        value.copy< ExpressionPtr > (that.value);
        break;

      case symbol_kind::S_instruction: // instruction
      case symbol_kind::S_commande: // commande
      case symbol_kind::S_structure_controle: // structure_controle
        value.copy< InstructionPtr > (that.value);
        break;

      case symbol_kind::S_NUMBER: // NUMBER
        value.copy< double > (that.value);
        break;

      case symbol_kind::S_VAR_NAME: // VAR_NAME
        value.copy< std::string > (that.value);
        break;

      case symbol_kind::S_args_appel: // args_appel
        value.copy< std::vector<ExpressionPtr> > (that.value);
        break;

      case symbol_kind::S_COLOR_HEX: // COLOR_HEX
        value.copy< std::vector<double> > (that.value);
        break;

      default:
        break;
    }

    location = that.location;
    return *this;
  }

   Parser ::stack_symbol_type&
   Parser ::stack_symbol_type::operator= (stack_symbol_type& that)
  {
    state = that.state;
    switch (that.kind ())
    {
      case symbol_kind::S_programme: // programme
      case symbol_kind::S_liste_instructions: // liste_instructions
        value.move< Bloc* > (that.value);
        break;

      case symbol_kind::S_condition: // condition
      case symbol_kind::S_condition_base: // condition_base
        value.move< ConditionPtr > (that.value);
        break;

      case symbol_kind::S_direction: // direction
        value.move< Direction > (that.value);
        break;

      case symbol_kind::S_expression: // expression
        value.move< ExpressionPtr > (that.value);
        break;

      case symbol_kind::S_instruction: // instruction
      case symbol_kind::S_commande: // commande
      case symbol_kind::S_structure_controle: // structure_controle
        value.move< InstructionPtr > (that.value);
        break;

      case symbol_kind::S_NUMBER: // NUMBER
        value.move< double > (that.value);
        break;

      case symbol_kind::S_VAR_NAME: // VAR_NAME
        value.move< std::string > (that.value);
        break;

      case symbol_kind::S_args_appel: // args_appel
        value.move< std::vector<ExpressionPtr> > (that.value);
        break;

      case symbol_kind::S_COLOR_HEX: // COLOR_HEX
        value.move< std::vector<double> > (that.value);
        break;

      default:
        break;
    }

    location = that.location;
    // that is emptied.
    that.state = empty_state;
    return *this;
  }
#endif

  template <typename Base>
  void
   Parser ::yy_destroy_ (const char* yymsg, basic_symbol<Base>& yysym) const
  {
    if (yymsg)
      YY_SYMBOL_PRINT (yymsg, yysym);
  }

#if YYDEBUG
  template <typename Base>
  void
   Parser ::yy_print_ (std::ostream& yyo, const basic_symbol<Base>& yysym) const
  {
    std::ostream& yyoutput = yyo;
    YY_USE (yyoutput);
    if (yysym.empty ())
      yyo << "empty symbol";
    else
      {
        symbol_kind_type yykind = yysym.kind ();
        yyo << (yykind < YYNTOKENS ? "token" : "nterm")
            << ' ' << yysym.name () << " ("
            << yysym.location << ": ";
        YY_USE (yykind);
        yyo << ')';
      }
  }
#endif

  void
   Parser ::yypush_ (const char* m, YY_MOVE_REF (stack_symbol_type) sym)
  {
    if (m)
      YY_SYMBOL_PRINT (m, sym);
    yystack_.push (YY_MOVE (sym));
  }

  void
   Parser ::yypush_ (const char* m, state_type s, YY_MOVE_REF (symbol_type) sym)
  {
#if 201103L <= YY_CPLUSPLUS
    yypush_ (m, stack_symbol_type (s, std::move (sym)));
#else
    stack_symbol_type ss (s, sym);
    yypush_ (m, ss);
#endif
  }

  void
   Parser ::yypop_ (int n) YY_NOEXCEPT
  {
    yystack_.pop (n);
  }

#if YYDEBUG
  std::ostream&
   Parser ::debug_stream () const
  {
    return *yycdebug_;
  }

  void
   Parser ::set_debug_stream (std::ostream& o)
  {
    yycdebug_ = &o;
  }


   Parser ::debug_level_type
   Parser ::debug_level () const
  {
    return yydebug_;
  }

  void
   Parser ::set_debug_level (debug_level_type l)
  {
    yydebug_ = l;
  }
#endif // YYDEBUG

   Parser ::state_type
   Parser ::yy_lr_goto_state_ (state_type yystate, int yysym)
  {
    int yyr = yypgoto_[yysym - YYNTOKENS] + yystate;
    if (0 <= yyr && yyr <= yylast_ && yycheck_[yyr] == yystate)
      return yytable_[yyr];
    else
      return yydefgoto_[yysym - YYNTOKENS];
  }

  bool
   Parser ::yy_pact_value_is_default_ (int yyvalue) YY_NOEXCEPT
  {
    return yyvalue == yypact_ninf_;
  }

  bool
   Parser ::yy_table_value_is_error_ (int yyvalue) YY_NOEXCEPT
  {
    return yyvalue == yytable_ninf_;
  }

  int
   Parser ::operator() ()
  {
    return parse ();
  }

  int
   Parser ::parse ()
  {
    int yyn;
    /// Length of the RHS of the rule being reduced.
    int yylen = 0;

    // Error handling.
    int yynerrs_ = 0;
    int yyerrstatus_ = 0;

    /// The lookahead symbol.
    symbol_type yyla;

    /// The locations where the error started and ended.
    stack_symbol_type yyerror_range[3];

    /// The return value of parse ().
    int yyresult;

#if YY_EXCEPTIONS
    try
#endif // YY_EXCEPTIONS
      {
    YYCDEBUG << "Starting parse\n";


    /* Initialize the stack.  The initial state will be set in
       yynewstate, since the latter expects the semantical and the
       location values to have been already stored, initialize these
       stacks with a primary value.  */
    yystack_.clear ();
    yypush_ (YY_NULLPTR, 0, YY_MOVE (yyla));

  /*-----------------------------------------------.
  | yynewstate -- push a new symbol on the stack.  |
  `-----------------------------------------------*/
  yynewstate:
    YYCDEBUG << "Entering state " << int (yystack_[0].state) << '\n';
    YY_STACK_PRINT ();

    // Accept?
    if (yystack_[0].state == yyfinal_)
      YYACCEPT;

    goto yybackup;


  /*-----------.
  | yybackup.  |
  `-----------*/
  yybackup:
    // Try to take a decision without lookahead.
    yyn = yypact_[+yystack_[0].state];
    if (yy_pact_value_is_default_ (yyn))
      goto yydefault;

    // Read a lookahead token.
    if (yyla.empty ())
      {
        YYCDEBUG << "Reading a token\n";
#if YY_EXCEPTIONS
        try
#endif // YY_EXCEPTIONS
          {
            yyla.kind_ = yytranslate_ (yylex (&yyla.value, &yyla.location));
          }
#if YY_EXCEPTIONS
        catch (const syntax_error& yyexc)
          {
            YYCDEBUG << "Caught exception: " << yyexc.what() << '\n';
            error (yyexc);
            goto yyerrlab1;
          }
#endif // YY_EXCEPTIONS
      }
    YY_SYMBOL_PRINT ("Next token is", yyla);

    if (yyla.kind () == symbol_kind::S_YYerror)
    {
      // The scanner already issued an error message, process directly
      // to error recovery.  But do not keep the error token as
      // lookahead, it is too special and may lead us to an endless
      // loop in error recovery. */
      yyla.kind_ = symbol_kind::S_YYUNDEF;
      goto yyerrlab1;
    }

    /* If the proper action on seeing token YYLA.TYPE is to reduce or
       to detect an error, take that action.  */
    yyn += yyla.kind ();
    if (yyn < 0 || yylast_ < yyn || yycheck_[yyn] != yyla.kind ())
      {
        goto yydefault;
      }

    // Reduce or error.
    yyn = yytable_[yyn];
    if (yyn <= 0)
      {
        if (yy_table_value_is_error_ (yyn))
          goto yyerrlab;
        yyn = -yyn;
        goto yyreduce;
      }

    // Count tokens shifted since error; after three, turn off error status.
    if (yyerrstatus_)
      --yyerrstatus_;

    // Shift the lookahead token.
    yypush_ ("Shifting", state_type (yyn), YY_MOVE (yyla));
    goto yynewstate;


  /*-----------------------------------------------------------.
  | yydefault -- do the default action for the current state.  |
  `-----------------------------------------------------------*/
  yydefault:
    yyn = yydefact_[+yystack_[0].state];
    if (yyn == 0)
      goto yyerrlab;
    goto yyreduce;


  /*-----------------------------.
  | yyreduce -- do a reduction.  |
  `-----------------------------*/
  yyreduce:
    yylen = yyr2_[yyn];
    {
      stack_symbol_type yylhs;
      yylhs.state = yy_lr_goto_state_ (yystack_[yylen].state, yyr1_[yyn]);
      /* Variants are always initialized to an empty instance of the
         correct type. The default '$$ = $1' action is NOT applied
         when using variants.  */
      switch (yyr1_[yyn])
    {
      case symbol_kind::S_programme: // programme
      case symbol_kind::S_liste_instructions: // liste_instructions
        yylhs.value.emplace< Bloc* > ();
        break;

      case symbol_kind::S_condition: // condition
      case symbol_kind::S_condition_base: // condition_base
        yylhs.value.emplace< ConditionPtr > ();
        break;

      case symbol_kind::S_direction: // direction
        yylhs.value.emplace< Direction > ();
        break;

      case symbol_kind::S_expression: // expression
        yylhs.value.emplace< ExpressionPtr > ();
        break;

      case symbol_kind::S_instruction: // instruction
      case symbol_kind::S_commande: // commande
      case symbol_kind::S_structure_controle: // structure_controle
        yylhs.value.emplace< InstructionPtr > ();
        break;

      case symbol_kind::S_NUMBER: // NUMBER
        yylhs.value.emplace< double > ();
        break;

      case symbol_kind::S_VAR_NAME: // VAR_NAME
        yylhs.value.emplace< std::string > ();
        break;

      case symbol_kind::S_args_appel: // args_appel
        yylhs.value.emplace< std::vector<ExpressionPtr> > ();
        break;

      case symbol_kind::S_COLOR_HEX: // COLOR_HEX
        yylhs.value.emplace< std::vector<double> > ();
        break;

      default:
        break;
    }


      // Default location.
      {
        stack_type::slice range (yystack_, yylen);
        YYLLOC_DEFAULT (yylhs.location, range, yylen);
        yyerror_range[1].location = yylhs.location;
      }

      // Perform the reduction.
      YY_REDUCE_PRINT (yyn);
#if YY_EXCEPTIONS
      try
#endif // YY_EXCEPTIONS
        {
          switch (yyn)
            {
  case 2: // root: programme
#line 68 "parser/parser.yy"
              {
        driver.executer(yystack_[0].value.as < Bloc* > ());
        delete yystack_[0].value.as < Bloc* > ();
        YYACCEPT;
    }
#line 921 "parser/parser.cc"
    break;

  case 3: // programme: programme instruction NL
#line 76 "parser/parser.yy"
                               { yylhs.value.as < Bloc* > () = yystack_[2].value.as < Bloc* > (); yylhs.value.as < Bloc* > ()->ajouter(yystack_[1].value.as < InstructionPtr > ()); }
#line 927 "parser/parser.cc"
    break;

  case 4: // programme: programme instruction END NL
#line 77 "parser/parser.yy"
                                   { yylhs.value.as < Bloc* > () = yystack_[3].value.as < Bloc* > (); yylhs.value.as < Bloc* > ()->ajouter(yystack_[2].value.as < InstructionPtr > ()); }
#line 933 "parser/parser.cc"
    break;

  case 5: // programme: programme instruction END_OF_FILE
#line 78 "parser/parser.yy"
                                        { yylhs.value.as < Bloc* > () = yystack_[2].value.as < Bloc* > (); yylhs.value.as < Bloc* > ()->ajouter(yystack_[1].value.as < InstructionPtr > ()); }
#line 939 "parser/parser.cc"
    break;

  case 6: // programme: programme NL
#line 79 "parser/parser.yy"
                   { yylhs.value.as < Bloc* > () = yystack_[1].value.as < Bloc* > (); }
#line 945 "parser/parser.cc"
    break;

  case 7: // programme: programme definition_fonction NL
#line 80 "parser/parser.yy"
                                       { yylhs.value.as < Bloc* > () = yystack_[2].value.as < Bloc* > (); }
#line 951 "parser/parser.cc"
    break;

  case 8: // programme: %empty
#line 81 "parser/parser.yy"
                 { yylhs.value.as < Bloc* > () = new Bloc(); }
#line 957 "parser/parser.cc"
    break;

  case 9: // definition_fonction: FONCTION VAR_NAME DP NL liste_instructions END FONCTION
#line 85 "parser/parser.yy"
                                                            {
        driver.definirFonction(yystack_[5].value.as < std::string > (), yystack_[2].value.as < Bloc* > ());
    }
#line 965 "parser/parser.cc"
    break;

  case 10: // liste_instructions: liste_instructions instruction NL
#line 91 "parser/parser.yy"
                                        { yylhs.value.as < Bloc* > () = yystack_[2].value.as < Bloc* > (); yylhs.value.as < Bloc* > ()->ajouter(yystack_[1].value.as < InstructionPtr > ()); }
#line 971 "parser/parser.cc"
    break;

  case 11: // liste_instructions: instruction NL
#line 92 "parser/parser.yy"
                     { yylhs.value.as < Bloc* > () = new Bloc(); yylhs.value.as < Bloc* > ()->ajouter(yystack_[1].value.as < InstructionPtr > ()); }
#line 977 "parser/parser.cc"
    break;

  case 12: // liste_instructions: liste_instructions NL
#line 93 "parser/parser.yy"
                            { yylhs.value.as < Bloc* > () = yystack_[1].value.as < Bloc* > (); }
#line 983 "parser/parser.cc"
    break;

  case 13: // liste_instructions: NL
#line 94 "parser/parser.yy"
         { yylhs.value.as < Bloc* > () = new Bloc(); }
#line 989 "parser/parser.cc"
    break;

  case 14: // instruction: commande
#line 98 "parser/parser.yy"
               { yylhs.value.as < InstructionPtr > () = yystack_[0].value.as < InstructionPtr > (); }
#line 995 "parser/parser.cc"
    break;

  case 15: // instruction: structure_controle
#line 99 "parser/parser.yy"
                         { yylhs.value.as < InstructionPtr > () = yystack_[0].value.as < InstructionPtr > (); }
#line 1001 "parser/parser.cc"
    break;

  case 21: // commande: AVANCE expression unite_opt
#line 114 "parser/parser.yy"
                                  { yylhs.value.as < InstructionPtr > () = std::make_shared<CommandeMouvement>(yystack_[1].value.as < ExpressionPtr > (), TypeMouvement::AVANCE); }
#line 1007 "parser/parser.cc"
    break;

  case 22: // commande: RECULE expression unite_opt
#line 115 "parser/parser.yy"
                                  { yylhs.value.as < InstructionPtr > () = std::make_shared<CommandeMouvement>(yystack_[1].value.as < ExpressionPtr > (), TypeMouvement::RECULE); }
#line 1013 "parser/parser.cc"
    break;

  case 23: // commande: SAUTE expression unite_opt
#line 116 "parser/parser.yy"
                                  { yylhs.value.as < InstructionPtr > () = std::make_shared<CommandeMouvement>(yystack_[1].value.as < ExpressionPtr > (), TypeMouvement::SAUTE); }
#line 1019 "parser/parser.cc"
    break;

  case 24: // commande: TOURNE expression unite_opt
#line 117 "parser/parser.yy"
                                  { yylhs.value.as < InstructionPtr > () = std::make_shared<CommandeMouvement>(yystack_[1].value.as < ExpressionPtr > (), TypeMouvement::TOURNE); }
#line 1025 "parser/parser.cc"
    break;

  case 25: // commande: AVANCE unite_special
#line 119 "parser/parser.yy"
                           { yylhs.value.as < InstructionPtr > () = std::make_shared<CommandeMouvement>(std::make_shared<Constante>(1.0), TypeMouvement::AVANCE); }
#line 1031 "parser/parser.cc"
    break;

  case 26: // commande: RECULE unite_special
#line 120 "parser/parser.yy"
                           { yylhs.value.as < InstructionPtr > () = std::make_shared<CommandeMouvement>(std::make_shared<Constante>(1.0), TypeMouvement::RECULE); }
#line 1037 "parser/parser.cc"
    break;

  case 27: // commande: SAUTE unite_special
#line 121 "parser/parser.yy"
                           { yylhs.value.as < InstructionPtr > () = std::make_shared<CommandeMouvement>(std::make_shared<Constante>(1.0), TypeMouvement::SAUTE); }
#line 1043 "parser/parser.cc"
    break;

  case 28: // commande: TOURNE unite_special
#line 122 "parser/parser.yy"
                           { yylhs.value.as < InstructionPtr > () = std::make_shared<CommandeMouvement>(std::make_shared<Constante>(90.0), TypeMouvement::TOURNE); }
#line 1049 "parser/parser.cc"
    break;

  case 29: // commande: TOURNE direction
#line 124 "parser/parser.yy"
                        {
        double angle = (yystack_[0].value.as < Direction > () == Direction::GAUCHE) ? -90.0 : 90.0;
        yylhs.value.as < InstructionPtr > () = std::make_shared<CommandeMouvement>(std::make_shared<Constante>(angle), TypeMouvement::TOURNE);
      }
#line 1058 "parser/parser.cc"
    break;

  case 30: // commande: TOURNE direction expression unite_opt
#line 128 "parser/parser.yy"
                                            {
         ExpressionPtr angle = yystack_[1].value.as < ExpressionPtr > ();
         if (yystack_[2].value.as < Direction > () == Direction::GAUCHE) {
             angle = std::make_shared<ExpressionUnaire>(yystack_[1].value.as < ExpressionPtr > (), OperateurUnaire::neg);
         }
         yylhs.value.as < InstructionPtr > () = std::make_shared<CommandeMouvement>(angle, TypeMouvement::TOURNE);
    }
#line 1070 "parser/parser.cc"
    break;

  case 31: // commande: TORTUES expression
#line 136 "parser/parser.yy"
                         { yylhs.value.as < InstructionPtr > () = std::make_shared<Bloc>(); }
#line 1076 "parser/parser.cc"
    break;

  case 32: // commande: COULEUR COLOR_HEX
#line 137 "parser/parser.yy"
                        { yylhs.value.as < InstructionPtr > () = std::make_shared<CommandeCouleur>(yystack_[0].value.as < std::vector<double> > ()[0], yystack_[0].value.as < std::vector<double> > ()[1], yystack_[0].value.as < std::vector<double> > ()[2]); }
#line 1082 "parser/parser.cc"
    break;

  case 33: // commande: COULEUR VAR_NAME
#line 138 "parser/parser.yy"
                       { yylhs.value.as < InstructionPtr > () = std::make_shared<CommandeCouleur>(255, 0, 0); }
#line 1088 "parser/parser.cc"
    break;

  case 34: // commande: JARDIN VAR_NAME
#line 140 "parser/parser.yy"
                        { driver.nouveauJardin(yystack_[0].value.as < std::string > ()); yylhs.value.as < InstructionPtr > () = std::make_shared<Bloc>(); }
#line 1094 "parser/parser.cc"
    break;

  case 35: // commande: VAR_NAME args_appel
#line 141 "parser/parser.yy"
                          { yylhs.value.as < InstructionPtr > () = std::make_shared<AppelFonction>(yystack_[1].value.as < std::string > (), yystack_[0].value.as < std::vector<ExpressionPtr> > ()); }
#line 1100 "parser/parser.cc"
    break;

  case 36: // commande: commande AROBASE expression
#line 142 "parser/parser.yy"
                                  {
        Bloc* b = new Bloc();
        b->ajouter(std::make_shared<CommandeSelectionTortue>(yystack_[0].value.as < ExpressionPtr > ()));
        b->ajouter(yystack_[2].value.as < InstructionPtr > ());
        yylhs.value.as < InstructionPtr > () = std::shared_ptr<Instruction>(b);
    }
#line 1111 "parser/parser.cc"
    break;

  case 37: // structure_controle: SI condition DP NL liste_instructions END SI
#line 151 "parser/parser.yy"
                                                   {
          yylhs.value.as < InstructionPtr > () = std::make_shared<ControleSi>(yystack_[5].value.as < ConditionPtr > (), std::shared_ptr<Instruction>(yystack_[2].value.as < Bloc* > ()));
      }
#line 1119 "parser/parser.cc"
    break;

  case 38: // structure_controle: SI condition DP NL liste_instructions SINON DP NL liste_instructions END SI
#line 154 "parser/parser.yy"
                                                                                  {
          yylhs.value.as < InstructionPtr > () = std::make_shared<ControleSi>(yystack_[9].value.as < ConditionPtr > (), std::shared_ptr<Instruction>(yystack_[6].value.as < Bloc* > ()), std::shared_ptr<Instruction>(yystack_[2].value.as < Bloc* > ()));
      }
#line 1127 "parser/parser.cc"
    break;

  case 39: // structure_controle: TANT QUE condition DP NL liste_instructions END TANT QUE
#line 157 "parser/parser.yy"
                                                               {
          yylhs.value.as < InstructionPtr > () = std::make_shared<ControleTantQue>(yystack_[6].value.as < ConditionPtr > (), std::shared_ptr<Instruction>(yystack_[3].value.as < Bloc* > ()));
      }
#line 1135 "parser/parser.cc"
    break;

  case 40: // structure_controle: REPETE expression DP NL liste_instructions END REPETE
#line 160 "parser/parser.yy"
                                                            {
          yylhs.value.as < InstructionPtr > () = std::make_shared<ControleRepete>(yystack_[5].value.as < ExpressionPtr > (), std::shared_ptr<Instruction>(yystack_[2].value.as < Bloc* > ()));
      }
#line 1143 "parser/parser.cc"
    break;

  case 41: // args_appel: args_appel expression
#line 166 "parser/parser.yy"
                            { yylhs.value.as < std::vector<ExpressionPtr> > () = yystack_[1].value.as < std::vector<ExpressionPtr> > (); yylhs.value.as < std::vector<ExpressionPtr> > ().push_back(yystack_[0].value.as < ExpressionPtr > ()); }
#line 1149 "parser/parser.cc"
    break;

  case 42: // args_appel: %empty
#line 167 "parser/parser.yy"
                 { }
#line 1155 "parser/parser.cc"
    break;

  case 43: // condition: condition_base
#line 171 "parser/parser.yy"
                     { yylhs.value.as < ConditionPtr > () = yystack_[0].value.as < ConditionPtr > (); }
#line 1161 "parser/parser.cc"
    break;

  case 44: // condition: PAS condition_base
#line 172 "parser/parser.yy"
                         { yylhs.value.as < ConditionPtr > () = yystack_[0].value.as < ConditionPtr > (); }
#line 1167 "parser/parser.cc"
    break;

  case 45: // condition: condition ET condition
#line 173 "parser/parser.yy"
                             { yylhs.value.as < ConditionPtr > () = std::make_shared<ConditionBinaire>(yystack_[2].value.as < ConditionPtr > (), yystack_[0].value.as < ConditionPtr > (), OperateurBinaireBool::et); }
#line 1173 "parser/parser.cc"
    break;

  case 46: // condition: condition OU condition
#line 174 "parser/parser.yy"
                             { yylhs.value.as < ConditionPtr > () = std::make_shared<ConditionBinaire>(yystack_[2].value.as < ConditionPtr > (), yystack_[0].value.as < ConditionPtr > (), OperateurBinaireBool::ou); }
#line 1179 "parser/parser.cc"
    break;

  case 47: // condition: LPAR condition RPAR
#line 175 "parser/parser.yy"
                          { yylhs.value.as < ConditionPtr > () = yystack_[1].value.as < ConditionPtr > (); }
#line 1185 "parser/parser.cc"
    break;

  case 48: // condition_base: MUR direction
#line 180 "parser/parser.yy"
                    { yylhs.value.as < ConditionPtr > () = std::make_shared<ConditionCapteur>(TypeCapteur::MUR, yystack_[0].value.as < Direction > ()); }
#line 1191 "parser/parser.cc"
    break;

  case 49: // condition_base: VIDE direction
#line 181 "parser/parser.yy"
                     { yylhs.value.as < ConditionPtr > () = std::make_shared<ConditionCapteur>(TypeCapteur::VIDE, yystack_[0].value.as < Direction > ()); }
#line 1197 "parser/parser.cc"
    break;

  case 50: // condition_base: PAS MUR direction
#line 182 "parser/parser.yy"
                        { yylhs.value.as < ConditionPtr > () = std::make_shared<ConditionCapteur>(TypeCapteur::VIDE, yystack_[0].value.as < Direction > ()); }
#line 1203 "parser/parser.cc"
    break;

  case 51: // condition_base: PAS VIDE direction
#line 183 "parser/parser.yy"
                         { yylhs.value.as < ConditionPtr > () = std::make_shared<ConditionCapteur>(TypeCapteur::MUR, yystack_[0].value.as < Direction > ()); }
#line 1209 "parser/parser.cc"
    break;

  case 52: // condition_base: MUR direction AROBASE expression
#line 185 "parser/parser.yy"
                                       { yylhs.value.as < ConditionPtr > () = std::make_shared<ConditionCapteur>(TypeCapteur::MUR, yystack_[2].value.as < Direction > (), yystack_[0].value.as < ExpressionPtr > ()); }
#line 1215 "parser/parser.cc"
    break;

  case 53: // condition_base: VIDE direction AROBASE expression
#line 186 "parser/parser.yy"
                                        { yylhs.value.as < ConditionPtr > () = std::make_shared<ConditionCapteur>(TypeCapteur::VIDE, yystack_[2].value.as < Direction > (), yystack_[0].value.as < ExpressionPtr > ()); }
#line 1221 "parser/parser.cc"
    break;

  case 54: // condition_base: PAS MUR direction AROBASE expression
#line 187 "parser/parser.yy"
                                           { yylhs.value.as < ConditionPtr > () = std::make_shared<ConditionCapteur>(TypeCapteur::VIDE, yystack_[2].value.as < Direction > (), yystack_[0].value.as < ExpressionPtr > ()); }
#line 1227 "parser/parser.cc"
    break;

  case 55: // condition_base: PAS VIDE direction AROBASE expression
#line 188 "parser/parser.yy"
                                            { yylhs.value.as < ConditionPtr > () = std::make_shared<ConditionCapteur>(TypeCapteur::MUR, yystack_[2].value.as < Direction > (), yystack_[0].value.as < ExpressionPtr > ()); }
#line 1233 "parser/parser.cc"
    break;

  case 56: // condition_base: expression EGAL expression
#line 190 "parser/parser.yy"
                                 { yylhs.value.as < ConditionPtr > () = std::make_shared<TestBinaire>(yystack_[2].value.as < ExpressionPtr > (), yystack_[0].value.as < ExpressionPtr > (), OperateurBool::egal); }
#line 1239 "parser/parser.cc"
    break;

  case 57: // condition_base: expression DIFFERENT expression
#line 191 "parser/parser.yy"
                                      { yylhs.value.as < ConditionPtr > () = std::make_shared<TestBinaire>(yystack_[2].value.as < ExpressionPtr > (), yystack_[0].value.as < ExpressionPtr > (), OperateurBool::different); }
#line 1245 "parser/parser.cc"
    break;

  case 58: // condition_base: expression INF expression
#line 192 "parser/parser.yy"
                                { yylhs.value.as < ConditionPtr > () = std::make_shared<TestBinaire>(yystack_[2].value.as < ExpressionPtr > (), yystack_[0].value.as < ExpressionPtr > (), OperateurBool::pluspetit); }
#line 1251 "parser/parser.cc"
    break;

  case 59: // condition_base: expression SUP expression
#line 193 "parser/parser.yy"
                                { yylhs.value.as < ConditionPtr > () = std::make_shared<TestBinaire>(yystack_[2].value.as < ExpressionPtr > (), yystack_[0].value.as < ExpressionPtr > (), OperateurBool::plusgrand); }
#line 1257 "parser/parser.cc"
    break;

  case 60: // direction: DEVANT
#line 197 "parser/parser.yy"
             { yylhs.value.as < Direction > () = Direction::DEVANT; }
#line 1263 "parser/parser.cc"
    break;

  case 61: // direction: DERRIERE
#line 198 "parser/parser.yy"
               { yylhs.value.as < Direction > () = Direction::DERRIERE; }
#line 1269 "parser/parser.cc"
    break;

  case 62: // direction: GAUCHE
#line 199 "parser/parser.yy"
             { yylhs.value.as < Direction > () = Direction::GAUCHE; }
#line 1275 "parser/parser.cc"
    break;

  case 63: // direction: DROITE
#line 200 "parser/parser.yy"
             { yylhs.value.as < Direction > () = Direction::DROITE; }
#line 1281 "parser/parser.cc"
    break;

  case 64: // expression: NUMBER
#line 204 "parser/parser.yy"
             { yylhs.value.as < ExpressionPtr > () = std::make_shared<Constante>(yystack_[0].value.as < double > ()); }
#line 1287 "parser/parser.cc"
    break;

  case 65: // expression: VAR_NAME
#line 205 "parser/parser.yy"
               { yylhs.value.as < ExpressionPtr > () = std::make_shared<Variable>(yystack_[0].value.as < std::string > ()); }
#line 1293 "parser/parser.cc"
    break;

  case 66: // expression: DOLLAR NUMBER
#line 206 "parser/parser.yy"
                    { yylhs.value.as < ExpressionPtr > () = std::make_shared<Variable>("$" + std::to_string((int)yystack_[0].value.as < double > ())); }
#line 1299 "parser/parser.cc"
    break;

  case 67: // expression: expression PLUS expression
#line 207 "parser/parser.yy"
                                 { yylhs.value.as < ExpressionPtr > () = std::make_shared<ExpressionBinaire>(yystack_[2].value.as < ExpressionPtr > (), yystack_[0].value.as < ExpressionPtr > (), OperateurBinaire::plus); }
#line 1305 "parser/parser.cc"
    break;

  case 68: // expression: expression MOINS expression
#line 208 "parser/parser.yy"
                                  { yylhs.value.as < ExpressionPtr > () = std::make_shared<ExpressionBinaire>(yystack_[2].value.as < ExpressionPtr > (), yystack_[0].value.as < ExpressionPtr > (), OperateurBinaire::moins); }
#line 1311 "parser/parser.cc"
    break;

  case 69: // expression: expression MULT expression
#line 209 "parser/parser.yy"
                                 { yylhs.value.as < ExpressionPtr > () = std::make_shared<ExpressionBinaire>(yystack_[2].value.as < ExpressionPtr > (), yystack_[0].value.as < ExpressionPtr > (), OperateurBinaire::multiplie); }
#line 1317 "parser/parser.cc"
    break;

  case 70: // expression: expression DIV expression
#line 210 "parser/parser.yy"
                                { yylhs.value.as < ExpressionPtr > () = std::make_shared<ExpressionBinaire>(yystack_[2].value.as < ExpressionPtr > (), yystack_[0].value.as < ExpressionPtr > (), OperateurBinaire::divise); }
#line 1323 "parser/parser.cc"
    break;

  case 71: // expression: MOINS expression
#line 211 "parser/parser.yy"
                                 { yylhs.value.as < ExpressionPtr > () = std::make_shared<ExpressionUnaire>(yystack_[0].value.as < ExpressionPtr > (), OperateurUnaire::neg); }
#line 1329 "parser/parser.cc"
    break;

  case 72: // expression: LPAR expression RPAR
#line 212 "parser/parser.yy"
                           { yylhs.value.as < ExpressionPtr > () = yystack_[1].value.as < ExpressionPtr > (); }
#line 1335 "parser/parser.cc"
    break;


#line 1339 "parser/parser.cc"

            default:
              break;
            }
        }
#if YY_EXCEPTIONS
      catch (const syntax_error& yyexc)
        {
          YYCDEBUG << "Caught exception: " << yyexc.what() << '\n';
          error (yyexc);
          YYERROR;
        }
#endif // YY_EXCEPTIONS
      YY_SYMBOL_PRINT ("-> $$ =", yylhs);
      yypop_ (yylen);
      yylen = 0;

      // Shift the result of the reduction.
      yypush_ (YY_NULLPTR, YY_MOVE (yylhs));
    }
    goto yynewstate;


  /*--------------------------------------.
  | yyerrlab -- here on detecting error.  |
  `--------------------------------------*/
  yyerrlab:
    // If not already recovering from an error, report this error.
    if (!yyerrstatus_)
      {
        ++yynerrs_;
        std::string msg = YY_("syntax error");
        error (yyla.location, YY_MOVE (msg));
      }


    yyerror_range[1].location = yyla.location;
    if (yyerrstatus_ == 3)
      {
        /* If just tried and failed to reuse lookahead token after an
           error, discard it.  */

        // Return failure if at end of input.
        if (yyla.kind () == symbol_kind::S_YYEOF)
          YYABORT;
        else if (!yyla.empty ())
          {
            yy_destroy_ ("Error: discarding", yyla);
            yyla.clear ();
          }
      }

    // Else will try to reuse lookahead token after shifting the error token.
    goto yyerrlab1;


  /*---------------------------------------------------.
  | yyerrorlab -- error raised explicitly by YYERROR.  |
  `---------------------------------------------------*/
  yyerrorlab:
    /* Pacify compilers when the user code never invokes YYERROR and
       the label yyerrorlab therefore never appears in user code.  */
    if (false)
      YYERROR;

    /* Do not reclaim the symbols of the rule whose action triggered
       this YYERROR.  */
    yypop_ (yylen);
    yylen = 0;
    YY_STACK_PRINT ();
    goto yyerrlab1;


  /*-------------------------------------------------------------.
  | yyerrlab1 -- common code for both syntax error and YYERROR.  |
  `-------------------------------------------------------------*/
  yyerrlab1:
    yyerrstatus_ = 3;   // Each real token shifted decrements this.
    // Pop stack until we find a state that shifts the error token.
    for (;;)
      {
        yyn = yypact_[+yystack_[0].state];
        if (!yy_pact_value_is_default_ (yyn))
          {
            yyn += symbol_kind::S_YYerror;
            if (0 <= yyn && yyn <= yylast_
                && yycheck_[yyn] == symbol_kind::S_YYerror)
              {
                yyn = yytable_[yyn];
                if (0 < yyn)
                  break;
              }
          }

        // Pop the current state because it cannot handle the error token.
        if (yystack_.size () == 1)
          YYABORT;

        yyerror_range[1].location = yystack_[0].location;
        yy_destroy_ ("Error: popping", yystack_[0]);
        yypop_ ();
        YY_STACK_PRINT ();
      }
    {
      stack_symbol_type error_token;

      yyerror_range[2].location = yyla.location;
      YYLLOC_DEFAULT (error_token.location, yyerror_range, 2);

      // Shift the error token.
      error_token.state = state_type (yyn);
      yypush_ ("Shifting", YY_MOVE (error_token));
    }
    goto yynewstate;


  /*-------------------------------------.
  | yyacceptlab -- YYACCEPT comes here.  |
  `-------------------------------------*/
  yyacceptlab:
    yyresult = 0;
    goto yyreturn;


  /*-----------------------------------.
  | yyabortlab -- YYABORT comes here.  |
  `-----------------------------------*/
  yyabortlab:
    yyresult = 1;
    goto yyreturn;


  /*-----------------------------------------------------.
  | yyreturn -- parsing is finished, return the result.  |
  `-----------------------------------------------------*/
  yyreturn:
    if (!yyla.empty ())
      yy_destroy_ ("Cleanup: discarding lookahead", yyla);

    /* Do not reclaim the symbols of the rule whose action triggered
       this YYABORT or YYACCEPT.  */
    yypop_ (yylen);
    YY_STACK_PRINT ();
    while (1 < yystack_.size ())
      {
        yy_destroy_ ("Cleanup: popping", yystack_[0]);
        yypop_ ();
      }

    return yyresult;
  }
#if YY_EXCEPTIONS
    catch (...)
      {
        YYCDEBUG << "Exception caught: cleaning lookahead and stack\n";
        // Do not try to display the values of the reclaimed symbols,
        // as their printers might throw an exception.
        if (!yyla.empty ())
          yy_destroy_ (YY_NULLPTR, yyla);

        while (1 < yystack_.size ())
          {
            yy_destroy_ (YY_NULLPTR, yystack_[0]);
            yypop_ ();
          }
        throw;
      }
#endif // YY_EXCEPTIONS
  }

  void
   Parser ::error (const syntax_error& yyexc)
  {
    error (yyexc.location, yyexc.what ());
  }

#if YYDEBUG || 0
  const char *
   Parser ::symbol_name (symbol_kind_type yysymbol)
  {
    return yytname_[yysymbol];
  }
#endif // #if YYDEBUG || 0









  const signed char  Parser ::yypact_ninf_ = -105;

  const signed char  Parser ::yytable_ninf_ = -1;

  const short
   Parser ::yypact_[] =
  {
    -105,    10,   145,  -105,  -105,     1,     1,   259,     1,     9,
      88,   -30,   -24,    45,    11,    88,  -105,    23,    67,     3,
    -105,  -105,    -8,    88,    88,  -105,  -105,  -105,     6,  -105,
       6,  -105,  -105,  -105,  -105,  -105,    88,     6,  -105,     6,
    -105,  -105,   188,  -105,    15,   249,   249,   237,    45,    19,
    -105,   105,    45,   152,    88,  -105,  -105,    44,  -105,    88,
    -105,  -105,   115,  -105,    88,    88,    88,    88,  -105,  -105,
    -105,     6,  -105,  -105,    46,    29,    47,   249,   249,    57,
    -105,   -25,    59,    76,    45,    45,    88,    88,    88,    88,
      41,    89,   188,  -105,   188,  -105,   223,   223,  -105,  -105,
    -105,   235,    88,    88,    75,    83,   249,   249,  -105,   235,
    -105,    87,   188,   188,   188,   188,   111,   235,  -105,   161,
     125,   188,   188,    88,    88,   104,   133,    97,   235,   182,
    -105,   149,   163,  -105,   188,   188,    88,    88,   160,   150,
     198,   162,  -105,  -105,   188,   188,  -105,   192,   181,  -105,
     235,   194,   219,  -105,   185,  -105
  };

  const signed char
   Parser ::yydefact_[] =
  {
       8,     0,     2,     1,     6,    19,    19,    19,    19,     0,
       0,     0,     0,     0,     0,     0,    42,     0,     0,    14,
      15,    20,     0,     0,     0,    64,    65,    25,    16,    26,
      16,    60,    61,    62,    63,    28,    29,    16,    27,    16,
      33,    32,    31,    34,     0,     0,     0,     0,     0,     0,
      43,     0,     0,     0,    35,     7,     3,     0,     5,     0,
      66,    71,     0,    17,     0,     0,     0,     0,    18,    21,
      22,    16,    24,    23,     0,    48,    49,     0,     0,     0,
      44,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    41,     4,    36,    72,    67,    68,    69,    70,
      30,     0,     0,     0,    48,    49,     0,     0,    47,     0,
      45,    46,    56,    57,    58,    59,     0,     0,    13,     0,
       0,    52,    53,     0,     0,    50,    51,     0,     0,     0,
      12,     0,     0,    11,    52,    53,     0,     0,     0,     0,
       0,     0,     9,    10,    54,    55,    37,     0,     0,    40,
       0,     0,     0,    39,     0,    38
  };

  const short
   Parser ::yypgoto_[] =
  {
    -105,  -105,  -105,  -105,  -104,    -2,   -14,   116,  -105,  -105,
    -105,   -31,   166,   -38,    -4
  };

  const signed char
   Parser ::yydefgoto_[] =
  {
       0,     1,     2,    17,   119,   120,    69,    27,    19,    20,
      54,    49,    50,    36,    51
  };

  const unsigned char
   Parser ::yytable_[] =
  {
      18,    28,    30,    37,    39,   127,    42,    75,    76,   108,
       3,    53,    43,   129,    84,    85,    70,    81,    44,    61,
      62,    90,    21,    72,   140,    73,    55,    63,    52,    22,
      59,    23,    71,    60,    24,    64,    65,    66,    67,   104,
     105,    74,    25,    26,    82,    83,   152,    93,    68,   101,
      92,    40,    41,   110,   111,    94,   102,   100,    84,    85,
      96,    97,    98,    99,    45,    46,    47,   116,   125,   126,
      56,    57,    58,    22,   103,    23,   106,   107,    48,   109,
      84,    85,   112,   113,   114,   115,    25,    26,    64,    65,
      66,    67,   117,    95,    86,    87,    88,    89,   121,   122,
     130,   138,   123,     5,     6,     7,     8,     9,    10,    11,
     124,    13,   139,    14,   128,    15,    22,   132,    23,   134,
     135,    24,    29,    35,    38,   132,    84,   132,   133,    25,
      26,   136,   144,   145,    64,    65,    66,    67,   132,    16,
      86,    87,    88,    89,    64,    65,    66,    67,     4,    95,
     132,     5,     6,     7,     8,     9,    10,    11,    12,    13,
     137,    14,   142,    15,   130,   131,   143,     5,     6,     7,
       8,     9,    10,    11,   146,    13,   147,    14,    91,    15,
     149,    64,    65,    66,    67,   130,   141,    16,     5,     6,
       7,     8,     9,    10,    11,   150,    13,   151,    14,   155,
      15,   130,   148,    16,     5,     6,     7,     8,     9,    10,
      11,   153,    13,    80,    14,     0,    15,    64,    65,    66,
      67,     0,   130,   154,    16,     5,     6,     7,     8,     9,
      10,    11,     0,    13,     0,    14,     0,    15,   118,     0,
      16,     5,     6,     7,     8,     9,    10,    11,     0,    13,
       0,    14,     0,    15,    66,    67,    77,    78,    79,     0,
       0,    16,     0,     0,     0,    22,     0,    23,     0,     0,
      24,    31,    32,    33,    34,     0,     0,    16,    25,    26,
      21,    31,    32,    33,    34,     0,     0,    22,     0,    23,
       0,     0,    24,     0,     0,     0,     0,     0,     0,     0,
      25,    26
  };

  const short
   Parser ::yycheck_[] =
  {
       2,     5,     6,     7,     8,   109,    10,    45,    46,    34,
       0,    15,    42,   117,    39,    40,    30,    48,    42,    23,
      24,    52,    21,    37,   128,    39,     3,    21,    17,    28,
      27,    30,    36,    41,    33,    29,    30,    31,    32,    77,
      78,    26,    41,    42,    48,    26,   150,     3,    42,     3,
      54,    42,    43,    84,    85,    59,    27,    71,    39,    40,
      64,    65,    66,    67,    19,    20,    21,    26,   106,   107,
       3,     4,     5,    28,    27,    30,    19,    20,    33,     3,
      39,    40,    86,    87,    88,    89,    41,    42,    29,    30,
      31,    32,     3,    34,    35,    36,    37,    38,   102,   103,
       3,     4,    27,     6,     7,     8,     9,    10,    11,    12,
      27,    14,    15,    16,     3,    18,    28,   119,    30,   123,
     124,    33,     6,     7,     8,   127,    39,   129,     3,    41,
      42,    27,   136,   137,    29,    30,    31,    32,   140,    42,
      35,    36,    37,    38,    29,    30,    31,    32,     3,    34,
     152,     6,     7,     8,     9,    10,    11,    12,    13,    14,
      27,    16,    13,    18,     3,     4,     3,     6,     7,     8,
       9,    10,    11,    12,    14,    14,    26,    16,    26,    18,
      18,    29,    30,    31,    32,     3,     4,    42,     6,     7,
       8,     9,    10,    11,    12,     3,    14,    16,    16,    14,
      18,     3,     4,    42,     6,     7,     8,     9,    10,    11,
      12,    17,    14,    47,    16,    -1,    18,    29,    30,    31,
      32,    -1,     3,     4,    42,     6,     7,     8,     9,    10,
      11,    12,    -1,    14,    -1,    16,    -1,    18,     3,    -1,
      42,     6,     7,     8,     9,    10,    11,    12,    -1,    14,
      -1,    16,    -1,    18,    31,    32,    19,    20,    21,    -1,
      -1,    42,    -1,    -1,    -1,    28,    -1,    30,    -1,    -1,
      33,    22,    23,    24,    25,    -1,    -1,    42,    41,    42,
      21,    22,    23,    24,    25,    -1,    -1,    28,    -1,    30,
      -1,    -1,    33,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      41,    42
  };

  const signed char
   Parser ::yystos_[] =
  {
       0,    46,    47,     0,     3,     6,     7,     8,     9,    10,
      11,    12,    13,    14,    16,    18,    42,    48,    50,    53,
      54,    21,    28,    30,    33,    41,    42,    52,    59,    52,
      59,    22,    23,    24,    25,    52,    58,    59,    52,    59,
      42,    43,    59,    42,    42,    19,    20,    21,    33,    56,
      57,    59,    17,    59,    55,     3,     3,     4,     5,    27,
      41,    59,    59,    21,    29,    30,    31,    32,    42,    51,
      51,    59,    51,    51,    26,    58,    58,    19,    20,    21,
      57,    56,    59,    26,    39,    40,    35,    36,    37,    38,
      56,    26,    59,     3,    59,    34,    59,    59,    59,    59,
      51,     3,    27,    27,    58,    58,    19,    20,    34,     3,
      56,    56,    59,    59,    59,    59,    26,     3,     3,    49,
      50,    59,    59,    27,    27,    58,    58,    49,     3,    49,
       3,     4,    50,     3,    59,    59,    27,    27,     4,    15,
      49,     4,    13,     3,    59,    59,    14,    26,     4,    18,
       3,    16,    49,    17,     4,    14
  };

  const signed char
   Parser ::yyr1_[] =
  {
       0,    45,    46,    47,    47,    47,    47,    47,    47,    48,
      49,    49,    49,    49,    50,    50,    51,    51,    51,    52,
      52,    53,    53,    53,    53,    53,    53,    53,    53,    53,
      53,    53,    53,    53,    53,    53,    53,    54,    54,    54,
      54,    55,    55,    56,    56,    56,    56,    56,    57,    57,
      57,    57,    57,    57,    57,    57,    57,    57,    57,    57,
      58,    58,    58,    58,    59,    59,    59,    59,    59,    59,
      59,    59,    59
  };

  const signed char
   Parser ::yyr2_[] =
  {
       0,     2,     1,     3,     4,     3,     2,     3,     0,     7,
       3,     2,     2,     1,     1,     1,     0,     1,     1,     0,
       1,     3,     3,     3,     3,     2,     2,     2,     2,     2,
       4,     2,     2,     2,     2,     2,     3,     7,    11,     9,
       7,     2,     0,     1,     2,     3,     3,     3,     2,     2,
       3,     3,     4,     4,     5,     5,     3,     3,     3,     3,
       1,     1,     1,     1,     1,     1,     2,     3,     3,     3,
       3,     2,     3
  };


#if YYDEBUG
  // YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
  // First, the terminals, then, starting at \a YYNTOKENS, nonterminals.
  const char*
  const  Parser ::yytname_[] =
  {
  "\"end of file\"", "error", "\"invalid token\"", "NL", "END",
  "END_OF_FILE", "AVANCE", "RECULE", "TOURNE", "SAUTE", "COULEUR",
  "TORTUES", "JARDIN", "FONCTION", "SI", "SINON", "TANT", "QUE", "REPETE",
  "MUR", "VIDE", "PAS", "DEVANT", "DERRIERE", "GAUCHE", "DROITE", "DP",
  "AROBASE", "DOLLAR", "PLUS", "MOINS", "MULT", "DIV", "LPAR", "RPAR",
  "EGAL", "DIFFERENT", "INF", "SUP", "ET", "OU", "NUMBER", "VAR_NAME",
  "COLOR_HEX", "NEG", "$accept", "root", "programme",
  "definition_fonction", "liste_instructions", "instruction", "unite_opt",
  "unite_special", "commande", "structure_controle", "args_appel",
  "condition", "condition_base", "direction", "expression", YY_NULLPTR
  };
#endif


#if YYDEBUG
  const unsigned char
   Parser ::yyrline_[] =
  {
       0,    68,    68,    76,    77,    78,    79,    80,    81,    85,
      91,    92,    93,    94,    98,    99,   102,   104,   105,   108,
     110,   114,   115,   116,   117,   119,   120,   121,   122,   124,
     128,   136,   137,   138,   140,   141,   142,   151,   154,   157,
     160,   166,   167,   171,   172,   173,   174,   175,   180,   181,
     182,   183,   185,   186,   187,   188,   190,   191,   192,   193,
     197,   198,   199,   200,   204,   205,   206,   207,   208,   209,
     210,   211,   212
  };

  void
   Parser ::yy_stack_print_ () const
  {
    *yycdebug_ << "Stack now";
    for (stack_type::const_iterator
           i = yystack_.begin (),
           i_end = yystack_.end ();
         i != i_end; ++i)
      *yycdebug_ << ' ' << int (i->state);
    *yycdebug_ << '\n';
  }

  void
   Parser ::yy_reduce_print_ (int yyrule) const
  {
    int yylno = yyrline_[yyrule];
    int yynrhs = yyr2_[yyrule];
    // Print the symbols being reduced, and their result.
    *yycdebug_ << "Reducing stack by rule " << yyrule - 1
               << " (line " << yylno << "):\n";
    // The symbols being reduced.
    for (int yyi = 0; yyi < yynrhs; yyi++)
      YY_SYMBOL_PRINT ("   $" << yyi + 1 << " =",
                       yystack_[(yynrhs) - (yyi + 1)]);
  }
#endif // YYDEBUG

   Parser ::symbol_kind_type
   Parser ::yytranslate_ (int t) YY_NOEXCEPT
  {
    // YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to
    // TOKEN-NUM as returned by yylex.
    static
    const signed char
    translate_table[] =
    {
       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
      35,    36,    37,    38,    39,    40,    41,    42,    43,    44
    };
    // Last valid token kind.
    const int code_max = 299;

    if (t <= 0)
      return symbol_kind::S_YYEOF;
    else if (t <= code_max)
      return static_cast <symbol_kind_type> (translate_table[t]);
    else
      return symbol_kind::S_YYUNDEF;
  }

} // yy
#line 1825 "parser/parser.cc"

#line 215 "parser/parser.yy"


void yy::Parser::error( const location_type &l, const std::string & err_msg) {
    std::cerr << "Erreur : " << l << ", " << err_msg << std::endl;
}



==================================================
FICHIER : ./parser/parser.hh
==================================================
// A Bison parser, made by GNU Bison 3.8.2.

// Skeleton interface for Bison LALR(1) parsers in C++

// Copyright (C) 2002-2015, 2018-2021 Free Software Foundation, Inc.

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// As a special exception, you may create a larger work that contains
// part or all of the Bison parser skeleton and distribute that work
// under terms of your choice, so long as that work isn't itself a
// parser generator using the skeleton or a modified version thereof
// as a parser skeleton.  Alternatively, if you modify or redistribute
// the parser skeleton itself, you may (at your option) remove this
// special exception, which will cause the skeleton and the resulting
// Bison output files to be licensed under the GNU General Public
// License without this special exception.

// This special exception was added by the Free Software Foundation in
// version 2.2 of Bison.


/**
 ** \file parser/parser.hh
 ** Define the yy::parser class.
 */

// C++ LALR(1) parser skeleton written by Akim Demaille.

// DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,
// especially those whose name start with YY_ or yy_.  They are
// private implementation details that can be changed or removed.

#ifndef YY_YY_PARSER_PARSER_HH_INCLUDED
# define YY_YY_PARSER_PARSER_HH_INCLUDED
// "%code requires" blocks.
#line 9 "parser/parser.yy"

    #include "contexte.hh"
    #include "expression.hh"
    #include "expressionBinaire.hh"
    #include "expressionUnaire.hh"
    #include "constante.hh"
    #include "variable.hh"
    #include "instructions.hh"
    #include "capteurs.hh"
    #include "types.hh"
    #include "condition.hh"
    #include "conditionBinaire.hh"
    #include "testBinaire.hh"
    #include <vector>
    #include <string>

    class Scanner;
    class Driver;

#line 69 "parser/parser.hh"

# include <cassert>
# include <cstdlib> // std::abort
# include <iostream>
# include <stdexcept>
# include <string>
# include <vector>

#if defined __cplusplus
# define YY_CPLUSPLUS __cplusplus
#else
# define YY_CPLUSPLUS 199711L
#endif

// Support move semantics when possible.
#if 201103L <= YY_CPLUSPLUS
# define YY_MOVE           std::move
# define YY_MOVE_OR_COPY   move
# define YY_MOVE_REF(Type) Type&&
# define YY_RVREF(Type)    Type&&
# define YY_COPY(Type)     Type
#else
# define YY_MOVE
# define YY_MOVE_OR_COPY   copy
# define YY_MOVE_REF(Type) Type&
# define YY_RVREF(Type)    const Type&
# define YY_COPY(Type)     const Type&
#endif

// Support noexcept when possible.
#if 201103L <= YY_CPLUSPLUS
# define YY_NOEXCEPT noexcept
# define YY_NOTHROW
#else
# define YY_NOEXCEPT
# define YY_NOTHROW throw ()
#endif

// Support constexpr when possible.
#if 201703 <= YY_CPLUSPLUS
# define YY_CONSTEXPR constexpr
#else
# define YY_CONSTEXPR
#endif
# include "location.hh"
#include <typeinfo>
#ifndef YY_ASSERT
# include <cassert>
# define YY_ASSERT assert
#endif


#ifndef YY_ATTRIBUTE_PURE
# if defined __GNUC__ && 2 < __GNUC__ + (96 <= __GNUC_MINOR__)
#  define YY_ATTRIBUTE_PURE __attribute__ ((__pure__))
# else
#  define YY_ATTRIBUTE_PURE
# endif
#endif

#ifndef YY_ATTRIBUTE_UNUSED
# if defined __GNUC__ && 2 < __GNUC__ + (7 <= __GNUC_MINOR__)
#  define YY_ATTRIBUTE_UNUSED __attribute__ ((__unused__))
# else
#  define YY_ATTRIBUTE_UNUSED
# endif
#endif

/* Suppress unused-variable warnings by "using" E.  */
#if ! defined lint || defined __GNUC__
# define YY_USE(E) ((void) (E))
#else
# define YY_USE(E) /* empty */
#endif

/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
#if defined __GNUC__ && ! defined __ICC && 406 <= __GNUC__ * 100 + __GNUC_MINOR__
# if __GNUC__ * 100 + __GNUC_MINOR__ < 407
#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \
    _Pragma ("GCC diagnostic push")                                     \
    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")
# else
#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \
    _Pragma ("GCC diagnostic push")                                     \
    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")              \
    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
# endif
# define YY_IGNORE_MAYBE_UNINITIALIZED_END      \
    _Pragma ("GCC diagnostic pop")
#else
# define YY_INITIAL_VALUE(Value) Value
#endif
#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# define YY_IGNORE_MAYBE_UNINITIALIZED_END
#endif
#ifndef YY_INITIAL_VALUE
# define YY_INITIAL_VALUE(Value) /* Nothing. */
#endif

#if defined __cplusplus && defined __GNUC__ && ! defined __ICC && 6 <= __GNUC__
# define YY_IGNORE_USELESS_CAST_BEGIN                          \
    _Pragma ("GCC diagnostic push")                            \
    _Pragma ("GCC diagnostic ignored \"-Wuseless-cast\"")
# define YY_IGNORE_USELESS_CAST_END            \
    _Pragma ("GCC diagnostic pop")
#endif
#ifndef YY_IGNORE_USELESS_CAST_BEGIN
# define YY_IGNORE_USELESS_CAST_BEGIN
# define YY_IGNORE_USELESS_CAST_END
#endif

# ifndef YY_CAST
#  ifdef __cplusplus
#   define YY_CAST(Type, Val) static_cast<Type> (Val)
#   define YY_REINTERPRET_CAST(Type, Val) reinterpret_cast<Type> (Val)
#  else
#   define YY_CAST(Type, Val) ((Type) (Val))
#   define YY_REINTERPRET_CAST(Type, Val) ((Type) (Val))
#  endif
# endif
# ifndef YY_NULLPTR
#  if defined __cplusplus
#   if 201103L <= __cplusplus
#    define YY_NULLPTR nullptr
#   else
#    define YY_NULLPTR 0
#   endif
#  else
#   define YY_NULLPTR ((void*)0)
#  endif
# endif

/* Debug traces.  */
#ifndef YYDEBUG
# define YYDEBUG 0
#endif

namespace yy {
#line 209 "parser/parser.hh"




  /// A Bison parser.
  class  Parser 
  {
  public:
#ifdef YYSTYPE
# ifdef __GNUC__
#  pragma GCC message "bison: do not #define YYSTYPE in C++, use %define api.value.type"
# endif
    typedef YYSTYPE value_type;
#else
  /// A buffer to store and retrieve objects.
  ///
  /// Sort of a variant, but does not keep track of the nature
  /// of the stored data, since that knowledge is available
  /// via the current parser state.
  class value_type
  {
  public:
    /// Type of *this.
    typedef value_type self_type;

    /// Empty construction.
    value_type () YY_NOEXCEPT
      : yyraw_ ()
      , yytypeid_ (YY_NULLPTR)
    {}

    /// Construct and fill.
    template <typename T>
    value_type (YY_RVREF (T) t)
      : yytypeid_ (&typeid (T))
    {
      YY_ASSERT (sizeof (T) <= size);
      new (yyas_<T> ()) T (YY_MOVE (t));
    }

#if 201103L <= YY_CPLUSPLUS
    /// Non copyable.
    value_type (const self_type&) = delete;
    /// Non copyable.
    self_type& operator= (const self_type&) = delete;
#endif

    /// Destruction, allowed only if empty.
    ~value_type () YY_NOEXCEPT
    {
      YY_ASSERT (!yytypeid_);
    }

# if 201103L <= YY_CPLUSPLUS
    /// Instantiate a \a T in here from \a t.
    template <typename T, typename... U>
    T&
    emplace (U&&... u)
    {
      YY_ASSERT (!yytypeid_);
      YY_ASSERT (sizeof (T) <= size);
      yytypeid_ = & typeid (T);
      return *new (yyas_<T> ()) T (std::forward <U>(u)...);
    }
# else
    /// Instantiate an empty \a T in here.
    template <typename T>
    T&
    emplace ()
    {
      YY_ASSERT (!yytypeid_);
      YY_ASSERT (sizeof (T) <= size);
      yytypeid_ = & typeid (T);
      return *new (yyas_<T> ()) T ();
    }

    /// Instantiate a \a T in here from \a t.
    template <typename T>
    T&
    emplace (const T& t)
    {
      YY_ASSERT (!yytypeid_);
      YY_ASSERT (sizeof (T) <= size);
      yytypeid_ = & typeid (T);
      return *new (yyas_<T> ()) T (t);
    }
# endif

    /// Instantiate an empty \a T in here.
    /// Obsolete, use emplace.
    template <typename T>
    T&
    build ()
    {
      return emplace<T> ();
    }

    /// Instantiate a \a T in here from \a t.
    /// Obsolete, use emplace.
    template <typename T>
    T&
    build (const T& t)
    {
      return emplace<T> (t);
    }

    /// Accessor to a built \a T.
    template <typename T>
    T&
    as () YY_NOEXCEPT
    {
      YY_ASSERT (yytypeid_);
      YY_ASSERT (*yytypeid_ == typeid (T));
      YY_ASSERT (sizeof (T) <= size);
      return *yyas_<T> ();
    }

    /// Const accessor to a built \a T (for %printer).
    template <typename T>
    const T&
    as () const YY_NOEXCEPT
    {
      YY_ASSERT (yytypeid_);
      YY_ASSERT (*yytypeid_ == typeid (T));
      YY_ASSERT (sizeof (T) <= size);
      return *yyas_<T> ();
    }

    /// Swap the content with \a that, of same type.
    ///
    /// Both variants must be built beforehand, because swapping the actual
    /// data requires reading it (with as()), and this is not possible on
    /// unconstructed variants: it would require some dynamic testing, which
    /// should not be the variant's responsibility.
    /// Swapping between built and (possibly) non-built is done with
    /// self_type::move ().
    template <typename T>
    void
    swap (self_type& that) YY_NOEXCEPT
    {
      YY_ASSERT (yytypeid_);
      YY_ASSERT (*yytypeid_ == *that.yytypeid_);
      std::swap (as<T> (), that.as<T> ());
    }

    /// Move the content of \a that to this.
    ///
    /// Destroys \a that.
    template <typename T>
    void
    move (self_type& that)
    {
# if 201103L <= YY_CPLUSPLUS
      emplace<T> (std::move (that.as<T> ()));
# else
      emplace<T> ();
      swap<T> (that);
# endif
      that.destroy<T> ();
    }

# if 201103L <= YY_CPLUSPLUS
    /// Move the content of \a that to this.
    template <typename T>
    void
    move (self_type&& that)
    {
      emplace<T> (std::move (that.as<T> ()));
      that.destroy<T> ();
    }
#endif

    /// Copy the content of \a that to this.
    template <typename T>
    void
    copy (const self_type& that)
    {
      emplace<T> (that.as<T> ());
    }

    /// Destroy the stored \a T.
    template <typename T>
    void
    destroy ()
    {
      as<T> ().~T ();
      yytypeid_ = YY_NULLPTR;
    }

  private:
#if YY_CPLUSPLUS < 201103L
    /// Non copyable.
    value_type (const self_type&);
    /// Non copyable.
    self_type& operator= (const self_type&);
#endif

    /// Accessor to raw memory as \a T.
    template <typename T>
    T*
    yyas_ () YY_NOEXCEPT
    {
      void *yyp = yyraw_;
      return static_cast<T*> (yyp);
     }

    /// Const accessor to raw memory as \a T.
    template <typename T>
    const T*
    yyas_ () const YY_NOEXCEPT
    {
      const void *yyp = yyraw_;
      return static_cast<const T*> (yyp);
     }

    /// An auxiliary type to compute the largest semantic type.
    union union_type
    {
      // programme
      // liste_instructions
      char dummy1[sizeof (Bloc*)];

      // condition
      // condition_base
      char dummy2[sizeof (ConditionPtr)];

      // direction
      char dummy3[sizeof (Direction)];

      // expression
      char dummy4[sizeof (ExpressionPtr)];

      // instruction
      // commande
      // structure_controle
      char dummy5[sizeof (InstructionPtr)];

      // NUMBER
      char dummy6[sizeof (double)];

      // VAR_NAME
      char dummy7[sizeof (std::string)];

      // args_appel
      char dummy8[sizeof (std::vector<ExpressionPtr>)];

      // COLOR_HEX
      char dummy9[sizeof (std::vector<double>)];
    };

    /// The size of the largest semantic type.
    enum { size = sizeof (union_type) };

    /// A buffer to store semantic values.
    union
    {
      /// Strongest alignment constraints.
      long double yyalign_me_;
      /// A buffer large enough to store any of the semantic values.
      char yyraw_[size];
    };

    /// Whether the content is built: if defined, the name of the stored type.
    const std::type_info *yytypeid_;
  };

#endif
    /// Backward compatibility (Bison 3.8).
    typedef value_type semantic_type;

    /// Symbol locations.
    typedef location location_type;

    /// Syntax errors thrown from user actions.
    struct syntax_error : std::runtime_error
    {
      syntax_error (const location_type& l, const std::string& m)
        : std::runtime_error (m)
        , location (l)
      {}

      syntax_error (const syntax_error& s)
        : std::runtime_error (s.what ())
        , location (s.location)
      {}

      ~syntax_error () YY_NOEXCEPT YY_NOTHROW;

      location_type location;
    };

    /// Token kinds.
    struct token
    {
      enum token_kind_type
      {
        YYEMPTY = -2,
    YYEOF = 0,                     // "end of file"
    YYerror = 256,                 // error
    YYUNDEF = 257,                 // "invalid token"
    NL = 258,                      // NL
    END = 259,                     // END
    END_OF_FILE = 260,             // END_OF_FILE
    AVANCE = 261,                  // AVANCE
    RECULE = 262,                  // RECULE
    TOURNE = 263,                  // TOURNE
    SAUTE = 264,                   // SAUTE
    COULEUR = 265,                 // COULEUR
    TORTUES = 266,                 // TORTUES
    JARDIN = 267,                  // JARDIN
    FONCTION = 268,                // FONCTION
    SI = 269,                      // SI
    SINON = 270,                   // SINON
    TANT = 271,                    // TANT
    QUE = 272,                     // QUE
    REPETE = 273,                  // REPETE
    MUR = 274,                     // MUR
    VIDE = 275,                    // VIDE
    PAS = 276,                     // PAS
    DEVANT = 277,                  // DEVANT
    DERRIERE = 278,                // DERRIERE
    GAUCHE = 279,                  // GAUCHE
    DROITE = 280,                  // DROITE
    DP = 281,                      // DP
    AROBASE = 282,                 // AROBASE
    DOLLAR = 283,                  // DOLLAR
    PLUS = 284,                    // PLUS
    MOINS = 285,                   // MOINS
    MULT = 286,                    // MULT
    DIV = 287,                     // DIV
    LPAR = 288,                    // LPAR
    RPAR = 289,                    // RPAR
    EGAL = 290,                    // EGAL
    DIFFERENT = 291,               // DIFFERENT
    INF = 292,                     // INF
    SUP = 293,                     // SUP
    ET = 294,                      // ET
    OU = 295,                      // OU
    NUMBER = 296,                  // NUMBER
    VAR_NAME = 297,                // VAR_NAME
    COLOR_HEX = 298,               // COLOR_HEX
    NEG = 299                      // NEG
      };
      /// Backward compatibility alias (Bison 3.6).
      typedef token_kind_type yytokentype;
    };

    /// Token kind, as returned by yylex.
    typedef token::token_kind_type token_kind_type;

    /// Backward compatibility alias (Bison 3.6).
    typedef token_kind_type token_type;

    /// Symbol kinds.
    struct symbol_kind
    {
      enum symbol_kind_type
      {
        YYNTOKENS = 45, ///< Number of tokens.
        S_YYEMPTY = -2,
        S_YYEOF = 0,                             // "end of file"
        S_YYerror = 1,                           // error
        S_YYUNDEF = 2,                           // "invalid token"
        S_NL = 3,                                // NL
        S_END = 4,                               // END
        S_END_OF_FILE = 5,                       // END_OF_FILE
        S_AVANCE = 6,                            // AVANCE
        S_RECULE = 7,                            // RECULE
        S_TOURNE = 8,                            // TOURNE
        S_SAUTE = 9,                             // SAUTE
        S_COULEUR = 10,                          // COULEUR
        S_TORTUES = 11,                          // TORTUES
        S_JARDIN = 12,                           // JARDIN
        S_FONCTION = 13,                         // FONCTION
        S_SI = 14,                               // SI
        S_SINON = 15,                            // SINON
        S_TANT = 16,                             // TANT
        S_QUE = 17,                              // QUE
        S_REPETE = 18,                           // REPETE
        S_MUR = 19,                              // MUR
        S_VIDE = 20,                             // VIDE
        S_PAS = 21,                              // PAS
        S_DEVANT = 22,                           // DEVANT
        S_DERRIERE = 23,                         // DERRIERE
        S_GAUCHE = 24,                           // GAUCHE
        S_DROITE = 25,                           // DROITE
        S_DP = 26,                               // DP
        S_AROBASE = 27,                          // AROBASE
        S_DOLLAR = 28,                           // DOLLAR
        S_PLUS = 29,                             // PLUS
        S_MOINS = 30,                            // MOINS
        S_MULT = 31,                             // MULT
        S_DIV = 32,                              // DIV
        S_LPAR = 33,                             // LPAR
        S_RPAR = 34,                             // RPAR
        S_EGAL = 35,                             // EGAL
        S_DIFFERENT = 36,                        // DIFFERENT
        S_INF = 37,                              // INF
        S_SUP = 38,                              // SUP
        S_ET = 39,                               // ET
        S_OU = 40,                               // OU
        S_NUMBER = 41,                           // NUMBER
        S_VAR_NAME = 42,                         // VAR_NAME
        S_COLOR_HEX = 43,                        // COLOR_HEX
        S_NEG = 44,                              // NEG
        S_YYACCEPT = 45,                         // $accept
        S_root = 46,                             // root
        S_programme = 47,                        // programme
        S_definition_fonction = 48,              // definition_fonction
        S_liste_instructions = 49,               // liste_instructions
        S_instruction = 50,                      // instruction
        S_unite_opt = 51,                        // unite_opt
        S_unite_special = 52,                    // unite_special
        S_commande = 53,                         // commande
        S_structure_controle = 54,               // structure_controle
        S_args_appel = 55,                       // args_appel
        S_condition = 56,                        // condition
        S_condition_base = 57,                   // condition_base
        S_direction = 58,                        // direction
        S_expression = 59                        // expression
      };
    };

    /// (Internal) symbol kind.
    typedef symbol_kind::symbol_kind_type symbol_kind_type;

    /// The number of tokens.
    static const symbol_kind_type YYNTOKENS = symbol_kind::YYNTOKENS;

    /// A complete symbol.
    ///
    /// Expects its Base type to provide access to the symbol kind
    /// via kind ().
    ///
    /// Provide access to semantic value and location.
    template <typename Base>
    struct basic_symbol : Base
    {
      /// Alias to Base.
      typedef Base super_type;

      /// Default constructor.
      basic_symbol () YY_NOEXCEPT
        : value ()
        , location ()
      {}

#if 201103L <= YY_CPLUSPLUS
      /// Move constructor.
      basic_symbol (basic_symbol&& that)
        : Base (std::move (that))
        , value ()
        , location (std::move (that.location))
      {
        switch (this->kind ())
    {
      case symbol_kind::S_programme: // programme
      case symbol_kind::S_liste_instructions: // liste_instructions
        value.move< Bloc* > (std::move (that.value));
        break;

      case symbol_kind::S_condition: // condition
      case symbol_kind::S_condition_base: // condition_base
        value.move< ConditionPtr > (std::move (that.value));
        break;

      case symbol_kind::S_direction: // direction
        value.move< Direction > (std::move (that.value));
        break;

      case symbol_kind::S_expression: // expression
        value.move< ExpressionPtr > (std::move (that.value));
        break;

      case symbol_kind::S_instruction: // instruction
      case symbol_kind::S_commande: // commande
      case symbol_kind::S_structure_controle: // structure_controle
        value.move< InstructionPtr > (std::move (that.value));
        break;

      case symbol_kind::S_NUMBER: // NUMBER
        value.move< double > (std::move (that.value));
        break;

      case symbol_kind::S_VAR_NAME: // VAR_NAME
        value.move< std::string > (std::move (that.value));
        break;

      case symbol_kind::S_args_appel: // args_appel
        value.move< std::vector<ExpressionPtr> > (std::move (that.value));
        break;

      case symbol_kind::S_COLOR_HEX: // COLOR_HEX
        value.move< std::vector<double> > (std::move (that.value));
        break;

      default:
        break;
    }

      }
#endif

      /// Copy constructor.
      basic_symbol (const basic_symbol& that);

      /// Constructors for typed symbols.
#if 201103L <= YY_CPLUSPLUS
      basic_symbol (typename Base::kind_type t, location_type&& l)
        : Base (t)
        , location (std::move (l))
      {}
#else
      basic_symbol (typename Base::kind_type t, const location_type& l)
        : Base (t)
        , location (l)
      {}
#endif

#if 201103L <= YY_CPLUSPLUS
      basic_symbol (typename Base::kind_type t, Bloc*&& v, location_type&& l)
        : Base (t)
        , value (std::move (v))
        , location (std::move (l))
      {}
#else
      basic_symbol (typename Base::kind_type t, const Bloc*& v, const location_type& l)
        : Base (t)
        , value (v)
        , location (l)
      {}
#endif

#if 201103L <= YY_CPLUSPLUS
      basic_symbol (typename Base::kind_type t, ConditionPtr&& v, location_type&& l)
        : Base (t)
        , value (std::move (v))
        , location (std::move (l))
      {}
#else
      basic_symbol (typename Base::kind_type t, const ConditionPtr& v, const location_type& l)
        : Base (t)
        , value (v)
        , location (l)
      {}
#endif

#if 201103L <= YY_CPLUSPLUS
      basic_symbol (typename Base::kind_type t, Direction&& v, location_type&& l)
        : Base (t)
        , value (std::move (v))
        , location (std::move (l))
      {}
#else
      basic_symbol (typename Base::kind_type t, const Direction& v, const location_type& l)
        : Base (t)
        , value (v)
        , location (l)
      {}
#endif

#if 201103L <= YY_CPLUSPLUS
      basic_symbol (typename Base::kind_type t, ExpressionPtr&& v, location_type&& l)
        : Base (t)
        , value (std::move (v))
        , location (std::move (l))
      {}
#else
      basic_symbol (typename Base::kind_type t, const ExpressionPtr& v, const location_type& l)
        : Base (t)
        , value (v)
        , location (l)
      {}
#endif

#if 201103L <= YY_CPLUSPLUS
      basic_symbol (typename Base::kind_type t, InstructionPtr&& v, location_type&& l)
        : Base (t)
        , value (std::move (v))
        , location (std::move (l))
      {}
#else
      basic_symbol (typename Base::kind_type t, const InstructionPtr& v, const location_type& l)
        : Base (t)
        , value (v)
        , location (l)
      {}
#endif

#if 201103L <= YY_CPLUSPLUS
      basic_symbol (typename Base::kind_type t, double&& v, location_type&& l)
        : Base (t)
        , value (std::move (v))
        , location (std::move (l))
      {}
#else
      basic_symbol (typename Base::kind_type t, const double& v, const location_type& l)
        : Base (t)
        , value (v)
        , location (l)
      {}
#endif

#if 201103L <= YY_CPLUSPLUS
      basic_symbol (typename Base::kind_type t, std::string&& v, location_type&& l)
        : Base (t)
        , value (std::move (v))
        , location (std::move (l))
      {}
#else
      basic_symbol (typename Base::kind_type t, const std::string& v, const location_type& l)
        : Base (t)
        , value (v)
        , location (l)
      {}
#endif

#if 201103L <= YY_CPLUSPLUS
      basic_symbol (typename Base::kind_type t, std::vector<ExpressionPtr>&& v, location_type&& l)
        : Base (t)
        , value (std::move (v))
        , location (std::move (l))
      {}
#else
      basic_symbol (typename Base::kind_type t, const std::vector<ExpressionPtr>& v, const location_type& l)
        : Base (t)
        , value (v)
        , location (l)
      {}
#endif

#if 201103L <= YY_CPLUSPLUS
      basic_symbol (typename Base::kind_type t, std::vector<double>&& v, location_type&& l)
        : Base (t)
        , value (std::move (v))
        , location (std::move (l))
      {}
#else
      basic_symbol (typename Base::kind_type t, const std::vector<double>& v, const location_type& l)
        : Base (t)
        , value (v)
        , location (l)
      {}
#endif

      /// Destroy the symbol.
      ~basic_symbol ()
      {
        clear ();
      }



      /// Destroy contents, and record that is empty.
      void clear () YY_NOEXCEPT
      {
        // User destructor.
        symbol_kind_type yykind = this->kind ();
        basic_symbol<Base>& yysym = *this;
        (void) yysym;
        switch (yykind)
        {
       default:
          break;
        }

        // Value type destructor.
switch (yykind)
    {
      case symbol_kind::S_programme: // programme
      case symbol_kind::S_liste_instructions: // liste_instructions
        value.template destroy< Bloc* > ();
        break;

      case symbol_kind::S_condition: // condition
      case symbol_kind::S_condition_base: // condition_base
        value.template destroy< ConditionPtr > ();
        break;

      case symbol_kind::S_direction: // direction
        value.template destroy< Direction > ();
        break;

      case symbol_kind::S_expression: // expression
        value.template destroy< ExpressionPtr > ();
        break;

      case symbol_kind::S_instruction: // instruction
      case symbol_kind::S_commande: // commande
      case symbol_kind::S_structure_controle: // structure_controle
        value.template destroy< InstructionPtr > ();
        break;

      case symbol_kind::S_NUMBER: // NUMBER
        value.template destroy< double > ();
        break;

      case symbol_kind::S_VAR_NAME: // VAR_NAME
        value.template destroy< std::string > ();
        break;

      case symbol_kind::S_args_appel: // args_appel
        value.template destroy< std::vector<ExpressionPtr> > ();
        break;

      case symbol_kind::S_COLOR_HEX: // COLOR_HEX
        value.template destroy< std::vector<double> > ();
        break;

      default:
        break;
    }

        Base::clear ();
      }

#if YYDEBUG || 0
      /// The user-facing name of this symbol.
      const char *name () const YY_NOEXCEPT
      {
        return  Parser ::symbol_name (this->kind ());
      }
#endif // #if YYDEBUG || 0


      /// Backward compatibility (Bison 3.6).
      symbol_kind_type type_get () const YY_NOEXCEPT;

      /// Whether empty.
      bool empty () const YY_NOEXCEPT;

      /// Destructive move, \a s is emptied into this.
      void move (basic_symbol& s);

      /// The semantic value.
      value_type value;

      /// The location.
      location_type location;

    private:
#if YY_CPLUSPLUS < 201103L
      /// Assignment operator.
      basic_symbol& operator= (const basic_symbol& that);
#endif
    };

    /// Type access provider for token (enum) based symbols.
    struct by_kind
    {
      /// The symbol kind as needed by the constructor.
      typedef token_kind_type kind_type;

      /// Default constructor.
      by_kind () YY_NOEXCEPT;

#if 201103L <= YY_CPLUSPLUS
      /// Move constructor.
      by_kind (by_kind&& that) YY_NOEXCEPT;
#endif

      /// Copy constructor.
      by_kind (const by_kind& that) YY_NOEXCEPT;

      /// Constructor from (external) token numbers.
      by_kind (kind_type t) YY_NOEXCEPT;



      /// Record that this symbol is empty.
      void clear () YY_NOEXCEPT;

      /// Steal the symbol kind from \a that.
      void move (by_kind& that);

      /// The (internal) type number (corresponding to \a type).
      /// \a empty when empty.
      symbol_kind_type kind () const YY_NOEXCEPT;

      /// Backward compatibility (Bison 3.6).
      symbol_kind_type type_get () const YY_NOEXCEPT;

      /// The symbol kind.
      /// \a S_YYEMPTY when empty.
      symbol_kind_type kind_;
    };

    /// Backward compatibility for a private implementation detail (Bison 3.6).
    typedef by_kind by_type;

    /// "External" symbols: returned by the scanner.
    struct symbol_type : basic_symbol<by_kind>
    {
      /// Superclass.
      typedef basic_symbol<by_kind> super_type;

      /// Empty symbol.
      symbol_type () YY_NOEXCEPT {}

      /// Constructor for valueless symbols, and symbols from each type.
#if 201103L <= YY_CPLUSPLUS
      symbol_type (int tok, location_type l)
        : super_type (token_kind_type (tok), std::move (l))
#else
      symbol_type (int tok, const location_type& l)
        : super_type (token_kind_type (tok), l)
#endif
      {
#if !defined _MSC_VER || defined __clang__
        YY_ASSERT (tok == token::YYEOF
                   || (token::YYerror <= tok && tok <= token::OU)
                   || tok == token::NEG);
#endif
      }
#if 201103L <= YY_CPLUSPLUS
      symbol_type (int tok, double v, location_type l)
        : super_type (token_kind_type (tok), std::move (v), std::move (l))
#else
      symbol_type (int tok, const double& v, const location_type& l)
        : super_type (token_kind_type (tok), v, l)
#endif
      {
#if !defined _MSC_VER || defined __clang__
        YY_ASSERT (tok == token::NUMBER);
#endif
      }
#if 201103L <= YY_CPLUSPLUS
      symbol_type (int tok, std::string v, location_type l)
        : super_type (token_kind_type (tok), std::move (v), std::move (l))
#else
      symbol_type (int tok, const std::string& v, const location_type& l)
        : super_type (token_kind_type (tok), v, l)
#endif
      {
#if !defined _MSC_VER || defined __clang__
        YY_ASSERT (tok == token::VAR_NAME);
#endif
      }
#if 201103L <= YY_CPLUSPLUS
      symbol_type (int tok, std::vector<double> v, location_type l)
        : super_type (token_kind_type (tok), std::move (v), std::move (l))
#else
      symbol_type (int tok, const std::vector<double>& v, const location_type& l)
        : super_type (token_kind_type (tok), v, l)
#endif
      {
#if !defined _MSC_VER || defined __clang__
        YY_ASSERT (tok == token::COLOR_HEX);
#endif
      }
    };

    /// Build a parser object.
     Parser  (Scanner &scanner_yyarg, Driver &driver_yyarg);
    virtual ~ Parser  ();

#if 201103L <= YY_CPLUSPLUS
    /// Non copyable.
     Parser  (const  Parser &) = delete;
    /// Non copyable.
     Parser & operator= (const  Parser &) = delete;
#endif

    /// Parse.  An alias for parse ().
    /// \returns  0 iff parsing succeeded.
    int operator() ();

    /// Parse.
    /// \returns  0 iff parsing succeeded.
    virtual int parse ();

#if YYDEBUG
    /// The current debugging stream.
    std::ostream& debug_stream () const YY_ATTRIBUTE_PURE;
    /// Set the current debugging stream.
    void set_debug_stream (std::ostream &);

    /// Type for debugging levels.
    typedef int debug_level_type;
    /// The current debugging level.
    debug_level_type debug_level () const YY_ATTRIBUTE_PURE;
    /// Set the current debugging level.
    void set_debug_level (debug_level_type l);
#endif

    /// Report a syntax error.
    /// \param loc    where the syntax error is found.
    /// \param msg    a description of the syntax error.
    virtual void error (const location_type& loc, const std::string& msg);

    /// Report a syntax error.
    void error (const syntax_error& err);

#if YYDEBUG || 0
    /// The user-facing name of the symbol whose (internal) number is
    /// YYSYMBOL.  No bounds checking.
    static const char *symbol_name (symbol_kind_type yysymbol);
#endif // #if YYDEBUG || 0


    // Implementation of make_symbol for each token kind.
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_YYEOF (location_type l)
      {
        return symbol_type (token::YYEOF, std::move (l));
      }
#else
      static
      symbol_type
      make_YYEOF (const location_type& l)
      {
        return symbol_type (token::YYEOF, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_YYerror (location_type l)
      {
        return symbol_type (token::YYerror, std::move (l));
      }
#else
      static
      symbol_type
      make_YYerror (const location_type& l)
      {
        return symbol_type (token::YYerror, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_YYUNDEF (location_type l)
      {
        return symbol_type (token::YYUNDEF, std::move (l));
      }
#else
      static
      symbol_type
      make_YYUNDEF (const location_type& l)
      {
        return symbol_type (token::YYUNDEF, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_NL (location_type l)
      {
        return symbol_type (token::NL, std::move (l));
      }
#else
      static
      symbol_type
      make_NL (const location_type& l)
      {
        return symbol_type (token::NL, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_END (location_type l)
      {
        return symbol_type (token::END, std::move (l));
      }
#else
      static
      symbol_type
      make_END (const location_type& l)
      {
        return symbol_type (token::END, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_END_OF_FILE (location_type l)
      {
        return symbol_type (token::END_OF_FILE, std::move (l));
      }
#else
      static
      symbol_type
      make_END_OF_FILE (const location_type& l)
      {
        return symbol_type (token::END_OF_FILE, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_AVANCE (location_type l)
      {
        return symbol_type (token::AVANCE, std::move (l));
      }
#else
      static
      symbol_type
      make_AVANCE (const location_type& l)
      {
        return symbol_type (token::AVANCE, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_RECULE (location_type l)
      {
        return symbol_type (token::RECULE, std::move (l));
      }
#else
      static
      symbol_type
      make_RECULE (const location_type& l)
      {
        return symbol_type (token::RECULE, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_TOURNE (location_type l)
      {
        return symbol_type (token::TOURNE, std::move (l));
      }
#else
      static
      symbol_type
      make_TOURNE (const location_type& l)
      {
        return symbol_type (token::TOURNE, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_SAUTE (location_type l)
      {
        return symbol_type (token::SAUTE, std::move (l));
      }
#else
      static
      symbol_type
      make_SAUTE (const location_type& l)
      {
        return symbol_type (token::SAUTE, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_COULEUR (location_type l)
      {
        return symbol_type (token::COULEUR, std::move (l));
      }
#else
      static
      symbol_type
      make_COULEUR (const location_type& l)
      {
        return symbol_type (token::COULEUR, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_TORTUES (location_type l)
      {
        return symbol_type (token::TORTUES, std::move (l));
      }
#else
      static
      symbol_type
      make_TORTUES (const location_type& l)
      {
        return symbol_type (token::TORTUES, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_JARDIN (location_type l)
      {
        return symbol_type (token::JARDIN, std::move (l));
      }
#else
      static
      symbol_type
      make_JARDIN (const location_type& l)
      {
        return symbol_type (token::JARDIN, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_FONCTION (location_type l)
      {
        return symbol_type (token::FONCTION, std::move (l));
      }
#else
      static
      symbol_type
      make_FONCTION (const location_type& l)
      {
        return symbol_type (token::FONCTION, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_SI (location_type l)
      {
        return symbol_type (token::SI, std::move (l));
      }
#else
      static
      symbol_type
      make_SI (const location_type& l)
      {
        return symbol_type (token::SI, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_SINON (location_type l)
      {
        return symbol_type (token::SINON, std::move (l));
      }
#else
      static
      symbol_type
      make_SINON (const location_type& l)
      {
        return symbol_type (token::SINON, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_TANT (location_type l)
      {
        return symbol_type (token::TANT, std::move (l));
      }
#else
      static
      symbol_type
      make_TANT (const location_type& l)
      {
        return symbol_type (token::TANT, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_QUE (location_type l)
      {
        return symbol_type (token::QUE, std::move (l));
      }
#else
      static
      symbol_type
      make_QUE (const location_type& l)
      {
        return symbol_type (token::QUE, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_REPETE (location_type l)
      {
        return symbol_type (token::REPETE, std::move (l));
      }
#else
      static
      symbol_type
      make_REPETE (const location_type& l)
      {
        return symbol_type (token::REPETE, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_MUR (location_type l)
      {
        return symbol_type (token::MUR, std::move (l));
      }
#else
      static
      symbol_type
      make_MUR (const location_type& l)
      {
        return symbol_type (token::MUR, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_VIDE (location_type l)
      {
        return symbol_type (token::VIDE, std::move (l));
      }
#else
      static
      symbol_type
      make_VIDE (const location_type& l)
      {
        return symbol_type (token::VIDE, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_PAS (location_type l)
      {
        return symbol_type (token::PAS, std::move (l));
      }
#else
      static
      symbol_type
      make_PAS (const location_type& l)
      {
        return symbol_type (token::PAS, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_DEVANT (location_type l)
      {
        return symbol_type (token::DEVANT, std::move (l));
      }
#else
      static
      symbol_type
      make_DEVANT (const location_type& l)
      {
        return symbol_type (token::DEVANT, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_DERRIERE (location_type l)
      {
        return symbol_type (token::DERRIERE, std::move (l));
      }
#else
      static
      symbol_type
      make_DERRIERE (const location_type& l)
      {
        return symbol_type (token::DERRIERE, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_GAUCHE (location_type l)
      {
        return symbol_type (token::GAUCHE, std::move (l));
      }
#else
      static
      symbol_type
      make_GAUCHE (const location_type& l)
      {
        return symbol_type (token::GAUCHE, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_DROITE (location_type l)
      {
        return symbol_type (token::DROITE, std::move (l));
      }
#else
      static
      symbol_type
      make_DROITE (const location_type& l)
      {
        return symbol_type (token::DROITE, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_DP (location_type l)
      {
        return symbol_type (token::DP, std::move (l));
      }
#else
      static
      symbol_type
      make_DP (const location_type& l)
      {
        return symbol_type (token::DP, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_AROBASE (location_type l)
      {
        return symbol_type (token::AROBASE, std::move (l));
      }
#else
      static
      symbol_type
      make_AROBASE (const location_type& l)
      {
        return symbol_type (token::AROBASE, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_DOLLAR (location_type l)
      {
        return symbol_type (token::DOLLAR, std::move (l));
      }
#else
      static
      symbol_type
      make_DOLLAR (const location_type& l)
      {
        return symbol_type (token::DOLLAR, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_PLUS (location_type l)
      {
        return symbol_type (token::PLUS, std::move (l));
      }
#else
      static
      symbol_type
      make_PLUS (const location_type& l)
      {
        return symbol_type (token::PLUS, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_MOINS (location_type l)
      {
        return symbol_type (token::MOINS, std::move (l));
      }
#else
      static
      symbol_type
      make_MOINS (const location_type& l)
      {
        return symbol_type (token::MOINS, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_MULT (location_type l)
      {
        return symbol_type (token::MULT, std::move (l));
      }
#else
      static
      symbol_type
      make_MULT (const location_type& l)
      {
        return symbol_type (token::MULT, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_DIV (location_type l)
      {
        return symbol_type (token::DIV, std::move (l));
      }
#else
      static
      symbol_type
      make_DIV (const location_type& l)
      {
        return symbol_type (token::DIV, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_LPAR (location_type l)
      {
        return symbol_type (token::LPAR, std::move (l));
      }
#else
      static
      symbol_type
      make_LPAR (const location_type& l)
      {
        return symbol_type (token::LPAR, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_RPAR (location_type l)
      {
        return symbol_type (token::RPAR, std::move (l));
      }
#else
      static
      symbol_type
      make_RPAR (const location_type& l)
      {
        return symbol_type (token::RPAR, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_EGAL (location_type l)
      {
        return symbol_type (token::EGAL, std::move (l));
      }
#else
      static
      symbol_type
      make_EGAL (const location_type& l)
      {
        return symbol_type (token::EGAL, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_DIFFERENT (location_type l)
      {
        return symbol_type (token::DIFFERENT, std::move (l));
      }
#else
      static
      symbol_type
      make_DIFFERENT (const location_type& l)
      {
        return symbol_type (token::DIFFERENT, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_INF (location_type l)
      {
        return symbol_type (token::INF, std::move (l));
      }
#else
      static
      symbol_type
      make_INF (const location_type& l)
      {
        return symbol_type (token::INF, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_SUP (location_type l)
      {
        return symbol_type (token::SUP, std::move (l));
      }
#else
      static
      symbol_type
      make_SUP (const location_type& l)
      {
        return symbol_type (token::SUP, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_ET (location_type l)
      {
        return symbol_type (token::ET, std::move (l));
      }
#else
      static
      symbol_type
      make_ET (const location_type& l)
      {
        return symbol_type (token::ET, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_OU (location_type l)
      {
        return symbol_type (token::OU, std::move (l));
      }
#else
      static
      symbol_type
      make_OU (const location_type& l)
      {
        return symbol_type (token::OU, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_NUMBER (double v, location_type l)
      {
        return symbol_type (token::NUMBER, std::move (v), std::move (l));
      }
#else
      static
      symbol_type
      make_NUMBER (const double& v, const location_type& l)
      {
        return symbol_type (token::NUMBER, v, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_VAR_NAME (std::string v, location_type l)
      {
        return symbol_type (token::VAR_NAME, std::move (v), std::move (l));
      }
#else
      static
      symbol_type
      make_VAR_NAME (const std::string& v, const location_type& l)
      {
        return symbol_type (token::VAR_NAME, v, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_COLOR_HEX (std::vector<double> v, location_type l)
      {
        return symbol_type (token::COLOR_HEX, std::move (v), std::move (l));
      }
#else
      static
      symbol_type
      make_COLOR_HEX (const std::vector<double>& v, const location_type& l)
      {
        return symbol_type (token::COLOR_HEX, v, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_NEG (location_type l)
      {
        return symbol_type (token::NEG, std::move (l));
      }
#else
      static
      symbol_type
      make_NEG (const location_type& l)
      {
        return symbol_type (token::NEG, l);
      }
#endif


  private:
#if YY_CPLUSPLUS < 201103L
    /// Non copyable.
     Parser  (const  Parser &);
    /// Non copyable.
     Parser & operator= (const  Parser &);
#endif


    /// Stored state numbers (used for stacks).
    typedef unsigned char state_type;

    /// Compute post-reduction state.
    /// \param yystate   the current state
    /// \param yysym     the nonterminal to push on the stack
    static state_type yy_lr_goto_state_ (state_type yystate, int yysym);

    /// Whether the given \c yypact_ value indicates a defaulted state.
    /// \param yyvalue   the value to check
    static bool yy_pact_value_is_default_ (int yyvalue) YY_NOEXCEPT;

    /// Whether the given \c yytable_ value indicates a syntax error.
    /// \param yyvalue   the value to check
    static bool yy_table_value_is_error_ (int yyvalue) YY_NOEXCEPT;

    static const signed char yypact_ninf_;
    static const signed char yytable_ninf_;

    /// Convert a scanner token kind \a t to a symbol kind.
    /// In theory \a t should be a token_kind_type, but character literals
    /// are valid, yet not members of the token_kind_type enum.
    static symbol_kind_type yytranslate_ (int t) YY_NOEXCEPT;

#if YYDEBUG || 0
    /// For a symbol, its name in clear.
    static const char* const yytname_[];
#endif // #if YYDEBUG || 0


    // Tables.
    // YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
    // STATE-NUM.
    static const short yypact_[];

    // YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
    // Performed when YYTABLE does not specify something else to do.  Zero
    // means the default is an error.
    static const signed char yydefact_[];

    // YYPGOTO[NTERM-NUM].
    static const short yypgoto_[];

    // YYDEFGOTO[NTERM-NUM].
    static const signed char yydefgoto_[];

    // YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
    // positive, shift that token.  If negative, reduce the rule whose
    // number is the opposite.  If YYTABLE_NINF, syntax error.
    static const unsigned char yytable_[];

    static const short yycheck_[];

    // YYSTOS[STATE-NUM] -- The symbol kind of the accessing symbol of
    // state STATE-NUM.
    static const signed char yystos_[];

    // YYR1[RULE-NUM] -- Symbol kind of the left-hand side of rule RULE-NUM.
    static const signed char yyr1_[];

    // YYR2[RULE-NUM] -- Number of symbols on the right-hand side of rule RULE-NUM.
    static const signed char yyr2_[];


#if YYDEBUG
    // YYRLINE[YYN] -- Source line where rule number YYN was defined.
    static const unsigned char yyrline_[];
    /// Report on the debug stream that the rule \a r is going to be reduced.
    virtual void yy_reduce_print_ (int r) const;
    /// Print the state stack on the debug stream.
    virtual void yy_stack_print_ () const;

    /// Debugging level.
    int yydebug_;
    /// Debug stream.
    std::ostream* yycdebug_;

    /// \brief Display a symbol kind, value and location.
    /// \param yyo    The output stream.
    /// \param yysym  The symbol.
    template <typename Base>
    void yy_print_ (std::ostream& yyo, const basic_symbol<Base>& yysym) const;
#endif

    /// \brief Reclaim the memory associated to a symbol.
    /// \param yymsg     Why this token is reclaimed.
    ///                  If null, print nothing.
    /// \param yysym     The symbol.
    template <typename Base>
    void yy_destroy_ (const char* yymsg, basic_symbol<Base>& yysym) const;

  private:
    /// Type access provider for state based symbols.
    struct by_state
    {
      /// Default constructor.
      by_state () YY_NOEXCEPT;

      /// The symbol kind as needed by the constructor.
      typedef state_type kind_type;

      /// Constructor.
      by_state (kind_type s) YY_NOEXCEPT;

      /// Copy constructor.
      by_state (const by_state& that) YY_NOEXCEPT;

      /// Record that this symbol is empty.
      void clear () YY_NOEXCEPT;

      /// Steal the symbol kind from \a that.
      void move (by_state& that);

      /// The symbol kind (corresponding to \a state).
      /// \a symbol_kind::S_YYEMPTY when empty.
      symbol_kind_type kind () const YY_NOEXCEPT;

      /// The state number used to denote an empty symbol.
      /// We use the initial state, as it does not have a value.
      enum { empty_state = 0 };

      /// The state.
      /// \a empty when empty.
      state_type state;
    };

    /// "Internal" symbol: element of the stack.
    struct stack_symbol_type : basic_symbol<by_state>
    {
      /// Superclass.
      typedef basic_symbol<by_state> super_type;
      /// Construct an empty symbol.
      stack_symbol_type ();
      /// Move or copy construction.
      stack_symbol_type (YY_RVREF (stack_symbol_type) that);
      /// Steal the contents from \a sym to build this.
      stack_symbol_type (state_type s, YY_MOVE_REF (symbol_type) sym);
#if YY_CPLUSPLUS < 201103L
      /// Assignment, needed by push_back by some old implementations.
      /// Moves the contents of that.
      stack_symbol_type& operator= (stack_symbol_type& that);

      /// Assignment, needed by push_back by other implementations.
      /// Needed by some other old implementations.
      stack_symbol_type& operator= (const stack_symbol_type& that);
#endif
    };

    /// A stack with random access from its top.
    template <typename T, typename S = std::vector<T> >
    class stack
    {
    public:
      // Hide our reversed order.
      typedef typename S::iterator iterator;
      typedef typename S::const_iterator const_iterator;
      typedef typename S::size_type size_type;
      typedef typename std::ptrdiff_t index_type;

      stack (size_type n = 200) YY_NOEXCEPT
        : seq_ (n)
      {}

#if 201103L <= YY_CPLUSPLUS
      /// Non copyable.
      stack (const stack&) = delete;
      /// Non copyable.
      stack& operator= (const stack&) = delete;
#endif

      /// Random access.
      ///
      /// Index 0 returns the topmost element.
      const T&
      operator[] (index_type i) const
      {
        return seq_[size_type (size () - 1 - i)];
      }

      /// Random access.
      ///
      /// Index 0 returns the topmost element.
      T&
      operator[] (index_type i)
      {
        return seq_[size_type (size () - 1 - i)];
      }

      /// Steal the contents of \a t.
      ///
      /// Close to move-semantics.
      void
      push (YY_MOVE_REF (T) t)
      {
        seq_.push_back (T ());
        operator[] (0).move (t);
      }

      /// Pop elements from the stack.
      void
      pop (std::ptrdiff_t n = 1) YY_NOEXCEPT
      {
        for (; 0 < n; --n)
          seq_.pop_back ();
      }

      /// Pop all elements from the stack.
      void
      clear () YY_NOEXCEPT
      {
        seq_.clear ();
      }

      /// Number of elements on the stack.
      index_type
      size () const YY_NOEXCEPT
      {
        return index_type (seq_.size ());
      }

      /// Iterator on top of the stack (going downwards).
      const_iterator
      begin () const YY_NOEXCEPT
      {
        return seq_.begin ();
      }

      /// Bottom of the stack.
      const_iterator
      end () const YY_NOEXCEPT
      {
        return seq_.end ();
      }

      /// Present a slice of the top of a stack.
      class slice
      {
      public:
        slice (const stack& stack, index_type range) YY_NOEXCEPT
          : stack_ (stack)
          , range_ (range)
        {}

        const T&
        operator[] (index_type i) const
        {
          return stack_[range_ - i];
        }

      private:
        const stack& stack_;
        index_type range_;
      };

    private:
#if YY_CPLUSPLUS < 201103L
      /// Non copyable.
      stack (const stack&);
      /// Non copyable.
      stack& operator= (const stack&);
#endif
      /// The wrapped container.
      S seq_;
    };


    /// Stack type.
    typedef stack<stack_symbol_type> stack_type;

    /// The stack.
    stack_type yystack_;

    /// Push a new state on the stack.
    /// \param m    a debug message to display
    ///             if null, no trace is output.
    /// \param sym  the symbol
    /// \warning the contents of \a s.value is stolen.
    void yypush_ (const char* m, YY_MOVE_REF (stack_symbol_type) sym);

    /// Push a new look ahead token on the state on the stack.
    /// \param m    a debug message to display
    ///             if null, no trace is output.
    /// \param s    the state
    /// \param sym  the symbol (for its value and location).
    /// \warning the contents of \a sym.value is stolen.
    void yypush_ (const char* m, state_type s, YY_MOVE_REF (symbol_type) sym);

    /// Pop \a n symbols from the stack.
    void yypop_ (int n = 1) YY_NOEXCEPT;

    /// Constants.
    enum
    {
      yylast_ = 301,     ///< Last index in yytable_.
      yynnts_ = 15,  ///< Number of nonterminal symbols.
      yyfinal_ = 3 ///< Termination state number.
    };


    // User arguments.
    Scanner &scanner;
    Driver &driver;

  };


} // yy
#line 2104 "parser/parser.hh"




#endif // !YY_YY_PARSER_PARSER_HH_INCLUDED



==================================================
FICHIER : ./parser/parser.yy
==================================================
%skeleton "lalr1.cc"
%require "3.0"
%defines
%define api.parser.class { Parser }
%define api.value.type variant
%define parse.assert
%locations

%code requires{
    #include "contexte.hh"
    #include "expression.hh"
    #include "expressionBinaire.hh"
    #include "expressionUnaire.hh"
    #include "constante.hh"
    #include "variable.hh"
    #include "instructions.hh"
    #include "capteurs.hh"
    #include "types.hh"
    #include "condition.hh"
    #include "conditionBinaire.hh"
    #include "testBinaire.hh"
    #include <vector>
    #include <string>

    class Scanner;
    class Driver;
}

%parse-param { Scanner &scanner }
%parse-param { Driver &driver }

%code{
    #include <iostream>
    #include "scanner.hh"
    #include "driver.hh"

    #undef  yylex
    #define yylex scanner.yylex
}

%token NL END END_OF_FILE
%token AVANCE RECULE TOURNE SAUTE COULEUR TORTUES JARDIN FONCTION
%token SI SINON TANT QUE REPETE
%token MUR VIDE PAS DEVANT DERRIERE GAUCHE DROITE
%token DP AROBASE DOLLAR
%token PLUS MOINS MULT DIV LPAR RPAR EGAL DIFFERENT INF SUP ET OU
%token <double> NUMBER
%token <std::string> VAR_NAME
%token <std::vector<double>> COLOR_HEX

%type <ExpressionPtr> expression
%type <ConditionPtr> condition condition_base
%type <InstructionPtr> instruction commande structure_controle
%type <Bloc*> liste_instructions programme
%type <std::vector<ExpressionPtr>> args_appel
%type <Direction> direction

%left OU
%left ET
%left EGAL DIFFERENT INF SUP
%left PLUS MOINS
%left MULT DIV
%precedence NEG

%%

root:
    programme {
        driver.executer($1);
        delete $1;
        YYACCEPT;
    }
    ;

programme:
      programme instruction NL { $$ = $1; $$->ajouter($2); }
    | programme instruction END NL { $$ = $1; $$->ajouter($2); }
    | programme instruction END_OF_FILE { $$ = $1; $$->ajouter($2); }
    | programme NL { $$ = $1; }
    | programme definition_fonction NL { $$ = $1; }
    | /* vide */ { $$ = new Bloc(); }
    ;

definition_fonction:
    FONCTION VAR_NAME DP NL liste_instructions END FONCTION {
        driver.definirFonction($2, $5);
    }
    ;

liste_instructions:
      liste_instructions instruction NL { $$ = $1; $$->ajouter($2); }
    | instruction NL { $$ = new Bloc(); $$->ajouter($1); }
    | liste_instructions NL { $$ = $1; }
    | NL { $$ = new Bloc(); }
    ;

instruction:
      commande { $$ = $1; }
    | structure_controle { $$ = $1; }
    ;

unite_opt:
      /* vide */
    | PAS
    | VAR_NAME
    ;

unite_special:
      /* vide */
    | PAS
    ;

commande:
      AVANCE expression unite_opt { $$ = std::make_shared<CommandeMouvement>($2, TypeMouvement::AVANCE); }
    | RECULE expression unite_opt { $$ = std::make_shared<CommandeMouvement>($2, TypeMouvement::RECULE); }
    | SAUTE expression unite_opt  { $$ = std::make_shared<CommandeMouvement>($2, TypeMouvement::SAUTE); }
    | TOURNE expression unite_opt { $$ = std::make_shared<CommandeMouvement>($2, TypeMouvement::TOURNE); }

    | AVANCE unite_special { $$ = std::make_shared<CommandeMouvement>(std::make_shared<Constante>(1.0), TypeMouvement::AVANCE); }
    | RECULE unite_special { $$ = std::make_shared<CommandeMouvement>(std::make_shared<Constante>(1.0), TypeMouvement::RECULE); }
    | SAUTE unite_special  { $$ = std::make_shared<CommandeMouvement>(std::make_shared<Constante>(1.0), TypeMouvement::SAUTE); }
    | TOURNE unite_special { $$ = std::make_shared<CommandeMouvement>(std::make_shared<Constante>(90.0), TypeMouvement::TOURNE); }

    | TOURNE direction  {
        double angle = ($2 == Direction::GAUCHE) ? -90.0 : 90.0;
        $$ = std::make_shared<CommandeMouvement>(std::make_shared<Constante>(angle), TypeMouvement::TOURNE);
      }
    | TOURNE direction expression unite_opt {
         ExpressionPtr angle = $3;
         if ($2 == Direction::GAUCHE) {
             angle = std::make_shared<ExpressionUnaire>($3, OperateurUnaire::neg);
         }
         $$ = std::make_shared<CommandeMouvement>(angle, TypeMouvement::TOURNE);
    }

    | TORTUES expression { $$ = std::make_shared<Bloc>(); }
    | COULEUR COLOR_HEX { $$ = std::make_shared<CommandeCouleur>($2[0], $2[1], $2[2]); }
    | COULEUR VAR_NAME { $$ = std::make_shared<CommandeCouleur>(255, 0, 0); }

    | JARDIN VAR_NAME   { driver.nouveauJardin($2); $$ = std::make_shared<Bloc>(); }
    | VAR_NAME args_appel { $$ = std::make_shared<AppelFonction>($1, $2); }
    | commande AROBASE expression {
        Bloc* b = new Bloc();
        b->ajouter(std::make_shared<CommandeSelectionTortue>($3));
        b->ajouter($1);
        $$ = std::shared_ptr<Instruction>(b);
    }
    ;

structure_controle:
      SI condition DP NL liste_instructions END SI {
          $$ = std::make_shared<ControleSi>($2, std::shared_ptr<Instruction>($5));
      }
    | SI condition DP NL liste_instructions SINON DP NL liste_instructions END SI {
          $$ = std::make_shared<ControleSi>($2, std::shared_ptr<Instruction>($5), std::shared_ptr<Instruction>($9));
      }
    | TANT QUE condition DP NL liste_instructions END TANT QUE {
          $$ = std::make_shared<ControleTantQue>($3, std::shared_ptr<Instruction>($6));
      }
    | REPETE expression DP NL liste_instructions END REPETE {
          $$ = std::make_shared<ControleRepete>($2, std::shared_ptr<Instruction>($5));
      }
    ;

args_appel:
      args_appel expression { $$ = $1; $$.push_back($2); }
    | /* vide */ { }
    ;

condition:
      condition_base { $$ = $1; }
    | PAS condition_base { $$ = $2; }
    | condition ET condition { $$ = std::make_shared<ConditionBinaire>($1, $3, OperateurBinaireBool::et); }
    | condition OU condition { $$ = std::make_shared<ConditionBinaire>($1, $3, OperateurBinaireBool::ou); }
    | LPAR condition RPAR { $$ = $2; }
    ;

/* C'EST ICI QU'ON AJOUTE LES RÈGLES POUR @expression */
condition_base:
      MUR direction { $$ = std::make_shared<ConditionCapteur>(TypeCapteur::MUR, $2); }
    | VIDE direction { $$ = std::make_shared<ConditionCapteur>(TypeCapteur::VIDE, $2); }
    | PAS MUR direction { $$ = std::make_shared<ConditionCapteur>(TypeCapteur::VIDE, $3); }
    | PAS VIDE direction { $$ = std::make_shared<ConditionCapteur>(TypeCapteur::MUR, $3); }

    | MUR direction AROBASE expression { $$ = std::make_shared<ConditionCapteur>(TypeCapteur::MUR, $2, $4); }
    | VIDE direction AROBASE expression { $$ = std::make_shared<ConditionCapteur>(TypeCapteur::VIDE, $2, $4); }
    | PAS MUR direction AROBASE expression { $$ = std::make_shared<ConditionCapteur>(TypeCapteur::VIDE, $3, $5); }
    | PAS VIDE direction AROBASE expression { $$ = std::make_shared<ConditionCapteur>(TypeCapteur::MUR, $3, $5); }

    | expression EGAL expression { $$ = std::make_shared<TestBinaire>($1, $3, OperateurBool::egal); }
    | expression DIFFERENT expression { $$ = std::make_shared<TestBinaire>($1, $3, OperateurBool::different); }
    | expression INF expression { $$ = std::make_shared<TestBinaire>($1, $3, OperateurBool::pluspetit); }
    | expression SUP expression { $$ = std::make_shared<TestBinaire>($1, $3, OperateurBool::plusgrand); }
    ;

direction:
      DEVANT { $$ = Direction::DEVANT; }
    | DERRIERE { $$ = Direction::DERRIERE; }
    | GAUCHE { $$ = Direction::GAUCHE; }
    | DROITE { $$ = Direction::DROITE; }
    ;

expression:
      NUMBER { $$ = std::make_shared<Constante>($1); }
    | VAR_NAME { $$ = std::make_shared<Variable>($1); }
    | DOLLAR NUMBER { $$ = std::make_shared<Variable>("$" + std::to_string((int)$2)); }
    | expression PLUS expression { $$ = std::make_shared<ExpressionBinaire>($1, $3, OperateurBinaire::plus); }
    | expression MOINS expression { $$ = std::make_shared<ExpressionBinaire>($1, $3, OperateurBinaire::moins); }
    | expression MULT expression { $$ = std::make_shared<ExpressionBinaire>($1, $3, OperateurBinaire::multiplie); }
    | expression DIV expression { $$ = std::make_shared<ExpressionBinaire>($1, $3, OperateurBinaire::divise); }
    | MOINS expression %prec NEG { $$ = std::make_shared<ExpressionUnaire>($2, OperateurUnaire::neg); }
    | LPAR expression RPAR { $$ = $2; }
    ;

%%

void yy::Parser::error( const location_type &l, const std::string & err_msg) {
    std::cerr << "Erreur : " << l << ", " << err_msg << std::endl;
}



==================================================
FICHIER : ./parser/position.hh
==================================================
// A Bison parser, made by GNU Bison 3.8.2.

// Starting with Bison 3.2, this file is useless: the structure it
// used to define is now defined in "location.hh".
//
// To get rid of this file:
// 1. add '%require "3.2"' (or newer) to your grammar file
// 2. remove references to this file from your build system
// 3. if you used to include it, include "location.hh" instead.

#include "location.hh"



==================================================
FICHIER : ./parser/scanner.cc
==================================================
#line 2 "parser/scanner.cc"

#line 4 "parser/scanner.cc"

#define  YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 6
#define YY_FLEX_SUBMINOR_VERSION 4
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

    /* The c++ scanner is a mess. The FlexLexer.h header file relies on the
     * following macro. This is required in order to pass the c++-multiple-scanners
     * test in the regression suite. We get reports that it breaks inheritance.
     * We will address this in a future release of flex, or omit the C++ scanner
     * altogether.
     */
    #define yyFlexLexer yyFlexLexer

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types. 
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t; 
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN               (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN              (-32767-1)
#endif
#ifndef INT32_MIN
#define INT32_MIN              (-2147483647-1)
#endif
#ifndef INT8_MAX
#define INT8_MAX               (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX              (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX              (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX              (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX             (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX             (4294967295U)
#endif

#ifndef SIZE_MAX
#define SIZE_MAX               (~(size_t)0)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

/* begin standard C++ headers. */
#include <iostream>
#include <errno.h>
#include <cstdlib>
#include <cstdio>
#include <cstring>
/* end standard C++ headers. */

/* TODO: this is always defined, so inline it */
#define yyconst const

#if defined(__GNUC__) && __GNUC__ >= 3
#define yynoreturn __attribute__((__noreturn__))
#else
#define yynoreturn
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an
 *   integer in range [0..255] for use as an array index.
 */
#define YY_SC_TO_UI(c) ((YY_CHAR) (c))

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN (yy_start) = 1 + 2 *
/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START (((yy_start) - 1) / 2)
#define YYSTATE YY_START
/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( yyin  )
#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define YY_BUF_SIZE 32768
#else
#define YY_BUF_SIZE 16384
#endif /* __ia64__ */
#endif

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

extern int yyleng;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2
    
    #define YY_LESS_LINENO(n)
    #define YY_LINENO_REWIND_TO(ptr)
    
/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		*yy_cp = (yy_hold_char); \
		YY_RESTORE_YY_MORE_OFFSET \
		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )
#define unput(c) yyunput( c, (yytext_ptr)  )

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
	{

	std::streambuf* yy_input_file;

	char *yy_ch_buf;		/* input buffer */
	char *yy_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	int yy_buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	int yy_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yy_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yy_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yy_at_bol;

    int yy_bs_lineno; /**< The line count. */
    int yy_bs_column; /**< The column count. */

	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yy_fill_buffer;

	int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via yyrestart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */
#define YY_BUFFER_EOF_PENDING 2

	};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
                          : NULL)
/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]

void *yyalloc ( yy_size_t  );
void *yyrealloc ( void *, yy_size_t  );
void yyfree ( void *  );

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){ \
        yyensure_buffer_stack (); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer( yyin, YY_BUF_SIZE ); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
	}
#define yy_set_bol(at_bol) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){\
        yyensure_buffer_stack (); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer( yyin, YY_BUF_SIZE ); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
	}
#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* Begin user sect3 */
#define YY_SKIP_YYWRAP
typedef flex_uint8_t YY_CHAR;

#define yytext_ptr yytext
#define YY_INTERACTIVE

#include <FlexLexer.h>

int yyFlexLexer::yywrap() { return 1; }
int yyFlexLexer::yylex()
	{
	LexerError( "yyFlexLexer::yylex invoked but %option yyclass used" );
	return 0;
	}

#define YY_DECL int Scanner::yylex()

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
	(yytext_ptr) = yy_bp; \
	yyleng = (int) (yy_cp - yy_bp); \
	(yy_hold_char) = *yy_cp; \
	*yy_cp = '\0'; \
	(yy_c_buf_p) = yy_cp;
#define YY_NUM_RULES 50
#define YY_END_OF_BUFFER 51
/* This struct is not used in this scanner,
   but its presence is necessary. */
struct yy_trans_info
	{
	flex_int32_t yy_verify;
	flex_int32_t yy_nxt;
	};
static const flex_int16_t yy_accept[156] =
    {   0,
        0,    0,   51,   49,    4,    5,   49,   49,   33,   30,
        3,   49,   38,   39,   36,   34,   35,   48,   37,   31,
       28,   42,   49,   43,   29,   48,   48,   48,   48,   48,
       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
       41,    0,   46,   33,   33,    3,    0,   47,    1,   48,
        2,   48,   31,   40,   48,   48,   48,   48,   44,   48,
       48,   48,   48,   48,   45,   48,   48,   48,   48,   14,
       48,   48,   48,   33,    1,    1,    2,    2,   31,   48,
       48,   48,   48,   48,    6,   48,   48,   48,   20,   23,
       17,   48,   48,   48,   48,   48,   48,   48,   48,   33,

       48,   48,   48,   48,   48,   48,   48,   48,    0,   48,
       48,   48,   48,   16,   48,   48,   21,   33,   48,   48,
       48,   48,   48,   48,   48,   48,    0,   48,   48,   10,
       15,   48,   48,   33,    7,   48,   48,   24,   27,   48,
       26,   13,   22,    8,   18,   48,    9,   32,   11,   48,
       48,   12,   25,   19,    0
    } ;

static const YY_CHAR yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    4,    5,    6,    7,    8,    1,    9,   10,
       11,   12,   13,    1,   14,   15,   16,   17,   17,   17,
       17,   17,   17,   17,   17,   17,   17,   18,    1,   19,
       20,   21,    1,   22,   23,   23,   23,   23,   23,   23,
       24,   24,   24,   24,   24,   24,   24,   24,   24,   24,
       24,   24,   24,   24,   24,   24,   24,   24,   24,   24,
        1,    1,    1,    1,   24,    1,   25,   23,   26,   27,

       28,   29,   30,   31,   32,   33,   24,   34,   35,   36,
       37,   38,   39,   40,   41,   42,   43,   44,   24,   24,
       24,   24,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static const YY_CHAR yy_meta[45] =
    {   0,
        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    3,    3,    3,    3,    1,    1,    1,
        1,    1,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3
    } ;

static const flex_int16_t yy_base[165] =
    {   0,
        0,    0,  277,  278,  278,  278,  256,  270,   28,  278,
        0,  265,  278,  278,  278,  278,  259,    0,  256,   31,
      278,  278,  251,  278,  278,  226,  232,   19,  226,   26,
      242,  241,  222,  221,  238,  219,  233,   35,   24,  228,
      278,  254,  278,    0,   51,    0,  249,  278,   80,    0,
      102,  240,   35,  278,  231,  212,   22,  217,    0,  217,
      216,  208,  210,  209,    0,  207,  219,   45,  203,  209,
      207,   29,  213,  108,    0,  137,    0,  159,  220,  198,
      197,  188,  200,  190,    0,  189,  187,  185,    0,  209,
        0,  167,  181,  160,  163,  157,  156,  157,  168,  165,

      163,  159,  154,  149,  142,  141,  145,  143,   68,  140,
      131,  134,  118,    0,  110,  116,    0,  178,  123,   97,
      104,   88,  101,   96,   99,   90,   91,   90,   89,    0,
        0,   88,   77,  191,    0,   57,   56,    0,    0,   57,
        0,    0,  278,    0,    0,   34,    0,    0,    0,   45,
       29,    0,    0,    0,  278,  220,  223,  226,  229,   61,
      232,  235,  238,  241
    } ;

static const flex_int16_t yy_def[165] =
    {   0,
      155,    1,  155,  155,  155,  155,  155,  156,  157,  155,
      158,  159,  155,  155,  155,  155,  160,  160,  160,  160,
      155,  155,  155,  155,  155,  160,  160,  160,  160,  160,
      160,  160,  160,  160,  160,  160,  160,  160,  160,  160,
      155,  156,  155,  157,  157,  158,  159,  155,  161,  160,
      162,  160,  160,  155,  160,  160,  160,  160,  160,  160,
      160,  160,  160,  160,  160,  160,  160,  160,  160,  160,
      160,  160,  160,  157,  163,  161,  164,  162,  160,  160,
      160,  160,  160,  160,  160,  160,  160,  160,  160,  160,
      160,  160,  160,  160,  160,  160,  160,  160,  160,  157,

      160,  160,  160,  160,  160,  160,  160,  160,  155,  160,
      160,  160,  160,  160,  160,  160,  160,  157,  160,  160,
      160,  160,  160,  160,  160,  160,  155,  160,  160,  160,
      160,  160,  160,  157,  160,  160,  160,  160,  160,  160,
      160,  160,  155,  160,  160,  160,  160,  157,  160,  160,
      160,  160,  160,  160,    0,  155,  155,  155,  155,  155,
      155,  155,  155,  155
    } ;

static const flex_int16_t yy_nxt[323] =
    {   0,
        4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
       14,   15,   16,   17,   18,   19,   20,   21,   22,   23,
       24,   25,   18,   18,   26,   27,   28,   29,   30,   31,
       18,   18,   32,   18,   33,   18,   34,   35,   36,   37,
       38,   39,   18,   40,   45,   52,   57,   53,   71,   52,
       45,   53,   45,   45,   45,   45,   45,   60,   58,   69,
       72,   82,   61,   50,  154,   83,   70,   74,   97,  109,
       92,   98,  153,   74,  152,   74,   74,   74,   74,   74,
       75,   75,   93,   75,   75,   75,   75,   75,   75,   75,
       75,   75,   75,  151,  127,  150,  149,   75,   75,   75,

       75,   75,   77,   77,  147,   77,   77,   77,   77,   77,
       77,   77,   77,   77,   77,  146,  145,  144,  143,   77,
       77,   77,   77,   77,  100,  142,  141,  140,  139,  138,
      100,  137,  100,  100,  100,  100,  100,   75,   75,  136,
       75,   75,   75,   75,   75,   75,   75,   75,   75,   75,
      135,  133,  132,  131,   75,   75,   75,   75,   75,   77,
       77,  130,   77,   77,   77,   77,   77,   77,   77,   77,
       77,   77,  129,  128,  126,  125,   77,   77,   77,   77,
       77,  118,  124,  123,  122,  121,  120,  118,  119,  118,
      118,  118,  118,  118,  134,  117,  116,  115,  114,  113,

      134,  112,  134,  134,  134,  134,  134,  148,  111,  110,
      109,  108,  107,  148,  106,  148,  148,  148,  148,  148,
       42,  105,   42,   44,  104,   44,   46,  103,   46,   47,
      102,   47,   76,  101,   76,   78,   79,   78,   75,   99,
       75,   77,   96,   77,   95,   94,   91,   90,   89,   88,
       87,   86,   85,   84,   81,   80,   79,   48,   43,   73,
       68,   67,   66,   65,   64,   63,   62,   59,   56,   55,
       54,   51,   49,   48,   43,   41,  155,    3,  155,  155,
      155,  155,  155,  155,  155,  155,  155,  155,  155,  155,
      155,  155,  155,  155,  155,  155,  155,  155,  155,  155,

      155,  155,  155,  155,  155,  155,  155,  155,  155,  155,
      155,  155,  155,  155,  155,  155,  155,  155,  155,  155,
      155,  155
    } ;

static const flex_int16_t yy_chk[323] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    9,   20,   28,   20,   39,   53,
        9,   53,    9,    9,    9,    9,    9,   30,   28,   38,
       39,   57,   30,  160,  151,   57,   38,   45,   72,  109,
       68,   72,  150,   45,  146,   45,   45,   45,   45,   45,
       49,   49,   68,   49,   49,   49,   49,   49,   49,   49,
       49,   49,   49,  140,  109,  137,  136,   49,   49,   49,

       49,   49,   51,   51,  133,   51,   51,   51,   51,   51,
       51,   51,   51,   51,   51,  132,  129,  128,  127,   51,
       51,   51,   51,   51,   74,  126,  125,  124,  123,  122,
       74,  121,   74,   74,   74,   74,   74,   76,   76,  120,
       76,   76,   76,   76,   76,   76,   76,   76,   76,   76,
      119,  116,  115,  113,   76,   76,   76,   76,   76,   78,
       78,  112,   78,   78,   78,   78,   78,   78,   78,   78,
       78,   78,  111,  110,  108,  107,   78,   78,   78,   78,
       78,  100,  106,  105,  104,  103,  102,  100,  101,  100,
      100,  100,  100,  100,  118,   99,   98,   97,   96,   95,

      118,   94,  118,  118,  118,  118,  118,  134,   93,   92,
       90,   88,   87,  134,   86,  134,  134,  134,  134,  134,
      156,   84,  156,  157,   83,  157,  158,   82,  158,  159,
       81,  159,  161,   80,  161,  162,   79,  162,  163,   73,
      163,  164,   71,  164,   70,   69,   67,   66,   64,   63,
       62,   61,   60,   58,   56,   55,   52,   47,   42,   40,
       37,   36,   35,   34,   33,   32,   31,   29,   27,   26,
       23,   19,   17,   12,    8,    7,    3,  155,  155,  155,
      155,  155,  155,  155,  155,  155,  155,  155,  155,  155,
      155,  155,  155,  155,  155,  155,  155,  155,  155,  155,

      155,  155,  155,  155,  155,  155,  155,  155,  155,  155,
      155,  155,  155,  155,  155,  155,  155,  155,  155,  155,
      155,  155
    } ;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
#line 1 "parser/scanner.ll"
#line 2 "parser/scanner.ll"
#include "scanner.hh"
#include <cstdlib>
#define YY_NO_UNISTD_H
using token = yy::Parser::token;
#undef  YY_DECL
#define YY_DECL int Scanner::yylex( yy::Parser::semantic_type * const lval, yy::Parser::location_type *loc )
#define YY_USER_ACTION loc->step(); loc->columns(yyleng);
#line 536 "parser/scanner.cc"
#line 537 "parser/scanner.cc"

#define INITIAL 0

#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#include <unistd.h>
#endif

#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void *
#endif

#ifndef yytext_ptr
static void yy_flex_strncpy ( char *, const char *, int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen ( const char * );
#endif

#ifndef YY_NO_INPUT

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
#define ECHO LexerOutput( yytext, yyleng )
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
\
	if ( (int)(result = LexerInput( (char *) buf, max_size )) < 0 ) \
		YY_FATAL_ERROR( "input in flex scanner failed" );

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) LexerError( msg )
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1
#define YY_DECL int yyFlexLexer::yylex()
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
	yy_state_type yy_current_state;
	char *yy_cp, *yy_bp;
	int yy_act;
    
	if ( !(yy_init) )
		{
		(yy_init) = 1;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! (yy_start) )
			(yy_start) = 1;	/* first start state */

		if ( ! yyin )
			yyin.rdbuf(std::cin.rdbuf());

		if ( ! yyout )
			yyout.rdbuf(std::cout.rdbuf());

		if ( ! YY_CURRENT_BUFFER ) {
			yyensure_buffer_stack ();
			YY_CURRENT_BUFFER_LVALUE =
				yy_create_buffer( yyin, YY_BUF_SIZE );
		}

		yy_load_buffer_state(  );
		}

	{
#line 15 "parser/scanner.ll"


#line 18 "parser/scanner.ll"
    yylval = lval;


#line 676 "parser/scanner.cc"

	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
		{
		yy_cp = (yy_c_buf_p);

		/* Support of yytext. */
		*yy_cp = (yy_hold_char);

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = (yy_start);
yy_match:
		do
			{
			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
			if ( yy_accept[yy_current_state] )
				{
				(yy_last_accepting_state) = yy_current_state;
				(yy_last_accepting_cpos) = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 156 )
					yy_c = yy_meta[yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 278 );

yy_find_action:
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ /* have to back up */
			yy_cp = (yy_last_accepting_cpos);
			yy_current_state = (yy_last_accepting_state);
			yy_act = yy_accept[yy_current_state];
			}

		YY_DO_BEFORE_ACTION;

do_action:	/* This label is used only to access EOF actions. */

		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = (yy_hold_char);
			yy_cp = (yy_last_accepting_cpos);
			yy_current_state = (yy_last_accepting_state);
			goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 21 "parser/scanner.ll"
{ }
	YY_BREAK
case 2:
YY_RULE_SETUP
#line 22 "parser/scanner.ll"
{ }
	YY_BREAK
case 3:
YY_RULE_SETUP
#line 23 "parser/scanner.ll"
{ }
	YY_BREAK
case 4:
YY_RULE_SETUP
#line 24 "parser/scanner.ll"
{ }
	YY_BREAK
case 5:
/* rule 5 can match eol */
YY_RULE_SETUP
#line 25 "parser/scanner.ll"
{ loc->lines(); return token::NL; }
	YY_BREAK
case 6:
YY_RULE_SETUP
#line 26 "parser/scanner.ll"
{ return token::END; }
	YY_BREAK
case 7:
YY_RULE_SETUP
#line 28 "parser/scanner.ll"
{ return token::AVANCE; }
	YY_BREAK
case 8:
YY_RULE_SETUP
#line 29 "parser/scanner.ll"
{ return token::RECULE; }
	YY_BREAK
case 9:
YY_RULE_SETUP
#line 30 "parser/scanner.ll"
{ return token::TOURNE; }
	YY_BREAK
case 10:
YY_RULE_SETUP
#line 31 "parser/scanner.ll"
{ return token::SAUTE; }
	YY_BREAK
case 11:
YY_RULE_SETUP
#line 32 "parser/scanner.ll"
{ return token::COULEUR; }
	YY_BREAK
case 12:
YY_RULE_SETUP
#line 33 "parser/scanner.ll"
{ return token::TORTUES; }
	YY_BREAK
case 13:
YY_RULE_SETUP
#line 34 "parser/scanner.ll"
{ return token::JARDIN; }
	YY_BREAK
case 14:
YY_RULE_SETUP
#line 36 "parser/scanner.ll"
{ return token::SI; }
	YY_BREAK
case 15:
YY_RULE_SETUP
#line 37 "parser/scanner.ll"
{ return token::SINON; }
	YY_BREAK
case 16:
YY_RULE_SETUP
#line 38 "parser/scanner.ll"
{ return token::TANT; }
	YY_BREAK
case 17:
YY_RULE_SETUP
#line 39 "parser/scanner.ll"
{ return token::QUE; }
	YY_BREAK
case 18:
YY_RULE_SETUP
#line 40 "parser/scanner.ll"
{ return token::REPETE; }
	YY_BREAK
case 19:
YY_RULE_SETUP
#line 41 "parser/scanner.ll"
{ return token::FONCTION; }
	YY_BREAK
case 20:
YY_RULE_SETUP
#line 43 "parser/scanner.ll"
{ return token::MUR; }
	YY_BREAK
case 21:
YY_RULE_SETUP
#line 44 "parser/scanner.ll"
{ return token::VIDE; }
	YY_BREAK
case 22:
YY_RULE_SETUP
#line 46 "parser/scanner.ll"
{ return token::PAS; }
	YY_BREAK
case 23:
YY_RULE_SETUP
#line 47 "parser/scanner.ll"
{ return token::PAS; }
	YY_BREAK
case 24:
YY_RULE_SETUP
#line 49 "parser/scanner.ll"
{ return token::DEVANT; }
	YY_BREAK
case 25:
YY_RULE_SETUP
#line 50 "parser/scanner.ll"
{ return token::DERRIERE; }
	YY_BREAK
case 26:
YY_RULE_SETUP
#line 51 "parser/scanner.ll"
{ return token::GAUCHE; }
	YY_BREAK
case 27:
YY_RULE_SETUP
#line 52 "parser/scanner.ll"
{ return token::DROITE; }
	YY_BREAK
case 28:
YY_RULE_SETUP
#line 54 "parser/scanner.ll"
{ return token::DP; }
	YY_BREAK
case 29:
YY_RULE_SETUP
#line 55 "parser/scanner.ll"
{ return token::AROBASE; }
	YY_BREAK
case 30:
YY_RULE_SETUP
#line 56 "parser/scanner.ll"
{ return token::DOLLAR; }
	YY_BREAK
case 31:
YY_RULE_SETUP
#line 58 "parser/scanner.ll"
{ yylval->build<double>(std::atof(YYText())); return token::NUMBER; }
	YY_BREAK
case 32:
YY_RULE_SETUP
#line 60 "parser/scanner.ll"
{
    std::string s = YYText();
    unsigned int r, g, b;
    std::sscanf(s.c_str(), "#%02x%02x%02x", &r, &g, &b);
    yylval->build<std::vector<double>>({(double)r, (double)g, (double)b});
    return token::COLOR_HEX;
}
	YY_BREAK
case 33:
YY_RULE_SETUP
#line 67 "parser/scanner.ll"
{ }
	YY_BREAK
case 34:
YY_RULE_SETUP
#line 69 "parser/scanner.ll"
{ return token::PLUS; }
	YY_BREAK
case 35:
YY_RULE_SETUP
#line 70 "parser/scanner.ll"
{ return token::MOINS; }
	YY_BREAK
case 36:
YY_RULE_SETUP
#line 71 "parser/scanner.ll"
{ return token::MULT; }
	YY_BREAK
case 37:
YY_RULE_SETUP
#line 72 "parser/scanner.ll"
{ return token::DIV; }
	YY_BREAK
case 38:
YY_RULE_SETUP
#line 73 "parser/scanner.ll"
{ return token::LPAR; }
	YY_BREAK
case 39:
YY_RULE_SETUP
#line 74 "parser/scanner.ll"
{ return token::RPAR; }
	YY_BREAK
case 40:
YY_RULE_SETUP
#line 75 "parser/scanner.ll"
{ return token::EGAL; }
	YY_BREAK
case 41:
YY_RULE_SETUP
#line 76 "parser/scanner.ll"
{ return token::DIFFERENT; }
	YY_BREAK
case 42:
YY_RULE_SETUP
#line 77 "parser/scanner.ll"
{ return token::INF; }
	YY_BREAK
case 43:
YY_RULE_SETUP
#line 78 "parser/scanner.ll"
{ return token::SUP; }
	YY_BREAK
case 44:
YY_RULE_SETUP
#line 79 "parser/scanner.ll"
{ return token::ET; }
	YY_BREAK
case 45:
YY_RULE_SETUP
#line 80 "parser/scanner.ll"
{ return token::OU; }
	YY_BREAK
case 46:
YY_RULE_SETUP
#line 82 "parser/scanner.ll"
{
    std::string s(YYText());
    yylval->build<std::string>(s.substr(1, s.length()-2));
    return token::VAR_NAME;
}
	YY_BREAK
case 47:
YY_RULE_SETUP
#line 87 "parser/scanner.ll"
{
    std::string s(YYText());
    yylval->build<std::string>(s.substr(1, s.length()-2));
    return token::VAR_NAME;
}
	YY_BREAK
case 48:
YY_RULE_SETUP
#line 93 "parser/scanner.ll"
{
    yylval->build<std::string>(YYText());
    return token::VAR_NAME;
}
	YY_BREAK
case YY_STATE_EOF(INITIAL):
#line 98 "parser/scanner.ll"
{ return token::END_OF_FILE; }
	YY_BREAK
case 49:
YY_RULE_SETUP
#line 99 "parser/scanner.ll"
{ }
	YY_BREAK
case 50:
YY_RULE_SETUP
#line 100 "parser/scanner.ll"
ECHO;
	YY_BREAK
#line 1005 "parser/scanner.cc"

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = (yy_hold_char);
		YY_RESTORE_YY_MORE_OFFSET

		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * yylex().  If so, then we have to assure
			 * consistency between YY_CURRENT_BUFFER and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin.rdbuf();
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state(  );

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state );

			yy_bp = (yytext_ptr) + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++(yy_c_buf_p);
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = (yy_c_buf_p);
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer(  ) )
			{
			case EOB_ACT_END_OF_FILE:
				{
				(yy_did_buffer_switch_on_eof) = 0;

				if ( yywrap(  ) )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! (yy_did_buffer_switch_on_eof) )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				(yy_c_buf_p) =
					(yytext_ptr) + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state(  );

				yy_cp = (yy_c_buf_p);
				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				(yy_c_buf_p) =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];

				yy_current_state = yy_get_previous_state(  );

				yy_cp = (yy_c_buf_p);
				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			"fatal flex scanner internal error--no action found" );
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of user's declarations */
} /* end of yylex */

/* The contents of this function are C++ specific, so the () macro is not used.
 * This constructor simply maintains backward compatibility.
 * DEPRECATED
 */
yyFlexLexer::yyFlexLexer( std::istream* arg_yyin, std::ostream* arg_yyout ):
	yyin(arg_yyin ? arg_yyin->rdbuf() : std::cin.rdbuf()),
	yyout(arg_yyout ? arg_yyout->rdbuf() : std::cout.rdbuf())
{
	ctor_common();
}

/* The contents of this function are C++ specific, so the () macro is not used.
 */
yyFlexLexer::yyFlexLexer( std::istream& arg_yyin, std::ostream& arg_yyout ):
	yyin(arg_yyin.rdbuf()),
	yyout(arg_yyout.rdbuf())
{
	ctor_common();
}

/* The contents of this function are C++ specific, so the () macro is not used.
 */
void yyFlexLexer::ctor_common()
{
	yy_c_buf_p = 0;
	yy_init = 0;
	yy_start = 0;
	yy_flex_debug = 0;
	yylineno = 1;	// this will only get updated if %option yylineno

	yy_did_buffer_switch_on_eof = 0;

	yy_looking_for_trail_begin = 0;
	yy_more_flag = 0;
	yy_more_len = 0;
	yy_more_offset = yy_prev_more_offset = 0;

	yy_start_stack_ptr = yy_start_stack_depth = 0;
	yy_start_stack = NULL;

	yy_buffer_stack = NULL;
	yy_buffer_stack_top = 0;
	yy_buffer_stack_max = 0;

	yy_state_buf = 0;

}

/* The contents of this function are C++ specific, so the () macro is not used.
 */
yyFlexLexer::~yyFlexLexer()
{
	delete [] yy_state_buf;
	yyfree( yy_start_stack  );
	yy_delete_buffer( YY_CURRENT_BUFFER );
	yyfree( yy_buffer_stack  );
}

/* The contents of this function are C++ specific, so the () macro is not used.
 */
void yyFlexLexer::switch_streams( std::istream& new_in, std::ostream& new_out )
{
	// was if( new_in )
	yy_delete_buffer( YY_CURRENT_BUFFER );
	yy_switch_to_buffer( yy_create_buffer( new_in, YY_BUF_SIZE  ) );

	// was if( new_out )
	yyout.rdbuf(new_out.rdbuf());
}

/* The contents of this function are C++ specific, so the () macro is not used.
 */
void yyFlexLexer::switch_streams( std::istream* new_in, std::ostream* new_out )
{
	if( ! new_in ) {
		new_in = &yyin;
	}

	if ( ! new_out ) {
		new_out = &yyout;
	}

	switch_streams(*new_in, *new_out);
}

#ifdef YY_INTERACTIVE
int yyFlexLexer::LexerInput( char* buf, int /* max_size */ )
#else
int yyFlexLexer::LexerInput( char* buf, int max_size )
#endif
{
	if ( yyin.eof() || yyin.fail() )
		return 0;

#ifdef YY_INTERACTIVE
	yyin.get( buf[0] );

	if ( yyin.eof() )
		return 0;

	if ( yyin.bad() )
		return -1;

	return 1;

#else
	(void) yyin.read( buf, max_size );

	if ( yyin.bad() )
		return -1;
	else
		return yyin.gcount();
#endif
}

void yyFlexLexer::LexerOutput( const char* buf, int size )
{
	(void) yyout.write( buf, size );
}

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
int yyFlexLexer::yy_get_next_buffer()
{
    	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
	char *source = (yytext_ptr);
	int number_to_move, i;
	int ret_val;

	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
		YY_FATAL_ERROR(
		"fatal flex scanner internal error--end of buffer missed" );

	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
			{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;

	else
		{
			int num_to_read =
			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

			int yy_c_buf_p_offset =
				(int) ((yy_c_buf_p) - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					yyrealloc( (void *) b->yy_ch_buf,
							 (yy_size_t) (b->yy_buf_size + 2)  );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = NULL;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
				"fatal error - scanner input buffer overflow" );

			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
						number_to_move - 1;

			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
			(yy_n_chars), num_to_read );

		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	if ( (yy_n_chars) == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			yyrestart( yyin  );
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
		/* Extend the array by 50%, plus the number we really need. */
		int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );
		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
		/* "- 2" to take care of EOB's */
		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
	}

	(yy_n_chars) += number_to_move;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;

	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

	return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    yy_state_type yyFlexLexer::yy_get_previous_state()
{
	yy_state_type yy_current_state;
	char *yy_cp;
    
	yy_current_state = (yy_start);

	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
		{
		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			(yy_last_accepting_state) = yy_current_state;
			(yy_last_accepting_cpos) = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 156 )
				yy_c = yy_meta[yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
		}

	return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
    yy_state_type yyFlexLexer::yy_try_NUL_trans( yy_state_type yy_current_state )
{
	int yy_is_jam;
    	char *yy_cp = (yy_c_buf_p);

	YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		(yy_last_accepting_state) = yy_current_state;
		(yy_last_accepting_cpos) = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 156 )
			yy_c = yy_meta[yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
	yy_is_jam = (yy_current_state == 155);

		return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT
    void yyFlexLexer::yyunput( int c, char* yy_bp)
{
	char *yy_cp;
    
    yy_cp = (yy_c_buf_p);

	/* undo effects of setting up yytext */
	*yy_cp = (yy_hold_char);

	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
		{ /* need to shift things up to make room */
		/* +2 for EOB chars. */
		int number_to_move = (yy_n_chars) + 2;
		char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
		char *source =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			*--dest = *--source;

		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
			(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
			YY_FATAL_ERROR( "flex scanner push-back overflow" );
		}

	*--yy_cp = (char) c;

	(yytext_ptr) = yy_bp;
	(yy_hold_char) = *yy_cp;
	(yy_c_buf_p) = yy_cp;
}
#endif

    int yyFlexLexer::yyinput()
{
	int c;
    
	*(yy_c_buf_p) = (yy_hold_char);

	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
		{
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
			/* This was really a NUL. */
			*(yy_c_buf_p) = '\0';

		else
			{ /* need more input */
			int offset = (int) ((yy_c_buf_p) - (yytext_ptr));
			++(yy_c_buf_p);

			switch ( yy_get_next_buffer(  ) )
				{
				case EOB_ACT_LAST_MATCH:
					/* This happens because yy_g_n_b()
					 * sees that we've accumulated a
					 * token and flags that we need to
					 * try matching the token before
					 * proceeding.  But for input(),
					 * there's no matching to consider.
					 * So convert the EOB_ACT_LAST_MATCH
					 * to EOB_ACT_END_OF_FILE.
					 */

					/* Reset buffer status. */
					yyrestart( yyin );

					/*FALLTHROUGH*/

				case EOB_ACT_END_OF_FILE:
					{
					if ( yywrap(  ) )
						return 0;

					if ( ! (yy_did_buffer_switch_on_eof) )
						YY_NEW_FILE;
#ifdef __cplusplus
					return yyinput();
#else
					return input();
#endif
					}

				case EOB_ACT_CONTINUE_SCAN:
					(yy_c_buf_p) = (yytext_ptr) + offset;
					break;
				}
			}
		}

	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
	*(yy_c_buf_p) = '\0';	/* preserve yytext */
	(yy_hold_char) = *++(yy_c_buf_p);

	return c;
}

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 * 
 * @note This function does not reset the start condition to @c INITIAL .
 */
    void yyFlexLexer::yyrestart( std::istream& input_file )
{
    
	if ( ! YY_CURRENT_BUFFER ){
        yyensure_buffer_stack ();
		YY_CURRENT_BUFFER_LVALUE =
            yy_create_buffer( yyin, YY_BUF_SIZE );
	}

	yy_init_buffer( YY_CURRENT_BUFFER, input_file );
	yy_load_buffer_state(  );
}

/** Delegate to the new version that takes an istream reference.
 * @param input_file A readable stream.
 * 
 * @note This function does not reset the start condition to @c INITIAL .
 */
void yyFlexLexer::yyrestart( std::istream* input_file )
{
	if( ! input_file ) {
		input_file = &yyin;
	}
	yyrestart( *input_file );
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 * 
 */
    void yyFlexLexer::yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
{
    
	/* TODO. We should be able to replace this entire function body
	 * with
	 *		yypop_buffer_state();
	 *		yypush_buffer_state(new_buffer);
     */
	yyensure_buffer_stack ();
	if ( YY_CURRENT_BUFFER == new_buffer )
		return;

	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*(yy_c_buf_p) = (yy_hold_char);
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	YY_CURRENT_BUFFER_LVALUE = new_buffer;
	yy_load_buffer_state(  );

	/* We don't actually know whether we did this switch during
	 * EOF (yywrap()) processing, but the only time this flag
	 * is looked at is after yywrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	(yy_did_buffer_switch_on_eof) = 1;
}

    void yyFlexLexer::yy_load_buffer_state()
{
    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
	yyin.rdbuf(YY_CURRENT_BUFFER_LVALUE->yy_input_file);
	(yy_hold_char) = *(yy_c_buf_p);
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 * 
 * @return the allocated buffer state.
 */
    YY_BUFFER_STATE yyFlexLexer::yy_create_buffer( std::istream& file, int size )
{
	YY_BUFFER_STATE b;
    
	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_buf_size = size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2)  );
	if ( ! b->yy_ch_buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_is_our_buffer = 1;

	yy_init_buffer( b, file );

	return b;
}

/** Delegate creation of buffers to the new version that takes an istream reference.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 * 
 * @return the allocated buffer state.
 */
	YY_BUFFER_STATE yyFlexLexer::yy_create_buffer( std::istream* file, int size )
{
	return yy_create_buffer( *file, size );
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 * 
 */
    void yyFlexLexer::yy_delete_buffer( YY_BUFFER_STATE b )
{
    
	if ( ! b )
		return;

	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;

	if ( b->yy_is_our_buffer )
		yyfree( (void *) b->yy_ch_buf  );

	yyfree( (void *) b  );
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
    void yyFlexLexer::yy_init_buffer( YY_BUFFER_STATE b, std::istream& file )

{
	int oerrno = errno;
    
	yy_flush_buffer( b );

	b->yy_input_file = file.rdbuf();
	b->yy_fill_buffer = 1;

    /* If b is the current buffer, then yy_init_buffer was _probably_
     * called from yyrestart() or through yy_get_next_buffer.
     * In that case, we don't want to reset the lineno or column.
     */
    if (b != YY_CURRENT_BUFFER){
        b->yy_bs_lineno = 1;
        b->yy_bs_column = 0;
    }

	b->yy_is_interactive = 0;
	errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 * 
 */
    void yyFlexLexer::yy_flush_buffer( YY_BUFFER_STATE b )
{
    	if ( ! b )
		return;

	b->yy_n_chars = 0;

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

	b->yy_buf_pos = &b->yy_ch_buf[0];

	b->yy_at_bol = 1;
	b->yy_buffer_status = YY_BUFFER_NEW;

	if ( b == YY_CURRENT_BUFFER )
		yy_load_buffer_state(  );
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *  
 */
void yyFlexLexer::yypush_buffer_state (YY_BUFFER_STATE new_buffer)
{
    	if (new_buffer == NULL)
		return;

	yyensure_buffer_stack();

	/* This block is copied from yy_switch_to_buffer. */
	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*(yy_c_buf_p) = (yy_hold_char);
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	/* Only push if top exists. Otherwise, replace top. */
	if (YY_CURRENT_BUFFER)
		(yy_buffer_stack_top)++;
	YY_CURRENT_BUFFER_LVALUE = new_buffer;

	/* copied from yy_switch_to_buffer. */
	yy_load_buffer_state(  );
	(yy_did_buffer_switch_on_eof) = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *  
 */
void yyFlexLexer::yypop_buffer_state (void)
{
    	if (!YY_CURRENT_BUFFER)
		return;

	yy_delete_buffer(YY_CURRENT_BUFFER );
	YY_CURRENT_BUFFER_LVALUE = NULL;
	if ((yy_buffer_stack_top) > 0)
		--(yy_buffer_stack_top);

	if (YY_CURRENT_BUFFER) {
		yy_load_buffer_state(  );
		(yy_did_buffer_switch_on_eof) = 1;
	}
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
void yyFlexLexer::yyensure_buffer_stack(void)
{
	yy_size_t num_to_alloc;
    
	if (!(yy_buffer_stack)) {

		/* First allocation is just for 2 elements, since we don't know if this
		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
		 * immediate realloc on the next call.
         */
      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
								(num_to_alloc * sizeof(struct yy_buffer_state*)
								);
		if ( ! (yy_buffer_stack) )
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );

		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));

		(yy_buffer_stack_max) = num_to_alloc;
		(yy_buffer_stack_top) = 0;
		return;
	}

	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){

		/* Increase the buffer to prepare for a possible push. */
		yy_size_t grow_size = 8 /* arbitrary grow size */;

		num_to_alloc = (yy_buffer_stack_max) + grow_size;
		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
								((yy_buffer_stack),
								num_to_alloc * sizeof(struct yy_buffer_state*)
								);
		if ( ! (yy_buffer_stack) )
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );

		/* zero only the new slots.*/
		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
		(yy_buffer_stack_max) = num_to_alloc;
	}
}

    void yyFlexLexer::yy_push_state( int _new_state )
{
    	if ( (yy_start_stack_ptr) >= (yy_start_stack_depth) )
		{
		yy_size_t new_size;

		(yy_start_stack_depth) += YY_START_STACK_INCR;
		new_size = (yy_size_t) (yy_start_stack_depth) * sizeof( int );

		if ( ! (yy_start_stack) )
			(yy_start_stack) = (int *) yyalloc( new_size  );

		else
			(yy_start_stack) = (int *) yyrealloc(
					(void *) (yy_start_stack), new_size  );

		if ( ! (yy_start_stack) )
			YY_FATAL_ERROR( "out of memory expanding start-condition stack" );
		}

	(yy_start_stack)[(yy_start_stack_ptr)++] = YY_START;

	BEGIN(_new_state);
}

    void yyFlexLexer::yy_pop_state()
{
    	if ( --(yy_start_stack_ptr) < 0 )
		YY_FATAL_ERROR( "start-condition stack underflow" );

	BEGIN((yy_start_stack)[(yy_start_stack_ptr)]);
}

    int yyFlexLexer::yy_top_state()
{
    	return (yy_start_stack)[(yy_start_stack_ptr) - 1];
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

void yyFlexLexer::LexerError( const char* msg )
{
    	std::cerr << msg << std::endl;
	exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		yytext[yyleng] = (yy_hold_char); \
		(yy_c_buf_p) = yytext + yyless_macro_arg; \
		(yy_hold_char) = *(yy_c_buf_p); \
		*(yy_c_buf_p) = '\0'; \
		yyleng = yyless_macro_arg; \
		} \
	while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy (char* s1, const char * s2, int n )
{
		
	int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (const char * s )
{
	int n;
	for ( n = 0; s[n]; ++n )
		;

	return n;
}
#endif

void *yyalloc (yy_size_t  size )
{
			return malloc(size);
}

void *yyrealloc  (void * ptr, yy_size_t  size )
{
		
	/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */
	return realloc(ptr, size);
}

void yyfree (void * ptr )
{
			free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
}

#define YYTABLES_NAME "yytables"

#line 100 "parser/scanner.ll"





==================================================
FICHIER : ./parser/scanner.hh
==================================================
#ifndef SCANNER_HH
#define SCANNER_HH

#if ! defined(yyFlexLexerOnce)
#include <FlexLexer.h>
#endif

#include "parser.hh" // Lien direct avec le parser généré
#include "location.hh"

class Scanner : public yyFlexLexer {
public:
    Scanner(std::istream & in, std::ostream & out) : yyFlexLexer(in, out) {}
    virtual ~Scanner() {}
    using FlexLexer::yylex;
    virtual int yylex(yy::Parser::semantic_type * const lval, yy::Parser::location_type *location);
private:
    yy::Parser::semantic_type *yylval = nullptr;
};
#endif



==================================================
FICHIER : ./parser/scanner.ll
==================================================
%{
#include "scanner.hh"
#include <cstdlib>
#define YY_NO_UNISTD_H
using token = yy::Parser::token;
#undef  YY_DECL
#define YY_DECL int Scanner::yylex( yy::Parser::semantic_type * const lval, yy::Parser::location_type *loc )
#define YY_USER_ACTION loc->step(); loc->columns(yyleng);
%}

%option c++
%option yyclass="Scanner"
%option noyywrap

%%
%{
    yylval = lval;
%}

"--".* { }
"//".* { }
"%".* { }
[ \t]       { }
"\n"        { loc->lines(); return token::NL; }
"fin"       { return token::END; }

"avance"    { return token::AVANCE; }
"recule"    { return token::RECULE; }
"tourne"    { return token::TOURNE; }
"saute"     { return token::SAUTE; }
"couleur"   { return token::COULEUR; }
"tortues"   { return token::TORTUES; }
"jardin"    { return token::JARDIN; }

"si"        { return token::SI; }
"sinon"     { return token::SINON; }
"tant"      { return token::TANT; }
"que"       { return token::QUE; }
"repete"    { return token::REPETE; }
"fonction"  { return token::FONCTION; }

"mur"       { return token::MUR; }
"vide"      { return token::VIDE; }

"pas"[ \t]+"de" { return token::PAS; }
"pas"           { return token::PAS; }

"devant"    { return token::DEVANT; }
"derriere"  { return token::DERRIERE; }
"gauche"    { return token::GAUCHE; }
"droite"    { return token::DROITE; }

":"         { return token::DP; }
"@"         { return token::AROBASE; }
"$"         { return token::DOLLAR; }

[0-9]+(\.[0-9]+)?      { yylval->build<double>(std::atof(YYText())); return token::NUMBER; }

"#"[0-9a-fA-F]{6}      {
    std::string s = YYText();
    unsigned int r, g, b;
    std::sscanf(s.c_str(), "#%02x%02x%02x", &r, &g, &b);
    yylval->build<std::vector<double>>({(double)r, (double)g, (double)b});
    return token::COLOR_HEX;
}
"#".* { }

"+" { return token::PLUS; }
"-" { return token::MOINS; }
"*" { return token::MULT; }
"/" { return token::DIV; }
"(" { return token::LPAR; }
")" { return token::RPAR; }
"==" { return token::EGAL; }
"!=" { return token::DIFFERENT; }
"<" { return token::INF; }
">" { return token::SUP; }
"et" { return token::ET; }
"ou" { return token::OU; }

\"[^\"\n]*\" {
    std::string s(YYText());
    yylval->build<std::string>(s.substr(1, s.length()-2));
    return token::VAR_NAME;
}
\'[^\'\n]*\' {
    std::string s(YYText());
    yylval->build<std::string>(s.substr(1, s.length()-2));
    return token::VAR_NAME;
}

[a-zA-Z0-9_\./-]+ {
    yylval->build<std::string>(YYText());
    return token::VAR_NAME;
}

<<EOF>> { return token::END_OF_FILE; }
.       { }
%%



==================================================
FICHIER : ./parser/stack.hh
==================================================
// A Bison parser, made by GNU Bison 3.8.2.

// Starting with Bison 3.2, this file is useless: the structure it
// used to define is now defined with the parser itself.
//
// To get rid of this file:
// 1. add '%require "3.2"' (or newer) to your grammar file
// 2. remove references to this file from your build system.



==================================================
FICHIER : ./parser.tab.cc
==================================================
// A Bison parser, made by GNU Bison 3.8.2.

// Skeleton implementation for Bison LALR(1) parsers in C++

// Copyright (C) 2002-2015, 2018-2021 Free Software Foundation, Inc.

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// As a special exception, you may create a larger work that contains
// part or all of the Bison parser skeleton and distribute that work
// under terms of your choice, so long as that work isn't itself a
// parser generator using the skeleton or a modified version thereof
// as a parser skeleton.  Alternatively, if you modify or redistribute
// the parser skeleton itself, you may (at your option) remove this
// special exception, which will cause the skeleton and the resulting
// Bison output files to be licensed under the GNU General Public
// License without this special exception.

// This special exception was added by the Free Software Foundation in
// version 2.2 of Bison.

// DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,
// especially those whose name start with YY_ or yy_.  They are
// private implementation details that can be changed or removed.


// Take the name prefix into account.
#define yylex   parserlex



#include "parser.tab.hh"


// Unqualified %code blocks.
#line 34 "parser/parser.yy"

    #include <iostream>
    #include "scanner.hh"
    #include "driver.hh"

    #undef  yylex
    #define yylex scanner.yylex

#line 57 "parser.tab.cc"


#ifndef YY_
# if defined YYENABLE_NLS && YYENABLE_NLS
#  if ENABLE_NLS
#   include <libintl.h> // FIXME: INFRINGES ON USER NAME SPACE.
#   define YY_(msgid) dgettext ("bison-runtime", msgid)
#  endif
# endif
# ifndef YY_
#  define YY_(msgid) msgid
# endif
#endif


// Whether we are compiled with exception support.
#ifndef YY_EXCEPTIONS
# if defined __GNUC__ && !defined __EXCEPTIONS
#  define YY_EXCEPTIONS 0
# else
#  define YY_EXCEPTIONS 1
# endif
#endif

#define YYRHSLOC(Rhs, K) ((Rhs)[K].location)
/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
   If N is 0, then set CURRENT to the empty location which ends
   the previous symbol: RHS[0] (always defined).  */

# ifndef YYLLOC_DEFAULT
#  define YYLLOC_DEFAULT(Current, Rhs, N)                               \
    do                                                                  \
      if (N)                                                            \
        {                                                               \
          (Current).begin  = YYRHSLOC (Rhs, 1).begin;                   \
          (Current).end    = YYRHSLOC (Rhs, N).end;                     \
        }                                                               \
      else                                                              \
        {                                                               \
          (Current).begin = (Current).end = YYRHSLOC (Rhs, 0).end;      \
        }                                                               \
    while (false)
# endif


// Enable debugging if requested.
#if YYDEBUG

// A pseudo ostream that takes yydebug_ into account.
# define YYCDEBUG if (yydebug_) (*yycdebug_)

# define YY_SYMBOL_PRINT(Title, Symbol)         \
  do {                                          \
    if (yydebug_)                               \
    {                                           \
      *yycdebug_ << Title << ' ';               \
      yy_print_ (*yycdebug_, Symbol);           \
      *yycdebug_ << '\n';                       \
    }                                           \
  } while (false)

# define YY_REDUCE_PRINT(Rule)          \
  do {                                  \
    if (yydebug_)                       \
      yy_reduce_print_ (Rule);          \
  } while (false)

# define YY_STACK_PRINT()               \
  do {                                  \
    if (yydebug_)                       \
      yy_stack_print_ ();                \
  } while (false)

#else // !YYDEBUG

# define YYCDEBUG if (false) std::cerr
# define YY_SYMBOL_PRINT(Title, Symbol)  YY_USE (Symbol)
# define YY_REDUCE_PRINT(Rule)           static_cast<void> (0)
# define YY_STACK_PRINT()                static_cast<void> (0)

#endif // !YYDEBUG

#define yyerrok         (yyerrstatus_ = 0)
#define yyclearin       (yyla.clear ())

#define YYACCEPT        goto yyacceptlab
#define YYABORT         goto yyabortlab
#define YYERROR         goto yyerrorlab
#define YYRECOVERING()  (!!yyerrstatus_)

namespace parser {
#line 149 "parser.tab.cc"

  /// Build a parser object.
   Parser :: Parser  (Scanner &scanner_yyarg, Driver &driver_yyarg)
#if YYDEBUG
    : yydebug_ (false),
      yycdebug_ (&std::cerr),
#else
    :
#endif
      scanner (scanner_yyarg),
      driver (driver_yyarg)
  {}

   Parser ::~ Parser  ()
  {}

   Parser ::syntax_error::~syntax_error () YY_NOEXCEPT YY_NOTHROW
  {}

  /*---------.
  | symbol.  |
  `---------*/

  // basic_symbol.
  template <typename Base>
   Parser ::basic_symbol<Base>::basic_symbol (const basic_symbol& that)
    : Base (that)
    , value ()
    , location (that.location)
  {
    switch (this->kind ())
    {
      case symbol_kind::S_programme: // programme
      case symbol_kind::S_liste_instructions: // liste_instructions
        value.copy< Bloc* > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_condition: // condition
      case symbol_kind::S_condition_base: // condition_base
        value.copy< ConditionPtr > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_direction: // direction
        value.copy< Direction > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_expression: // expression
        value.copy< ExpressionPtr > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_instruction: // instruction
      case symbol_kind::S_commande: // commande
      case symbol_kind::S_structure_controle: // structure_controle
        value.copy< InstructionPtr > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_NUMBER: // NUMBER
        value.copy< double > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_VAR_NAME: // VAR_NAME
        value.copy< std::string > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_args_appel: // args_appel
        value.copy< std::vector<ExpressionPtr> > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_COLOR_HEX: // COLOR_HEX
        value.copy< std::vector<double> > (YY_MOVE (that.value));
        break;

      default:
        break;
    }

  }




  template <typename Base>
   Parser ::symbol_kind_type
   Parser ::basic_symbol<Base>::type_get () const YY_NOEXCEPT
  {
    return this->kind ();
  }


  template <typename Base>
  bool
   Parser ::basic_symbol<Base>::empty () const YY_NOEXCEPT
  {
    return this->kind () == symbol_kind::S_YYEMPTY;
  }

  template <typename Base>
  void
   Parser ::basic_symbol<Base>::move (basic_symbol& s)
  {
    super_type::move (s);
    switch (this->kind ())
    {
      case symbol_kind::S_programme: // programme
      case symbol_kind::S_liste_instructions: // liste_instructions
        value.move< Bloc* > (YY_MOVE (s.value));
        break;

      case symbol_kind::S_condition: // condition
      case symbol_kind::S_condition_base: // condition_base
        value.move< ConditionPtr > (YY_MOVE (s.value));
        break;

      case symbol_kind::S_direction: // direction
        value.move< Direction > (YY_MOVE (s.value));
        break;

      case symbol_kind::S_expression: // expression
        value.move< ExpressionPtr > (YY_MOVE (s.value));
        break;

      case symbol_kind::S_instruction: // instruction
      case symbol_kind::S_commande: // commande
      case symbol_kind::S_structure_controle: // structure_controle
        value.move< InstructionPtr > (YY_MOVE (s.value));
        break;

      case symbol_kind::S_NUMBER: // NUMBER
        value.move< double > (YY_MOVE (s.value));
        break;

      case symbol_kind::S_VAR_NAME: // VAR_NAME
        value.move< std::string > (YY_MOVE (s.value));
        break;

      case symbol_kind::S_args_appel: // args_appel
        value.move< std::vector<ExpressionPtr> > (YY_MOVE (s.value));
        break;

      case symbol_kind::S_COLOR_HEX: // COLOR_HEX
        value.move< std::vector<double> > (YY_MOVE (s.value));
        break;

      default:
        break;
    }

    location = YY_MOVE (s.location);
  }

  // by_kind.
   Parser ::by_kind::by_kind () YY_NOEXCEPT
    : kind_ (symbol_kind::S_YYEMPTY)
  {}

#if 201103L <= YY_CPLUSPLUS
   Parser ::by_kind::by_kind (by_kind&& that) YY_NOEXCEPT
    : kind_ (that.kind_)
  {
    that.clear ();
  }
#endif

   Parser ::by_kind::by_kind (const by_kind& that) YY_NOEXCEPT
    : kind_ (that.kind_)
  {}

   Parser ::by_kind::by_kind (token_kind_type t) YY_NOEXCEPT
    : kind_ (yytranslate_ (t))
  {}



  void
   Parser ::by_kind::clear () YY_NOEXCEPT
  {
    kind_ = symbol_kind::S_YYEMPTY;
  }

  void
   Parser ::by_kind::move (by_kind& that)
  {
    kind_ = that.kind_;
    that.clear ();
  }

   Parser ::symbol_kind_type
   Parser ::by_kind::kind () const YY_NOEXCEPT
  {
    return kind_;
  }


   Parser ::symbol_kind_type
   Parser ::by_kind::type_get () const YY_NOEXCEPT
  {
    return this->kind ();
  }



  // by_state.
   Parser ::by_state::by_state () YY_NOEXCEPT
    : state (empty_state)
  {}

   Parser ::by_state::by_state (const by_state& that) YY_NOEXCEPT
    : state (that.state)
  {}

  void
   Parser ::by_state::clear () YY_NOEXCEPT
  {
    state = empty_state;
  }

  void
   Parser ::by_state::move (by_state& that)
  {
    state = that.state;
    that.clear ();
  }

   Parser ::by_state::by_state (state_type s) YY_NOEXCEPT
    : state (s)
  {}

   Parser ::symbol_kind_type
   Parser ::by_state::kind () const YY_NOEXCEPT
  {
    if (state == empty_state)
      return symbol_kind::S_YYEMPTY;
    else
      return YY_CAST (symbol_kind_type, yystos_[+state]);
  }

   Parser ::stack_symbol_type::stack_symbol_type ()
  {}

   Parser ::stack_symbol_type::stack_symbol_type (YY_RVREF (stack_symbol_type) that)
    : super_type (YY_MOVE (that.state), YY_MOVE (that.location))
  {
    switch (that.kind ())
    {
      case symbol_kind::S_programme: // programme
      case symbol_kind::S_liste_instructions: // liste_instructions
        value.YY_MOVE_OR_COPY< Bloc* > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_condition: // condition
      case symbol_kind::S_condition_base: // condition_base
        value.YY_MOVE_OR_COPY< ConditionPtr > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_direction: // direction
        value.YY_MOVE_OR_COPY< Direction > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_expression: // expression
        value.YY_MOVE_OR_COPY< ExpressionPtr > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_instruction: // instruction
      case symbol_kind::S_commande: // commande
      case symbol_kind::S_structure_controle: // structure_controle
        value.YY_MOVE_OR_COPY< InstructionPtr > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_NUMBER: // NUMBER
        value.YY_MOVE_OR_COPY< double > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_VAR_NAME: // VAR_NAME
        value.YY_MOVE_OR_COPY< std::string > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_args_appel: // args_appel
        value.YY_MOVE_OR_COPY< std::vector<ExpressionPtr> > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_COLOR_HEX: // COLOR_HEX
        value.YY_MOVE_OR_COPY< std::vector<double> > (YY_MOVE (that.value));
        break;

      default:
        break;
    }

#if 201103L <= YY_CPLUSPLUS
    // that is emptied.
    that.state = empty_state;
#endif
  }

   Parser ::stack_symbol_type::stack_symbol_type (state_type s, YY_MOVE_REF (symbol_type) that)
    : super_type (s, YY_MOVE (that.location))
  {
    switch (that.kind ())
    {
      case symbol_kind::S_programme: // programme
      case symbol_kind::S_liste_instructions: // liste_instructions
        value.move< Bloc* > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_condition: // condition
      case symbol_kind::S_condition_base: // condition_base
        value.move< ConditionPtr > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_direction: // direction
        value.move< Direction > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_expression: // expression
        value.move< ExpressionPtr > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_instruction: // instruction
      case symbol_kind::S_commande: // commande
      case symbol_kind::S_structure_controle: // structure_controle
        value.move< InstructionPtr > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_NUMBER: // NUMBER
        value.move< double > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_VAR_NAME: // VAR_NAME
        value.move< std::string > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_args_appel: // args_appel
        value.move< std::vector<ExpressionPtr> > (YY_MOVE (that.value));
        break;

      case symbol_kind::S_COLOR_HEX: // COLOR_HEX
        value.move< std::vector<double> > (YY_MOVE (that.value));
        break;

      default:
        break;
    }

    // that is emptied.
    that.kind_ = symbol_kind::S_YYEMPTY;
  }

#if YY_CPLUSPLUS < 201103L
   Parser ::stack_symbol_type&
   Parser ::stack_symbol_type::operator= (const stack_symbol_type& that)
  {
    state = that.state;
    switch (that.kind ())
    {
      case symbol_kind::S_programme: // programme
      case symbol_kind::S_liste_instructions: // liste_instructions
        value.copy< Bloc* > (that.value);
        break;

      case symbol_kind::S_condition: // condition
      case symbol_kind::S_condition_base: // condition_base
        value.copy< ConditionPtr > (that.value);
        break;

      case symbol_kind::S_direction: // direction
        value.copy< Direction > (that.value);
        break;

      case symbol_kind::S_expression: // expression
        value.copy< ExpressionPtr > (that.value);
        break;

      case symbol_kind::S_instruction: // instruction
      case symbol_kind::S_commande: // commande
      case symbol_kind::S_structure_controle: // structure_controle
        value.copy< InstructionPtr > (that.value);
        break;

      case symbol_kind::S_NUMBER: // NUMBER
        value.copy< double > (that.value);
        break;

      case symbol_kind::S_VAR_NAME: // VAR_NAME
        value.copy< std::string > (that.value);
        break;

      case symbol_kind::S_args_appel: // args_appel
        value.copy< std::vector<ExpressionPtr> > (that.value);
        break;

      case symbol_kind::S_COLOR_HEX: // COLOR_HEX
        value.copy< std::vector<double> > (that.value);
        break;

      default:
        break;
    }

    location = that.location;
    return *this;
  }

   Parser ::stack_symbol_type&
   Parser ::stack_symbol_type::operator= (stack_symbol_type& that)
  {
    state = that.state;
    switch (that.kind ())
    {
      case symbol_kind::S_programme: // programme
      case symbol_kind::S_liste_instructions: // liste_instructions
        value.move< Bloc* > (that.value);
        break;

      case symbol_kind::S_condition: // condition
      case symbol_kind::S_condition_base: // condition_base
        value.move< ConditionPtr > (that.value);
        break;

      case symbol_kind::S_direction: // direction
        value.move< Direction > (that.value);
        break;

      case symbol_kind::S_expression: // expression
        value.move< ExpressionPtr > (that.value);
        break;

      case symbol_kind::S_instruction: // instruction
      case symbol_kind::S_commande: // commande
      case symbol_kind::S_structure_controle: // structure_controle
        value.move< InstructionPtr > (that.value);
        break;

      case symbol_kind::S_NUMBER: // NUMBER
        value.move< double > (that.value);
        break;

      case symbol_kind::S_VAR_NAME: // VAR_NAME
        value.move< std::string > (that.value);
        break;

      case symbol_kind::S_args_appel: // args_appel
        value.move< std::vector<ExpressionPtr> > (that.value);
        break;

      case symbol_kind::S_COLOR_HEX: // COLOR_HEX
        value.move< std::vector<double> > (that.value);
        break;

      default:
        break;
    }

    location = that.location;
    // that is emptied.
    that.state = empty_state;
    return *this;
  }
#endif

  template <typename Base>
  void
   Parser ::yy_destroy_ (const char* yymsg, basic_symbol<Base>& yysym) const
  {
    if (yymsg)
      YY_SYMBOL_PRINT (yymsg, yysym);
  }

#if YYDEBUG
  template <typename Base>
  void
   Parser ::yy_print_ (std::ostream& yyo, const basic_symbol<Base>& yysym) const
  {
    std::ostream& yyoutput = yyo;
    YY_USE (yyoutput);
    if (yysym.empty ())
      yyo << "empty symbol";
    else
      {
        symbol_kind_type yykind = yysym.kind ();
        yyo << (yykind < YYNTOKENS ? "token" : "nterm")
            << ' ' << yysym.name () << " ("
            << yysym.location << ": ";
        YY_USE (yykind);
        yyo << ')';
      }
  }
#endif

  void
   Parser ::yypush_ (const char* m, YY_MOVE_REF (stack_symbol_type) sym)
  {
    if (m)
      YY_SYMBOL_PRINT (m, sym);
    yystack_.push (YY_MOVE (sym));
  }

  void
   Parser ::yypush_ (const char* m, state_type s, YY_MOVE_REF (symbol_type) sym)
  {
#if 201103L <= YY_CPLUSPLUS
    yypush_ (m, stack_symbol_type (s, std::move (sym)));
#else
    stack_symbol_type ss (s, sym);
    yypush_ (m, ss);
#endif
  }

  void
   Parser ::yypop_ (int n) YY_NOEXCEPT
  {
    yystack_.pop (n);
  }

#if YYDEBUG
  std::ostream&
   Parser ::debug_stream () const
  {
    return *yycdebug_;
  }

  void
   Parser ::set_debug_stream (std::ostream& o)
  {
    yycdebug_ = &o;
  }


   Parser ::debug_level_type
   Parser ::debug_level () const
  {
    return yydebug_;
  }

  void
   Parser ::set_debug_level (debug_level_type l)
  {
    yydebug_ = l;
  }
#endif // YYDEBUG

   Parser ::state_type
   Parser ::yy_lr_goto_state_ (state_type yystate, int yysym)
  {
    int yyr = yypgoto_[yysym - YYNTOKENS] + yystate;
    if (0 <= yyr && yyr <= yylast_ && yycheck_[yyr] == yystate)
      return yytable_[yyr];
    else
      return yydefgoto_[yysym - YYNTOKENS];
  }

  bool
   Parser ::yy_pact_value_is_default_ (int yyvalue) YY_NOEXCEPT
  {
    return yyvalue == yypact_ninf_;
  }

  bool
   Parser ::yy_table_value_is_error_ (int yyvalue) YY_NOEXCEPT
  {
    return yyvalue == yytable_ninf_;
  }

  int
   Parser ::operator() ()
  {
    return parse ();
  }

  int
   Parser ::parse ()
  {
    int yyn;
    /// Length of the RHS of the rule being reduced.
    int yylen = 0;

    // Error handling.
    int yynerrs_ = 0;
    int yyerrstatus_ = 0;

    /// The lookahead symbol.
    symbol_type yyla;

    /// The locations where the error started and ended.
    stack_symbol_type yyerror_range[3];

    /// The return value of parse ().
    int yyresult;

#if YY_EXCEPTIONS
    try
#endif // YY_EXCEPTIONS
      {
    YYCDEBUG << "Starting parse\n";


    /* Initialize the stack.  The initial state will be set in
       yynewstate, since the latter expects the semantical and the
       location values to have been already stored, initialize these
       stacks with a primary value.  */
    yystack_.clear ();
    yypush_ (YY_NULLPTR, 0, YY_MOVE (yyla));

  /*-----------------------------------------------.
  | yynewstate -- push a new symbol on the stack.  |
  `-----------------------------------------------*/
  yynewstate:
    YYCDEBUG << "Entering state " << int (yystack_[0].state) << '\n';
    YY_STACK_PRINT ();

    // Accept?
    if (yystack_[0].state == yyfinal_)
      YYACCEPT;

    goto yybackup;


  /*-----------.
  | yybackup.  |
  `-----------*/
  yybackup:
    // Try to take a decision without lookahead.
    yyn = yypact_[+yystack_[0].state];
    if (yy_pact_value_is_default_ (yyn))
      goto yydefault;

    // Read a lookahead token.
    if (yyla.empty ())
      {
        YYCDEBUG << "Reading a token\n";
#if YY_EXCEPTIONS
        try
#endif // YY_EXCEPTIONS
          {
            yyla.kind_ = yytranslate_ (yylex (&yyla.value, &yyla.location));
          }
#if YY_EXCEPTIONS
        catch (const syntax_error& yyexc)
          {
            YYCDEBUG << "Caught exception: " << yyexc.what() << '\n';
            error (yyexc);
            goto yyerrlab1;
          }
#endif // YY_EXCEPTIONS
      }
    YY_SYMBOL_PRINT ("Next token is", yyla);

    if (yyla.kind () == symbol_kind::S_YYerror)
    {
      // The scanner already issued an error message, process directly
      // to error recovery.  But do not keep the error token as
      // lookahead, it is too special and may lead us to an endless
      // loop in error recovery. */
      yyla.kind_ = symbol_kind::S_YYUNDEF;
      goto yyerrlab1;
    }

    /* If the proper action on seeing token YYLA.TYPE is to reduce or
       to detect an error, take that action.  */
    yyn += yyla.kind ();
    if (yyn < 0 || yylast_ < yyn || yycheck_[yyn] != yyla.kind ())
      {
        goto yydefault;
      }

    // Reduce or error.
    yyn = yytable_[yyn];
    if (yyn <= 0)
      {
        if (yy_table_value_is_error_ (yyn))
          goto yyerrlab;
        yyn = -yyn;
        goto yyreduce;
      }

    // Count tokens shifted since error; after three, turn off error status.
    if (yyerrstatus_)
      --yyerrstatus_;

    // Shift the lookahead token.
    yypush_ ("Shifting", state_type (yyn), YY_MOVE (yyla));
    goto yynewstate;


  /*-----------------------------------------------------------.
  | yydefault -- do the default action for the current state.  |
  `-----------------------------------------------------------*/
  yydefault:
    yyn = yydefact_[+yystack_[0].state];
    if (yyn == 0)
      goto yyerrlab;
    goto yyreduce;


  /*-----------------------------.
  | yyreduce -- do a reduction.  |
  `-----------------------------*/
  yyreduce:
    yylen = yyr2_[yyn];
    {
      stack_symbol_type yylhs;
      yylhs.state = yy_lr_goto_state_ (yystack_[yylen].state, yyr1_[yyn]);
      /* Variants are always initialized to an empty instance of the
         correct type. The default '$$ = $1' action is NOT applied
         when using variants.  */
      switch (yyr1_[yyn])
    {
      case symbol_kind::S_programme: // programme
      case symbol_kind::S_liste_instructions: // liste_instructions
        yylhs.value.emplace< Bloc* > ();
        break;

      case symbol_kind::S_condition: // condition
      case symbol_kind::S_condition_base: // condition_base
        yylhs.value.emplace< ConditionPtr > ();
        break;

      case symbol_kind::S_direction: // direction
        yylhs.value.emplace< Direction > ();
        break;

      case symbol_kind::S_expression: // expression
        yylhs.value.emplace< ExpressionPtr > ();
        break;

      case symbol_kind::S_instruction: // instruction
      case symbol_kind::S_commande: // commande
      case symbol_kind::S_structure_controle: // structure_controle
        yylhs.value.emplace< InstructionPtr > ();
        break;

      case symbol_kind::S_NUMBER: // NUMBER
        yylhs.value.emplace< double > ();
        break;

      case symbol_kind::S_VAR_NAME: // VAR_NAME
        yylhs.value.emplace< std::string > ();
        break;

      case symbol_kind::S_args_appel: // args_appel
        yylhs.value.emplace< std::vector<ExpressionPtr> > ();
        break;

      case symbol_kind::S_COLOR_HEX: // COLOR_HEX
        yylhs.value.emplace< std::vector<double> > ();
        break;

      default:
        break;
    }


      // Default location.
      {
        stack_type::slice range (yystack_, yylen);
        YYLLOC_DEFAULT (yylhs.location, range, yylen);
        yyerror_range[1].location = yylhs.location;
      }

      // Perform the reduction.
      YY_REDUCE_PRINT (yyn);
#if YY_EXCEPTIONS
      try
#endif // YY_EXCEPTIONS
        {
          switch (yyn)
            {
  case 2: // root: programme
#line 73 "parser/parser.yy"
              {
        driver.executer(yystack_[0].value.as < Bloc* > ());
        delete yystack_[0].value.as < Bloc* > ();
        YYACCEPT;
    }
#line 923 "parser.tab.cc"
    break;

  case 3: // programme: programme instruction NL
#line 81 "parser/parser.yy"
                               { yylhs.value.as < Bloc* > () = yystack_[2].value.as < Bloc* > (); yylhs.value.as < Bloc* > ()->ajouter(yystack_[1].value.as < InstructionPtr > ()); }
#line 929 "parser.tab.cc"
    break;

  case 4: // programme: programme instruction END NL
#line 82 "parser/parser.yy"
                                   { yylhs.value.as < Bloc* > () = yystack_[3].value.as < Bloc* > (); yylhs.value.as < Bloc* > ()->ajouter(yystack_[2].value.as < InstructionPtr > ()); }
#line 935 "parser.tab.cc"
    break;

  case 5: // programme: programme instruction END_OF_FILE
#line 83 "parser/parser.yy"
                                        { yylhs.value.as < Bloc* > () = yystack_[2].value.as < Bloc* > (); yylhs.value.as < Bloc* > ()->ajouter(yystack_[1].value.as < InstructionPtr > ()); }
#line 941 "parser.tab.cc"
    break;

  case 6: // programme: programme NL
#line 84 "parser/parser.yy"
                   { yylhs.value.as < Bloc* > () = yystack_[1].value.as < Bloc* > (); }
#line 947 "parser.tab.cc"
    break;

  case 7: // programme: programme definition_fonction NL
#line 85 "parser/parser.yy"
                                       { yylhs.value.as < Bloc* > () = yystack_[2].value.as < Bloc* > (); }
#line 953 "parser.tab.cc"
    break;

  case 8: // programme: %empty
#line 86 "parser/parser.yy"
                 { yylhs.value.as < Bloc* > () = new Bloc(); }
#line 959 "parser.tab.cc"
    break;

  case 9: // definition_fonction: FONCTION VAR_NAME DP NL liste_instructions END FONCTION
#line 90 "parser/parser.yy"
                                                            {
        driver.definirFonction(yystack_[5].value.as < std::string > (), yystack_[2].value.as < Bloc* > ());
    }
#line 967 "parser.tab.cc"
    break;

  case 10: // liste_instructions: liste_instructions instruction NL
#line 96 "parser/parser.yy"
                                        { yylhs.value.as < Bloc* > () = yystack_[2].value.as < Bloc* > (); yylhs.value.as < Bloc* > ()->ajouter(yystack_[1].value.as < InstructionPtr > ()); }
#line 973 "parser.tab.cc"
    break;

  case 11: // liste_instructions: instruction NL
#line 97 "parser/parser.yy"
                     { yylhs.value.as < Bloc* > () = new Bloc(); yylhs.value.as < Bloc* > ()->ajouter(yystack_[1].value.as < InstructionPtr > ()); }
#line 979 "parser.tab.cc"
    break;

  case 12: // liste_instructions: liste_instructions NL
#line 98 "parser/parser.yy"
                            { yylhs.value.as < Bloc* > () = yystack_[1].value.as < Bloc* > (); }
#line 985 "parser.tab.cc"
    break;

  case 13: // instruction: commande
#line 102 "parser/parser.yy"
               { yylhs.value.as < InstructionPtr > () = yystack_[0].value.as < InstructionPtr > (); }
#line 991 "parser.tab.cc"
    break;

  case 14: // instruction: structure_controle
#line 103 "parser/parser.yy"
                         { yylhs.value.as < InstructionPtr > () = yystack_[0].value.as < InstructionPtr > (); }
#line 997 "parser.tab.cc"
    break;

  case 15: // commande: AVANCE expression
#line 107 "parser/parser.yy"
                        { yylhs.value.as < InstructionPtr > () = std::make_shared<CommandeMouvement>(yystack_[0].value.as < ExpressionPtr > (), TypeMouvement::AVANCE); }
#line 1003 "parser.tab.cc"
    break;

  case 16: // commande: RECULE expression
#line 108 "parser/parser.yy"
                        { yylhs.value.as < InstructionPtr > () = std::make_shared<CommandeMouvement>(yystack_[0].value.as < ExpressionPtr > (), TypeMouvement::RECULE); }
#line 1009 "parser.tab.cc"
    break;

  case 17: // commande: TOURNE expression
#line 109 "parser/parser.yy"
                        { yylhs.value.as < InstructionPtr > () = std::make_shared<CommandeMouvement>(yystack_[0].value.as < ExpressionPtr > (), TypeMouvement::TOURNE); }
#line 1015 "parser.tab.cc"
    break;

  case 18: // commande: TOURNE direction
#line 110 "parser/parser.yy"
                        {
        double angle = (yystack_[0].value.as < Direction > () == Direction::GAUCHE) ? -90.0 : 90.0;
        yylhs.value.as < InstructionPtr > () = std::make_shared<CommandeMouvement>(std::make_shared<Constante>(angle), TypeMouvement::TOURNE);
      }
#line 1024 "parser.tab.cc"
    break;

  case 19: // commande: SAUTE expression
#line 114 "parser/parser.yy"
                        { yylhs.value.as < InstructionPtr > () = std::make_shared<CommandeMouvement>(yystack_[0].value.as < ExpressionPtr > (), TypeMouvement::SAUTE); }
#line 1030 "parser.tab.cc"
    break;

  case 20: // commande: COULEUR COLOR_HEX
#line 115 "parser/parser.yy"
                        { yylhs.value.as < InstructionPtr > () = std::make_shared<CommandeCouleur>(yystack_[0].value.as < std::vector<double> > ()[0], yystack_[0].value.as < std::vector<double> > ()[1], yystack_[0].value.as < std::vector<double> > ()[2]); }
#line 1036 "parser.tab.cc"
    break;

  case 21: // commande: JARDIN VAR_NAME
#line 116 "parser/parser.yy"
                        {
                          driver.nouveauJardin(yystack_[0].value.as < std::string > ());
                          yylhs.value.as < InstructionPtr > () = std::make_shared<Bloc>();
                        }
#line 1045 "parser.tab.cc"
    break;

  case 22: // commande: VAR_NAME args_appel
#line 120 "parser/parser.yy"
                          { yylhs.value.as < InstructionPtr > () = std::make_shared<AppelFonction>(yystack_[1].value.as < std::string > (), yystack_[0].value.as < std::vector<ExpressionPtr> > ()); }
#line 1051 "parser.tab.cc"
    break;

  case 23: // commande: commande AROBASE expression
#line 121 "parser/parser.yy"
                                  {
        Bloc* b = new Bloc();
        b->ajouter(std::make_shared<CommandeSelectionTortue>(yystack_[0].value.as < ExpressionPtr > ()));
        b->ajouter(yystack_[2].value.as < InstructionPtr > ());
        yylhs.value.as < InstructionPtr > () = std::shared_ptr<Instruction>(b);
    }
#line 1062 "parser.tab.cc"
    break;

  case 24: // structure_controle: SI condition DP NL liste_instructions END SI
#line 130 "parser/parser.yy"
                                                   {
          yylhs.value.as < InstructionPtr > () = std::make_shared<ControleSi>(yystack_[5].value.as < ConditionPtr > (), std::shared_ptr<Instruction>(yystack_[2].value.as < Bloc* > ()));
      }
#line 1070 "parser.tab.cc"
    break;

  case 25: // structure_controle: SI condition DP NL liste_instructions SINON DP NL liste_instructions END SI
#line 133 "parser/parser.yy"
                                                                                  {
          yylhs.value.as < InstructionPtr > () = std::make_shared<ControleSi>(yystack_[9].value.as < ConditionPtr > (), std::shared_ptr<Instruction>(yystack_[6].value.as < Bloc* > ()), std::shared_ptr<Instruction>(yystack_[2].value.as < Bloc* > ()));
      }
#line 1078 "parser.tab.cc"
    break;

  case 26: // structure_controle: TANT QUE condition DP NL liste_instructions END TANT QUE
#line 136 "parser/parser.yy"
                                                               {
          /* Correction ici : $3 pour la condition au lieu de $2 */
          yylhs.value.as < InstructionPtr > () = std::make_shared<ControleTantQue>(yystack_[6].value.as < ConditionPtr > (), std::shared_ptr<Instruction>(yystack_[3].value.as < Bloc* > ()));
      }
#line 1087 "parser.tab.cc"
    break;

  case 27: // structure_controle: REPETE expression DP NL liste_instructions END REPETE
#line 140 "parser/parser.yy"
                                                            {
          yylhs.value.as < InstructionPtr > () = std::make_shared<ControleRepete>(yystack_[5].value.as < ExpressionPtr > (), std::shared_ptr<Instruction>(yystack_[2].value.as < Bloc* > ()));
      }
#line 1095 "parser.tab.cc"
    break;

  case 28: // args_appel: args_appel expression
#line 146 "parser/parser.yy"
                            { yylhs.value.as < std::vector<ExpressionPtr> > () = yystack_[1].value.as < std::vector<ExpressionPtr> > (); yylhs.value.as < std::vector<ExpressionPtr> > ().push_back(yystack_[0].value.as < ExpressionPtr > ()); }
#line 1101 "parser.tab.cc"
    break;

  case 29: // args_appel: %empty
#line 147 "parser/parser.yy"
                 { }
#line 1107 "parser.tab.cc"
    break;

  case 30: // condition: condition_base
#line 151 "parser/parser.yy"
                     { yylhs.value.as < ConditionPtr > () = yystack_[0].value.as < ConditionPtr > (); }
#line 1113 "parser.tab.cc"
    break;

  case 31: // condition: PAS condition_base
#line 152 "parser/parser.yy"
                         {
        yylhs.value.as < ConditionPtr > () = yystack_[0].value.as < ConditionPtr > ();
    }
#line 1121 "parser.tab.cc"
    break;

  case 32: // condition: condition ET condition
#line 155 "parser/parser.yy"
                             { yylhs.value.as < ConditionPtr > () = std::make_shared<ConditionBinaire>(yystack_[2].value.as < ConditionPtr > (), yystack_[0].value.as < ConditionPtr > (), OperateurBinaireBool::et); }
#line 1127 "parser.tab.cc"
    break;

  case 33: // condition: condition OU condition
#line 156 "parser/parser.yy"
                             { yylhs.value.as < ConditionPtr > () = std::make_shared<ConditionBinaire>(yystack_[2].value.as < ConditionPtr > (), yystack_[0].value.as < ConditionPtr > (), OperateurBinaireBool::ou); }
#line 1133 "parser.tab.cc"
    break;

  case 34: // condition: LPAR condition RPAR
#line 157 "parser/parser.yy"
                          { yylhs.value.as < ConditionPtr > () = yystack_[1].value.as < ConditionPtr > (); }
#line 1139 "parser.tab.cc"
    break;

  case 35: // condition_base: MUR direction
#line 161 "parser/parser.yy"
                    { yylhs.value.as < ConditionPtr > () = std::make_shared<ConditionCapteur>(TypeCapteur::MUR, yystack_[0].value.as < Direction > ()); }
#line 1145 "parser.tab.cc"
    break;

  case 36: // condition_base: VIDE direction
#line 162 "parser/parser.yy"
                     { yylhs.value.as < ConditionPtr > () = std::make_shared<ConditionCapteur>(TypeCapteur::VIDE, yystack_[0].value.as < Direction > ()); }
#line 1151 "parser.tab.cc"
    break;

  case 37: // condition_base: PAS MUR direction
#line 163 "parser/parser.yy"
                        {
         yylhs.value.as < ConditionPtr > () = std::make_shared<ConditionCapteur>(TypeCapteur::VIDE, yystack_[0].value.as < Direction > ());
      }
#line 1159 "parser.tab.cc"
    break;

  case 38: // condition_base: PAS VIDE direction
#line 166 "parser/parser.yy"
                         {
         yylhs.value.as < ConditionPtr > () = std::make_shared<ConditionCapteur>(TypeCapteur::MUR, yystack_[0].value.as < Direction > ());
      }
#line 1167 "parser.tab.cc"
    break;

  case 39: // condition_base: expression EGAL expression
#line 169 "parser/parser.yy"
                                 { yylhs.value.as < ConditionPtr > () = std::make_shared<TestBinaire>(yystack_[2].value.as < ExpressionPtr > (), yystack_[0].value.as < ExpressionPtr > (), OperateurBool::egal); }
#line 1173 "parser.tab.cc"
    break;

  case 40: // condition_base: expression DIFFERENT expression
#line 170 "parser/parser.yy"
                                      { yylhs.value.as < ConditionPtr > () = std::make_shared<TestBinaire>(yystack_[2].value.as < ExpressionPtr > (), yystack_[0].value.as < ExpressionPtr > (), OperateurBool::different); }
#line 1179 "parser.tab.cc"
    break;

  case 41: // condition_base: expression INF expression
#line 171 "parser/parser.yy"
                                { yylhs.value.as < ConditionPtr > () = std::make_shared<TestBinaire>(yystack_[2].value.as < ExpressionPtr > (), yystack_[0].value.as < ExpressionPtr > (), OperateurBool::pluspetit); }
#line 1185 "parser.tab.cc"
    break;

  case 42: // condition_base: expression SUP expression
#line 172 "parser/parser.yy"
                                { yylhs.value.as < ConditionPtr > () = std::make_shared<TestBinaire>(yystack_[2].value.as < ExpressionPtr > (), yystack_[0].value.as < ExpressionPtr > (), OperateurBool::plusgrand); }
#line 1191 "parser.tab.cc"
    break;

  case 43: // direction: DEVANT
#line 176 "parser/parser.yy"
             { yylhs.value.as < Direction > () = Direction::DEVANT; }
#line 1197 "parser.tab.cc"
    break;

  case 44: // direction: DERRIERE
#line 177 "parser/parser.yy"
               { yylhs.value.as < Direction > () = Direction::DERRIERE; }
#line 1203 "parser.tab.cc"
    break;

  case 45: // direction: GAUCHE
#line 178 "parser/parser.yy"
             { yylhs.value.as < Direction > () = Direction::GAUCHE; }
#line 1209 "parser.tab.cc"
    break;

  case 46: // direction: DROITE
#line 179 "parser/parser.yy"
             { yylhs.value.as < Direction > () = Direction::DROITE; }
#line 1215 "parser.tab.cc"
    break;

  case 47: // expression: NUMBER
#line 183 "parser/parser.yy"
             { yylhs.value.as < ExpressionPtr > () = std::make_shared<Constante>(yystack_[0].value.as < double > ()); }
#line 1221 "parser.tab.cc"
    break;

  case 48: // expression: VAR_NAME
#line 184 "parser/parser.yy"
               { yylhs.value.as < ExpressionPtr > () = std::make_shared<Variable>(yystack_[0].value.as < std::string > ()); }
#line 1227 "parser.tab.cc"
    break;

  case 49: // expression: DOLLAR NUMBER
#line 185 "parser/parser.yy"
                    { yylhs.value.as < ExpressionPtr > () = std::make_shared<Variable>("$" + std::to_string((int)yystack_[0].value.as < double > ())); }
#line 1233 "parser.tab.cc"
    break;

  case 50: // expression: expression PLUS expression
#line 186 "parser/parser.yy"
                                 { yylhs.value.as < ExpressionPtr > () = std::make_shared<ExpressionBinaire>(yystack_[2].value.as < ExpressionPtr > (), yystack_[0].value.as < ExpressionPtr > (), OperateurBinaire::plus); }
#line 1239 "parser.tab.cc"
    break;

  case 51: // expression: expression MOINS expression
#line 187 "parser/parser.yy"
                                  { yylhs.value.as < ExpressionPtr > () = std::make_shared<ExpressionBinaire>(yystack_[2].value.as < ExpressionPtr > (), yystack_[0].value.as < ExpressionPtr > (), OperateurBinaire::moins); }
#line 1245 "parser.tab.cc"
    break;

  case 52: // expression: expression MULT expression
#line 188 "parser/parser.yy"
                                 { yylhs.value.as < ExpressionPtr > () = std::make_shared<ExpressionBinaire>(yystack_[2].value.as < ExpressionPtr > (), yystack_[0].value.as < ExpressionPtr > (), OperateurBinaire::multiplie); }
#line 1251 "parser.tab.cc"
    break;

  case 53: // expression: expression DIV expression
#line 189 "parser/parser.yy"
                                { yylhs.value.as < ExpressionPtr > () = std::make_shared<ExpressionBinaire>(yystack_[2].value.as < ExpressionPtr > (), yystack_[0].value.as < ExpressionPtr > (), OperateurBinaire::divise); }
#line 1257 "parser.tab.cc"
    break;

  case 54: // expression: MOINS expression
#line 190 "parser/parser.yy"
                                 { yylhs.value.as < ExpressionPtr > () = std::make_shared<ExpressionUnaire>(yystack_[0].value.as < ExpressionPtr > (), OperateurUnaire::neg); }
#line 1263 "parser.tab.cc"
    break;

  case 55: // expression: LPAR expression RPAR
#line 191 "parser/parser.yy"
                           { yylhs.value.as < ExpressionPtr > () = yystack_[1].value.as < ExpressionPtr > (); }
#line 1269 "parser.tab.cc"
    break;


#line 1273 "parser.tab.cc"

            default:
              break;
            }
        }
#if YY_EXCEPTIONS
      catch (const syntax_error& yyexc)
        {
          YYCDEBUG << "Caught exception: " << yyexc.what() << '\n';
          error (yyexc);
          YYERROR;
        }
#endif // YY_EXCEPTIONS
      YY_SYMBOL_PRINT ("-> $$ =", yylhs);
      yypop_ (yylen);
      yylen = 0;

      // Shift the result of the reduction.
      yypush_ (YY_NULLPTR, YY_MOVE (yylhs));
    }
    goto yynewstate;


  /*--------------------------------------.
  | yyerrlab -- here on detecting error.  |
  `--------------------------------------*/
  yyerrlab:
    // If not already recovering from an error, report this error.
    if (!yyerrstatus_)
      {
        ++yynerrs_;
        std::string msg = YY_("syntax error");
        error (yyla.location, YY_MOVE (msg));
      }


    yyerror_range[1].location = yyla.location;
    if (yyerrstatus_ == 3)
      {
        /* If just tried and failed to reuse lookahead token after an
           error, discard it.  */

        // Return failure if at end of input.
        if (yyla.kind () == symbol_kind::S_YYEOF)
          YYABORT;
        else if (!yyla.empty ())
          {
            yy_destroy_ ("Error: discarding", yyla);
            yyla.clear ();
          }
      }

    // Else will try to reuse lookahead token after shifting the error token.
    goto yyerrlab1;


  /*---------------------------------------------------.
  | yyerrorlab -- error raised explicitly by YYERROR.  |
  `---------------------------------------------------*/
  yyerrorlab:
    /* Pacify compilers when the user code never invokes YYERROR and
       the label yyerrorlab therefore never appears in user code.  */
    if (false)
      YYERROR;

    /* Do not reclaim the symbols of the rule whose action triggered
       this YYERROR.  */
    yypop_ (yylen);
    yylen = 0;
    YY_STACK_PRINT ();
    goto yyerrlab1;


  /*-------------------------------------------------------------.
  | yyerrlab1 -- common code for both syntax error and YYERROR.  |
  `-------------------------------------------------------------*/
  yyerrlab1:
    yyerrstatus_ = 3;   // Each real token shifted decrements this.
    // Pop stack until we find a state that shifts the error token.
    for (;;)
      {
        yyn = yypact_[+yystack_[0].state];
        if (!yy_pact_value_is_default_ (yyn))
          {
            yyn += symbol_kind::S_YYerror;
            if (0 <= yyn && yyn <= yylast_
                && yycheck_[yyn] == symbol_kind::S_YYerror)
              {
                yyn = yytable_[yyn];
                if (0 < yyn)
                  break;
              }
          }

        // Pop the current state because it cannot handle the error token.
        if (yystack_.size () == 1)
          YYABORT;

        yyerror_range[1].location = yystack_[0].location;
        yy_destroy_ ("Error: popping", yystack_[0]);
        yypop_ ();
        YY_STACK_PRINT ();
      }
    {
      stack_symbol_type error_token;

      yyerror_range[2].location = yyla.location;
      YYLLOC_DEFAULT (error_token.location, yyerror_range, 2);

      // Shift the error token.
      error_token.state = state_type (yyn);
      yypush_ ("Shifting", YY_MOVE (error_token));
    }
    goto yynewstate;


  /*-------------------------------------.
  | yyacceptlab -- YYACCEPT comes here.  |
  `-------------------------------------*/
  yyacceptlab:
    yyresult = 0;
    goto yyreturn;


  /*-----------------------------------.
  | yyabortlab -- YYABORT comes here.  |
  `-----------------------------------*/
  yyabortlab:
    yyresult = 1;
    goto yyreturn;


  /*-----------------------------------------------------.
  | yyreturn -- parsing is finished, return the result.  |
  `-----------------------------------------------------*/
  yyreturn:
    if (!yyla.empty ())
      yy_destroy_ ("Cleanup: discarding lookahead", yyla);

    /* Do not reclaim the symbols of the rule whose action triggered
       this YYABORT or YYACCEPT.  */
    yypop_ (yylen);
    YY_STACK_PRINT ();
    while (1 < yystack_.size ())
      {
        yy_destroy_ ("Cleanup: popping", yystack_[0]);
        yypop_ ();
      }

    return yyresult;
  }
#if YY_EXCEPTIONS
    catch (...)
      {
        YYCDEBUG << "Exception caught: cleaning lookahead and stack\n";
        // Do not try to display the values of the reclaimed symbols,
        // as their printers might throw an exception.
        if (!yyla.empty ())
          yy_destroy_ (YY_NULLPTR, yyla);

        while (1 < yystack_.size ())
          {
            yy_destroy_ (YY_NULLPTR, yystack_[0]);
            yypop_ ();
          }
        throw;
      }
#endif // YY_EXCEPTIONS
  }

  void
   Parser ::error (const syntax_error& yyexc)
  {
    error (yyexc.location, yyexc.what ());
  }

#if YYDEBUG || 0
  const char *
   Parser ::symbol_name (symbol_kind_type yysymbol)
  {
    return yytname_[yysymbol];
  }
#endif // #if YYDEBUG || 0









  const signed char  Parser ::yypact_ninf_ = -85;

  const signed char  Parser ::yytable_ninf_ = -1;

  const short
   Parser ::yypact_[] =
  {
     -85,     8,    87,   -85,   -85,   -14,   -14,   205,   -14,   -17,
     -30,   -13,   180,    15,   -14,   -85,    32,    45,    39,   -85,
       0,   -14,   -14,   -85,   -85,    33,    33,   -85,   -85,   -85,
     -85,   -85,    33,    33,   -85,   -85,    47,    84,    84,   184,
     180,   -15,   -85,   229,   180,    14,   -14,   -85,   -85,    76,
     -85,   -14,   -85,   -85,   210,   -14,   -14,   -14,   -14,    78,
     -85,   -85,    84,    84,     3,   -85,    21,   219,    82,   180,
     180,   -14,   -14,   -14,   -14,    -6,    85,    33,   -85,    33,
     -85,    27,    27,   -85,   -85,   178,   -85,   -85,    84,    84,
     -85,   178,   -85,    48,    33,    33,    33,    33,    86,   178,
     110,    88,   -85,   -85,    68,   178,   127,   -85,    79,   109,
     -85,   101,    97,   147,   107,   -85,   -85,   -85,   124,   116,
     -85,   178,   121,   164,   -85,   126,   -85
  };

  const signed char
   Parser ::yydefact_[] =
  {
       8,     0,     2,     1,     6,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,    29,     0,     0,    13,    14,
       0,     0,     0,    47,    48,    15,    16,    43,    44,    45,
      46,    18,    17,    19,    20,    21,     0,     0,     0,     0,
       0,     0,    30,     0,     0,     0,    22,     7,     3,     0,
       5,     0,    49,    54,     0,     0,     0,     0,     0,     0,
      35,    36,     0,     0,     0,    31,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,    28,     4,    23,
      55,    50,    51,    52,    53,     0,    35,    36,     0,     0,
      34,     0,    32,    33,    39,    40,    41,    42,     0,     0,
       0,     0,    37,    38,     0,     0,     0,    12,     0,     0,
      11,     0,     0,     0,     0,     9,    10,    24,     0,     0,
      27,     0,     0,     0,    26,     0,    25
  };

  const signed char
   Parser ::yypgoto_[] =
  {
     -85,   -85,   -85,   -85,   -84,    -2,   -85,   -85,   -85,   -31,
     103,   -32,    -4
  };

  const signed char
   Parser ::yydefgoto_[] =
  {
       0,     1,     2,    16,   100,   101,    18,    19,    46,    41,
      42,    31,    43
  };

  const signed char
   Parser ::yytable_[] =
  {
      17,    25,    26,    32,    33,    60,    61,   104,     3,    66,
      45,    68,    35,    75,    20,   106,    21,    53,    54,    22,
      98,   113,    88,    89,    69,    70,    34,    23,    24,    36,
      86,    87,    44,    69,    70,    47,    67,   123,    92,    93,
      76,    52,    77,    55,    56,    57,    58,    79,    48,    49,
      50,    81,    82,    83,    84,    90,   102,   103,    57,    58,
      69,    70,    55,    56,    57,    58,    51,    94,    95,    96,
      97,   107,   111,    59,     5,     6,     7,     8,     9,    78,
      10,    85,    12,   112,    13,    91,    14,    69,    99,   105,
       4,   110,   115,     5,     6,     7,     8,     9,   109,    10,
      11,    12,   109,    13,   109,    14,    27,    28,    29,    30,
      15,   109,   116,   107,   108,   117,     5,     6,     7,     8,
       9,   109,    10,   118,    12,   120,    13,   121,    14,    15,
     107,   114,   122,     5,     6,     7,     8,     9,   124,    10,
     126,    12,    65,    13,     0,    14,     0,     0,     0,     0,
     107,   119,    15,     5,     6,     7,     8,     9,     0,    10,
       0,    12,     0,    13,     0,    14,     0,   107,   125,    15,
       5,     6,     7,     8,     9,     0,    10,     0,    12,     0,
      13,     0,    14,     0,     5,     6,     7,     8,     9,    15,
      10,     0,    12,     0,    13,     0,    14,     0,     0,    37,
      38,    39,     0,    62,    63,    64,    15,     0,    20,     0,
      21,     0,    20,    40,    21,     0,     0,    22,     0,     0,
      15,    23,    24,     0,     0,    23,    24,    27,    28,    29,
      30,     0,     0,    20,     0,    21,     0,     0,    22,    55,
      56,    57,    58,     0,    80,     0,    23,    24,    55,    56,
      57,    58,     0,    80,    71,    72,    73,    74,    55,    56,
      57,    58,     0,     0,    71,    72,    73,    74
  };

  const signed char
   Parser ::yycheck_[] =
  {
       2,     5,     6,     7,     8,    37,    38,    91,     0,    40,
      14,    26,    42,    44,    28,    99,    30,    21,    22,    33,
      26,   105,    19,    20,    39,    40,    43,    41,    42,    42,
      62,    63,    17,    39,    40,     3,    40,   121,    69,    70,
      26,    41,    46,    29,    30,    31,    32,    51,     3,     4,
       5,    55,    56,    57,    58,    34,    88,    89,    31,    32,
      39,    40,    29,    30,    31,    32,    27,    71,    72,    73,
      74,     3,     4,    26,     6,     7,     8,     9,    10,     3,
      12,     3,    14,    15,    16,     3,    18,    39,     3,     3,
       3,     3,    13,     6,     7,     8,     9,    10,   100,    12,
      13,    14,   104,    16,   106,    18,    22,    23,    24,    25,
      42,   113,     3,     3,     4,    14,     6,     7,     8,     9,
      10,   123,    12,    26,    14,    18,    16,     3,    18,    42,
       3,     4,    16,     6,     7,     8,     9,    10,    17,    12,
      14,    14,    39,    16,    -1,    18,    -1,    -1,    -1,    -1,
       3,     4,    42,     6,     7,     8,     9,    10,    -1,    12,
      -1,    14,    -1,    16,    -1,    18,    -1,     3,     4,    42,
       6,     7,     8,     9,    10,    -1,    12,    -1,    14,    -1,
      16,    -1,    18,    -1,     6,     7,     8,     9,    10,    42,
      12,    -1,    14,    -1,    16,    -1,    18,    -1,    -1,    19,
      20,    21,    -1,    19,    20,    21,    42,    -1,    28,    -1,
      30,    -1,    28,    33,    30,    -1,    -1,    33,    -1,    -1,
      42,    41,    42,    -1,    -1,    41,    42,    22,    23,    24,
      25,    -1,    -1,    28,    -1,    30,    -1,    -1,    33,    29,
      30,    31,    32,    -1,    34,    -1,    41,    42,    29,    30,
      31,    32,    -1,    34,    35,    36,    37,    38,    29,    30,
      31,    32,    -1,    -1,    35,    36,    37,    38
  };

  const signed char
   Parser ::yystos_[] =
  {
       0,    46,    47,     0,     3,     6,     7,     8,     9,    10,
      12,    13,    14,    16,    18,    42,    48,    50,    51,    52,
      28,    30,    33,    41,    42,    57,    57,    22,    23,    24,
      25,    56,    57,    57,    43,    42,    42,    19,    20,    21,
      33,    54,    55,    57,    17,    57,    53,     3,     3,     4,
       5,    27,    41,    57,    57,    29,    30,    31,    32,    26,
      56,    56,    19,    20,    21,    55,    54,    57,    26,    39,
      40,    35,    36,    37,    38,    54,    26,    57,     3,    57,
      34,    57,    57,    57,    57,     3,    56,    56,    19,    20,
      34,     3,    54,    54,    57,    57,    57,    57,    26,     3,
      49,    50,    56,    56,    49,     3,    49,     3,     4,    50,
       3,     4,    15,    49,     4,    13,     3,    14,    26,     4,
      18,     3,    16,    49,    17,     4,    14
  };

  const signed char
   Parser ::yyr1_[] =
  {
       0,    45,    46,    47,    47,    47,    47,    47,    47,    48,
      49,    49,    49,    50,    50,    51,    51,    51,    51,    51,
      51,    51,    51,    51,    52,    52,    52,    52,    53,    53,
      54,    54,    54,    54,    54,    55,    55,    55,    55,    55,
      55,    55,    55,    56,    56,    56,    56,    57,    57,    57,
      57,    57,    57,    57,    57,    57
  };

  const signed char
   Parser ::yyr2_[] =
  {
       0,     2,     1,     3,     4,     3,     2,     3,     0,     7,
       3,     2,     2,     1,     1,     2,     2,     2,     2,     2,
       2,     2,     2,     3,     7,    11,     9,     7,     2,     0,
       1,     2,     3,     3,     3,     2,     2,     3,     3,     3,
       3,     3,     3,     1,     1,     1,     1,     1,     1,     2,
       3,     3,     3,     3,     2,     3
  };


#if YYDEBUG
  // YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
  // First, the terminals, then, starting at \a YYNTOKENS, nonterminals.
  const char*
  const  Parser ::yytname_[] =
  {
  "\"end of file\"", "error", "\"invalid token\"", "NL", "END",
  "END_OF_FILE", "AVANCE", "RECULE", "TOURNE", "SAUTE", "COULEUR",
  "TORTUES", "JARDIN", "FONCTION", "SI", "SINON", "TANT", "QUE", "REPETE",
  "MUR", "VIDE", "PAS", "DEVANT", "DERRIERE", "GAUCHE", "DROITE", "DP",
  "AROBASE", "DOLLAR", "PLUS", "MOINS", "MULT", "DIV", "LPAR", "RPAR",
  "EGAL", "DIFFERENT", "INF", "SUP", "ET", "OU", "NUMBER", "VAR_NAME",
  "COLOR_HEX", "NEG", "$accept", "root", "programme",
  "definition_fonction", "liste_instructions", "instruction", "commande",
  "structure_controle", "args_appel", "condition", "condition_base",
  "direction", "expression", YY_NULLPTR
  };
#endif


#if YYDEBUG
  const unsigned char
   Parser ::yyrline_[] =
  {
       0,    73,    73,    81,    82,    83,    84,    85,    86,    90,
      96,    97,    98,   102,   103,   107,   108,   109,   110,   114,
     115,   116,   120,   121,   130,   133,   136,   140,   146,   147,
     151,   152,   155,   156,   157,   161,   162,   163,   166,   169,
     170,   171,   172,   176,   177,   178,   179,   183,   184,   185,
     186,   187,   188,   189,   190,   191
  };

  void
   Parser ::yy_stack_print_ () const
  {
    *yycdebug_ << "Stack now";
    for (stack_type::const_iterator
           i = yystack_.begin (),
           i_end = yystack_.end ();
         i != i_end; ++i)
      *yycdebug_ << ' ' << int (i->state);
    *yycdebug_ << '\n';
  }

  void
   Parser ::yy_reduce_print_ (int yyrule) const
  {
    int yylno = yyrline_[yyrule];
    int yynrhs = yyr2_[yyrule];
    // Print the symbols being reduced, and their result.
    *yycdebug_ << "Reducing stack by rule " << yyrule - 1
               << " (line " << yylno << "):\n";
    // The symbols being reduced.
    for (int yyi = 0; yyi < yynrhs; yyi++)
      YY_SYMBOL_PRINT ("   $" << yyi + 1 << " =",
                       yystack_[(yynrhs) - (yyi + 1)]);
  }
#endif // YYDEBUG

   Parser ::symbol_kind_type
   Parser ::yytranslate_ (int t) YY_NOEXCEPT
  {
    // YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to
    // TOKEN-NUM as returned by yylex.
    static
    const signed char
    translate_table[] =
    {
       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
      35,    36,    37,    38,    39,    40,    41,    42,    43,    44
    };
    // Last valid token kind.
    const int code_max = 299;

    if (t <= 0)
      return symbol_kind::S_YYEOF;
    else if (t <= code_max)
      return static_cast <symbol_kind_type> (translate_table[t]);
    else
      return symbol_kind::S_YYUNDEF;
  }

} // parser
#line 1736 "parser.tab.cc"

#line 194 "parser/parser.yy"


void yy::Parser::error( const location_type &l, const std::string & err_msg) {
    std::cerr << "Erreur : " << l << ", " << err_msg << std::endl;
}



==================================================
FICHIER : ./parser.tab.hh
==================================================
// A Bison parser, made by GNU Bison 3.8.2.

// Skeleton interface for Bison LALR(1) parsers in C++

// Copyright (C) 2002-2015, 2018-2021 Free Software Foundation, Inc.

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// As a special exception, you may create a larger work that contains
// part or all of the Bison parser skeleton and distribute that work
// under terms of your choice, so long as that work isn't itself a
// parser generator using the skeleton or a modified version thereof
// as a parser skeleton.  Alternatively, if you modify or redistribute
// the parser skeleton itself, you may (at your option) remove this
// special exception, which will cause the skeleton and the resulting
// Bison output files to be licensed under the GNU General Public
// License without this special exception.

// This special exception was added by the Free Software Foundation in
// version 2.2 of Bison.


/**
 ** \file parser.tab.hh
 ** Define the parser::parser class.
 */

// C++ LALR(1) parser skeleton written by Akim Demaille.

// DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,
// especially those whose name start with YY_ or yy_.  They are
// private implementation details that can be changed or removed.

#ifndef YY_PARSER_PARSER_TAB_HH_INCLUDED
# define YY_PARSER_PARSER_TAB_HH_INCLUDED
// "%code requires" blocks.
#line 11 "parser/parser.yy"

    #include "contexte.hh"
    #include "expression.hh"
    #include "expressionBinaire.hh"
    #include "expressionUnaire.hh"
    #include "constante.hh"
    #include "variable.hh"
    #include "instructions.hh"
    #include "capteurs.hh"
    #include "types.hh"
    #include "condition.hh"
    #include "conditionBinaire.hh"
    #include "testBinaire.hh"
    #include <vector>
    #include <string>

    class Scanner;
    class Driver;

#line 69 "parser.tab.hh"

# include <cassert>
# include <cstdlib> // std::abort
# include <iostream>
# include <stdexcept>
# include <string>
# include <vector>

#if defined __cplusplus
# define YY_CPLUSPLUS __cplusplus
#else
# define YY_CPLUSPLUS 199711L
#endif

// Support move semantics when possible.
#if 201103L <= YY_CPLUSPLUS
# define YY_MOVE           std::move
# define YY_MOVE_OR_COPY   move
# define YY_MOVE_REF(Type) Type&&
# define YY_RVREF(Type)    Type&&
# define YY_COPY(Type)     Type
#else
# define YY_MOVE
# define YY_MOVE_OR_COPY   copy
# define YY_MOVE_REF(Type) Type&
# define YY_RVREF(Type)    const Type&
# define YY_COPY(Type)     const Type&
#endif

// Support noexcept when possible.
#if 201103L <= YY_CPLUSPLUS
# define YY_NOEXCEPT noexcept
# define YY_NOTHROW
#else
# define YY_NOEXCEPT
# define YY_NOTHROW throw ()
#endif

// Support constexpr when possible.
#if 201703 <= YY_CPLUSPLUS
# define YY_CONSTEXPR constexpr
#else
# define YY_CONSTEXPR
#endif
# include "location.hh"
#include <typeinfo>
#ifndef YY_ASSERT
# include <cassert>
# define YY_ASSERT assert
#endif


#ifndef YY_ATTRIBUTE_PURE
# if defined __GNUC__ && 2 < __GNUC__ + (96 <= __GNUC_MINOR__)
#  define YY_ATTRIBUTE_PURE __attribute__ ((__pure__))
# else
#  define YY_ATTRIBUTE_PURE
# endif
#endif

#ifndef YY_ATTRIBUTE_UNUSED
# if defined __GNUC__ && 2 < __GNUC__ + (7 <= __GNUC_MINOR__)
#  define YY_ATTRIBUTE_UNUSED __attribute__ ((__unused__))
# else
#  define YY_ATTRIBUTE_UNUSED
# endif
#endif

/* Suppress unused-variable warnings by "using" E.  */
#if ! defined lint || defined __GNUC__
# define YY_USE(E) ((void) (E))
#else
# define YY_USE(E) /* empty */
#endif

/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
#if defined __GNUC__ && ! defined __ICC && 406 <= __GNUC__ * 100 + __GNUC_MINOR__
# if __GNUC__ * 100 + __GNUC_MINOR__ < 407
#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \
    _Pragma ("GCC diagnostic push")                                     \
    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")
# else
#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \
    _Pragma ("GCC diagnostic push")                                     \
    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")              \
    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
# endif
# define YY_IGNORE_MAYBE_UNINITIALIZED_END      \
    _Pragma ("GCC diagnostic pop")
#else
# define YY_INITIAL_VALUE(Value) Value
#endif
#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
# define YY_IGNORE_MAYBE_UNINITIALIZED_END
#endif
#ifndef YY_INITIAL_VALUE
# define YY_INITIAL_VALUE(Value) /* Nothing. */
#endif

#if defined __cplusplus && defined __GNUC__ && ! defined __ICC && 6 <= __GNUC__
# define YY_IGNORE_USELESS_CAST_BEGIN                          \
    _Pragma ("GCC diagnostic push")                            \
    _Pragma ("GCC diagnostic ignored \"-Wuseless-cast\"")
# define YY_IGNORE_USELESS_CAST_END            \
    _Pragma ("GCC diagnostic pop")
#endif
#ifndef YY_IGNORE_USELESS_CAST_BEGIN
# define YY_IGNORE_USELESS_CAST_BEGIN
# define YY_IGNORE_USELESS_CAST_END
#endif

# ifndef YY_CAST
#  ifdef __cplusplus
#   define YY_CAST(Type, Val) static_cast<Type> (Val)
#   define YY_REINTERPRET_CAST(Type, Val) reinterpret_cast<Type> (Val)
#  else
#   define YY_CAST(Type, Val) ((Type) (Val))
#   define YY_REINTERPRET_CAST(Type, Val) ((Type) (Val))
#  endif
# endif
# ifndef YY_NULLPTR
#  if defined __cplusplus
#   if 201103L <= __cplusplus
#    define YY_NULLPTR nullptr
#   else
#    define YY_NULLPTR 0
#   endif
#  else
#   define YY_NULLPTR ((void*)0)
#  endif
# endif

/* Debug traces.  */
#ifndef YYDEBUG
# define YYDEBUG 0
#endif

namespace parser {
#line 209 "parser.tab.hh"




  /// A Bison parser.
  class  Parser 
  {
  public:
#ifdef YYSTYPE
# ifdef __GNUC__
#  pragma GCC message "bison: do not #define YYSTYPE in C++, use %define api.value.type"
# endif
    typedef YYSTYPE value_type;
#else
  /// A buffer to store and retrieve objects.
  ///
  /// Sort of a variant, but does not keep track of the nature
  /// of the stored data, since that knowledge is available
  /// via the current parser state.
  class value_type
  {
  public:
    /// Type of *this.
    typedef value_type self_type;

    /// Empty construction.
    value_type () YY_NOEXCEPT
      : yyraw_ ()
      , yytypeid_ (YY_NULLPTR)
    {}

    /// Construct and fill.
    template <typename T>
    value_type (YY_RVREF (T) t)
      : yytypeid_ (&typeid (T))
    {
      YY_ASSERT (sizeof (T) <= size);
      new (yyas_<T> ()) T (YY_MOVE (t));
    }

#if 201103L <= YY_CPLUSPLUS
    /// Non copyable.
    value_type (const self_type&) = delete;
    /// Non copyable.
    self_type& operator= (const self_type&) = delete;
#endif

    /// Destruction, allowed only if empty.
    ~value_type () YY_NOEXCEPT
    {
      YY_ASSERT (!yytypeid_);
    }

# if 201103L <= YY_CPLUSPLUS
    /// Instantiate a \a T in here from \a t.
    template <typename T, typename... U>
    T&
    emplace (U&&... u)
    {
      YY_ASSERT (!yytypeid_);
      YY_ASSERT (sizeof (T) <= size);
      yytypeid_ = & typeid (T);
      return *new (yyas_<T> ()) T (std::forward <U>(u)...);
    }
# else
    /// Instantiate an empty \a T in here.
    template <typename T>
    T&
    emplace ()
    {
      YY_ASSERT (!yytypeid_);
      YY_ASSERT (sizeof (T) <= size);
      yytypeid_ = & typeid (T);
      return *new (yyas_<T> ()) T ();
    }

    /// Instantiate a \a T in here from \a t.
    template <typename T>
    T&
    emplace (const T& t)
    {
      YY_ASSERT (!yytypeid_);
      YY_ASSERT (sizeof (T) <= size);
      yytypeid_ = & typeid (T);
      return *new (yyas_<T> ()) T (t);
    }
# endif

    /// Instantiate an empty \a T in here.
    /// Obsolete, use emplace.
    template <typename T>
    T&
    build ()
    {
      return emplace<T> ();
    }

    /// Instantiate a \a T in here from \a t.
    /// Obsolete, use emplace.
    template <typename T>
    T&
    build (const T& t)
    {
      return emplace<T> (t);
    }

    /// Accessor to a built \a T.
    template <typename T>
    T&
    as () YY_NOEXCEPT
    {
      YY_ASSERT (yytypeid_);
      YY_ASSERT (*yytypeid_ == typeid (T));
      YY_ASSERT (sizeof (T) <= size);
      return *yyas_<T> ();
    }

    /// Const accessor to a built \a T (for %printer).
    template <typename T>
    const T&
    as () const YY_NOEXCEPT
    {
      YY_ASSERT (yytypeid_);
      YY_ASSERT (*yytypeid_ == typeid (T));
      YY_ASSERT (sizeof (T) <= size);
      return *yyas_<T> ();
    }

    /// Swap the content with \a that, of same type.
    ///
    /// Both variants must be built beforehand, because swapping the actual
    /// data requires reading it (with as()), and this is not possible on
    /// unconstructed variants: it would require some dynamic testing, which
    /// should not be the variant's responsibility.
    /// Swapping between built and (possibly) non-built is done with
    /// self_type::move ().
    template <typename T>
    void
    swap (self_type& that) YY_NOEXCEPT
    {
      YY_ASSERT (yytypeid_);
      YY_ASSERT (*yytypeid_ == *that.yytypeid_);
      std::swap (as<T> (), that.as<T> ());
    }

    /// Move the content of \a that to this.
    ///
    /// Destroys \a that.
    template <typename T>
    void
    move (self_type& that)
    {
# if 201103L <= YY_CPLUSPLUS
      emplace<T> (std::move (that.as<T> ()));
# else
      emplace<T> ();
      swap<T> (that);
# endif
      that.destroy<T> ();
    }

# if 201103L <= YY_CPLUSPLUS
    /// Move the content of \a that to this.
    template <typename T>
    void
    move (self_type&& that)
    {
      emplace<T> (std::move (that.as<T> ()));
      that.destroy<T> ();
    }
#endif

    /// Copy the content of \a that to this.
    template <typename T>
    void
    copy (const self_type& that)
    {
      emplace<T> (that.as<T> ());
    }

    /// Destroy the stored \a T.
    template <typename T>
    void
    destroy ()
    {
      as<T> ().~T ();
      yytypeid_ = YY_NULLPTR;
    }

  private:
#if YY_CPLUSPLUS < 201103L
    /// Non copyable.
    value_type (const self_type&);
    /// Non copyable.
    self_type& operator= (const self_type&);
#endif

    /// Accessor to raw memory as \a T.
    template <typename T>
    T*
    yyas_ () YY_NOEXCEPT
    {
      void *yyp = yyraw_;
      return static_cast<T*> (yyp);
     }

    /// Const accessor to raw memory as \a T.
    template <typename T>
    const T*
    yyas_ () const YY_NOEXCEPT
    {
      const void *yyp = yyraw_;
      return static_cast<const T*> (yyp);
     }

    /// An auxiliary type to compute the largest semantic type.
    union union_type
    {
      // programme
      // liste_instructions
      char dummy1[sizeof (Bloc*)];

      // condition
      // condition_base
      char dummy2[sizeof (ConditionPtr)];

      // direction
      char dummy3[sizeof (Direction)];

      // expression
      char dummy4[sizeof (ExpressionPtr)];

      // instruction
      // commande
      // structure_controle
      char dummy5[sizeof (InstructionPtr)];

      // NUMBER
      char dummy6[sizeof (double)];

      // VAR_NAME
      char dummy7[sizeof (std::string)];

      // args_appel
      char dummy8[sizeof (std::vector<ExpressionPtr>)];

      // COLOR_HEX
      char dummy9[sizeof (std::vector<double>)];
    };

    /// The size of the largest semantic type.
    enum { size = sizeof (union_type) };

    /// A buffer to store semantic values.
    union
    {
      /// Strongest alignment constraints.
      long double yyalign_me_;
      /// A buffer large enough to store any of the semantic values.
      char yyraw_[size];
    };

    /// Whether the content is built: if defined, the name of the stored type.
    const std::type_info *yytypeid_;
  };

#endif
    /// Backward compatibility (Bison 3.8).
    typedef value_type semantic_type;

    /// Symbol locations.
    typedef location location_type;

    /// Syntax errors thrown from user actions.
    struct syntax_error : std::runtime_error
    {
      syntax_error (const location_type& l, const std::string& m)
        : std::runtime_error (m)
        , location (l)
      {}

      syntax_error (const syntax_error& s)
        : std::runtime_error (s.what ())
        , location (s.location)
      {}

      ~syntax_error () YY_NOEXCEPT YY_NOTHROW;

      location_type location;
    };

    /// Token kinds.
    struct token
    {
      enum token_kind_type
      {
        YYEMPTY = -2,
    YYEOF = 0,                     // "end of file"
    YYerror = 256,                 // error
    YYUNDEF = 257,                 // "invalid token"
    NL = 258,                      // NL
    END = 259,                     // END
    END_OF_FILE = 260,             // END_OF_FILE
    AVANCE = 261,                  // AVANCE
    RECULE = 262,                  // RECULE
    TOURNE = 263,                  // TOURNE
    SAUTE = 264,                   // SAUTE
    COULEUR = 265,                 // COULEUR
    TORTUES = 266,                 // TORTUES
    JARDIN = 267,                  // JARDIN
    FONCTION = 268,                // FONCTION
    SI = 269,                      // SI
    SINON = 270,                   // SINON
    TANT = 271,                    // TANT
    QUE = 272,                     // QUE
    REPETE = 273,                  // REPETE
    MUR = 274,                     // MUR
    VIDE = 275,                    // VIDE
    PAS = 276,                     // PAS
    DEVANT = 277,                  // DEVANT
    DERRIERE = 278,                // DERRIERE
    GAUCHE = 279,                  // GAUCHE
    DROITE = 280,                  // DROITE
    DP = 281,                      // DP
    AROBASE = 282,                 // AROBASE
    DOLLAR = 283,                  // DOLLAR
    PLUS = 284,                    // PLUS
    MOINS = 285,                   // MOINS
    MULT = 286,                    // MULT
    DIV = 287,                     // DIV
    LPAR = 288,                    // LPAR
    RPAR = 289,                    // RPAR
    EGAL = 290,                    // EGAL
    DIFFERENT = 291,               // DIFFERENT
    INF = 292,                     // INF
    SUP = 293,                     // SUP
    ET = 294,                      // ET
    OU = 295,                      // OU
    NUMBER = 296,                  // NUMBER
    VAR_NAME = 297,                // VAR_NAME
    COLOR_HEX = 298,               // COLOR_HEX
    NEG = 299                      // NEG
      };
      /// Backward compatibility alias (Bison 3.6).
      typedef token_kind_type yytokentype;
    };

    /// Token kind, as returned by yylex.
    typedef token::token_kind_type token_kind_type;

    /// Backward compatibility alias (Bison 3.6).
    typedef token_kind_type token_type;

    /// Symbol kinds.
    struct symbol_kind
    {
      enum symbol_kind_type
      {
        YYNTOKENS = 45, ///< Number of tokens.
        S_YYEMPTY = -2,
        S_YYEOF = 0,                             // "end of file"
        S_YYerror = 1,                           // error
        S_YYUNDEF = 2,                           // "invalid token"
        S_NL = 3,                                // NL
        S_END = 4,                               // END
        S_END_OF_FILE = 5,                       // END_OF_FILE
        S_AVANCE = 6,                            // AVANCE
        S_RECULE = 7,                            // RECULE
        S_TOURNE = 8,                            // TOURNE
        S_SAUTE = 9,                             // SAUTE
        S_COULEUR = 10,                          // COULEUR
        S_TORTUES = 11,                          // TORTUES
        S_JARDIN = 12,                           // JARDIN
        S_FONCTION = 13,                         // FONCTION
        S_SI = 14,                               // SI
        S_SINON = 15,                            // SINON
        S_TANT = 16,                             // TANT
        S_QUE = 17,                              // QUE
        S_REPETE = 18,                           // REPETE
        S_MUR = 19,                              // MUR
        S_VIDE = 20,                             // VIDE
        S_PAS = 21,                              // PAS
        S_DEVANT = 22,                           // DEVANT
        S_DERRIERE = 23,                         // DERRIERE
        S_GAUCHE = 24,                           // GAUCHE
        S_DROITE = 25,                           // DROITE
        S_DP = 26,                               // DP
        S_AROBASE = 27,                          // AROBASE
        S_DOLLAR = 28,                           // DOLLAR
        S_PLUS = 29,                             // PLUS
        S_MOINS = 30,                            // MOINS
        S_MULT = 31,                             // MULT
        S_DIV = 32,                              // DIV
        S_LPAR = 33,                             // LPAR
        S_RPAR = 34,                             // RPAR
        S_EGAL = 35,                             // EGAL
        S_DIFFERENT = 36,                        // DIFFERENT
        S_INF = 37,                              // INF
        S_SUP = 38,                              // SUP
        S_ET = 39,                               // ET
        S_OU = 40,                               // OU
        S_NUMBER = 41,                           // NUMBER
        S_VAR_NAME = 42,                         // VAR_NAME
        S_COLOR_HEX = 43,                        // COLOR_HEX
        S_NEG = 44,                              // NEG
        S_YYACCEPT = 45,                         // $accept
        S_root = 46,                             // root
        S_programme = 47,                        // programme
        S_definition_fonction = 48,              // definition_fonction
        S_liste_instructions = 49,               // liste_instructions
        S_instruction = 50,                      // instruction
        S_commande = 51,                         // commande
        S_structure_controle = 52,               // structure_controle
        S_args_appel = 53,                       // args_appel
        S_condition = 54,                        // condition
        S_condition_base = 55,                   // condition_base
        S_direction = 56,                        // direction
        S_expression = 57                        // expression
      };
    };

    /// (Internal) symbol kind.
    typedef symbol_kind::symbol_kind_type symbol_kind_type;

    /// The number of tokens.
    static const symbol_kind_type YYNTOKENS = symbol_kind::YYNTOKENS;

    /// A complete symbol.
    ///
    /// Expects its Base type to provide access to the symbol kind
    /// via kind ().
    ///
    /// Provide access to semantic value and location.
    template <typename Base>
    struct basic_symbol : Base
    {
      /// Alias to Base.
      typedef Base super_type;

      /// Default constructor.
      basic_symbol () YY_NOEXCEPT
        : value ()
        , location ()
      {}

#if 201103L <= YY_CPLUSPLUS
      /// Move constructor.
      basic_symbol (basic_symbol&& that)
        : Base (std::move (that))
        , value ()
        , location (std::move (that.location))
      {
        switch (this->kind ())
    {
      case symbol_kind::S_programme: // programme
      case symbol_kind::S_liste_instructions: // liste_instructions
        value.move< Bloc* > (std::move (that.value));
        break;

      case symbol_kind::S_condition: // condition
      case symbol_kind::S_condition_base: // condition_base
        value.move< ConditionPtr > (std::move (that.value));
        break;

      case symbol_kind::S_direction: // direction
        value.move< Direction > (std::move (that.value));
        break;

      case symbol_kind::S_expression: // expression
        value.move< ExpressionPtr > (std::move (that.value));
        break;

      case symbol_kind::S_instruction: // instruction
      case symbol_kind::S_commande: // commande
      case symbol_kind::S_structure_controle: // structure_controle
        value.move< InstructionPtr > (std::move (that.value));
        break;

      case symbol_kind::S_NUMBER: // NUMBER
        value.move< double > (std::move (that.value));
        break;

      case symbol_kind::S_VAR_NAME: // VAR_NAME
        value.move< std::string > (std::move (that.value));
        break;

      case symbol_kind::S_args_appel: // args_appel
        value.move< std::vector<ExpressionPtr> > (std::move (that.value));
        break;

      case symbol_kind::S_COLOR_HEX: // COLOR_HEX
        value.move< std::vector<double> > (std::move (that.value));
        break;

      default:
        break;
    }

      }
#endif

      /// Copy constructor.
      basic_symbol (const basic_symbol& that);

      /// Constructors for typed symbols.
#if 201103L <= YY_CPLUSPLUS
      basic_symbol (typename Base::kind_type t, location_type&& l)
        : Base (t)
        , location (std::move (l))
      {}
#else
      basic_symbol (typename Base::kind_type t, const location_type& l)
        : Base (t)
        , location (l)
      {}
#endif

#if 201103L <= YY_CPLUSPLUS
      basic_symbol (typename Base::kind_type t, Bloc*&& v, location_type&& l)
        : Base (t)
        , value (std::move (v))
        , location (std::move (l))
      {}
#else
      basic_symbol (typename Base::kind_type t, const Bloc*& v, const location_type& l)
        : Base (t)
        , value (v)
        , location (l)
      {}
#endif

#if 201103L <= YY_CPLUSPLUS
      basic_symbol (typename Base::kind_type t, ConditionPtr&& v, location_type&& l)
        : Base (t)
        , value (std::move (v))
        , location (std::move (l))
      {}
#else
      basic_symbol (typename Base::kind_type t, const ConditionPtr& v, const location_type& l)
        : Base (t)
        , value (v)
        , location (l)
      {}
#endif

#if 201103L <= YY_CPLUSPLUS
      basic_symbol (typename Base::kind_type t, Direction&& v, location_type&& l)
        : Base (t)
        , value (std::move (v))
        , location (std::move (l))
      {}
#else
      basic_symbol (typename Base::kind_type t, const Direction& v, const location_type& l)
        : Base (t)
        , value (v)
        , location (l)
      {}
#endif

#if 201103L <= YY_CPLUSPLUS
      basic_symbol (typename Base::kind_type t, ExpressionPtr&& v, location_type&& l)
        : Base (t)
        , value (std::move (v))
        , location (std::move (l))
      {}
#else
      basic_symbol (typename Base::kind_type t, const ExpressionPtr& v, const location_type& l)
        : Base (t)
        , value (v)
        , location (l)
      {}
#endif

#if 201103L <= YY_CPLUSPLUS
      basic_symbol (typename Base::kind_type t, InstructionPtr&& v, location_type&& l)
        : Base (t)
        , value (std::move (v))
        , location (std::move (l))
      {}
#else
      basic_symbol (typename Base::kind_type t, const InstructionPtr& v, const location_type& l)
        : Base (t)
        , value (v)
        , location (l)
      {}
#endif

#if 201103L <= YY_CPLUSPLUS
      basic_symbol (typename Base::kind_type t, double&& v, location_type&& l)
        : Base (t)
        , value (std::move (v))
        , location (std::move (l))
      {}
#else
      basic_symbol (typename Base::kind_type t, const double& v, const location_type& l)
        : Base (t)
        , value (v)
        , location (l)
      {}
#endif

#if 201103L <= YY_CPLUSPLUS
      basic_symbol (typename Base::kind_type t, std::string&& v, location_type&& l)
        : Base (t)
        , value (std::move (v))
        , location (std::move (l))
      {}
#else
      basic_symbol (typename Base::kind_type t, const std::string& v, const location_type& l)
        : Base (t)
        , value (v)
        , location (l)
      {}
#endif

#if 201103L <= YY_CPLUSPLUS
      basic_symbol (typename Base::kind_type t, std::vector<ExpressionPtr>&& v, location_type&& l)
        : Base (t)
        , value (std::move (v))
        , location (std::move (l))
      {}
#else
      basic_symbol (typename Base::kind_type t, const std::vector<ExpressionPtr>& v, const location_type& l)
        : Base (t)
        , value (v)
        , location (l)
      {}
#endif

#if 201103L <= YY_CPLUSPLUS
      basic_symbol (typename Base::kind_type t, std::vector<double>&& v, location_type&& l)
        : Base (t)
        , value (std::move (v))
        , location (std::move (l))
      {}
#else
      basic_symbol (typename Base::kind_type t, const std::vector<double>& v, const location_type& l)
        : Base (t)
        , value (v)
        , location (l)
      {}
#endif

      /// Destroy the symbol.
      ~basic_symbol ()
      {
        clear ();
      }



      /// Destroy contents, and record that is empty.
      void clear () YY_NOEXCEPT
      {
        // User destructor.
        symbol_kind_type yykind = this->kind ();
        basic_symbol<Base>& yysym = *this;
        (void) yysym;
        switch (yykind)
        {
       default:
          break;
        }

        // Value type destructor.
switch (yykind)
    {
      case symbol_kind::S_programme: // programme
      case symbol_kind::S_liste_instructions: // liste_instructions
        value.template destroy< Bloc* > ();
        break;

      case symbol_kind::S_condition: // condition
      case symbol_kind::S_condition_base: // condition_base
        value.template destroy< ConditionPtr > ();
        break;

      case symbol_kind::S_direction: // direction
        value.template destroy< Direction > ();
        break;

      case symbol_kind::S_expression: // expression
        value.template destroy< ExpressionPtr > ();
        break;

      case symbol_kind::S_instruction: // instruction
      case symbol_kind::S_commande: // commande
      case symbol_kind::S_structure_controle: // structure_controle
        value.template destroy< InstructionPtr > ();
        break;

      case symbol_kind::S_NUMBER: // NUMBER
        value.template destroy< double > ();
        break;

      case symbol_kind::S_VAR_NAME: // VAR_NAME
        value.template destroy< std::string > ();
        break;

      case symbol_kind::S_args_appel: // args_appel
        value.template destroy< std::vector<ExpressionPtr> > ();
        break;

      case symbol_kind::S_COLOR_HEX: // COLOR_HEX
        value.template destroy< std::vector<double> > ();
        break;

      default:
        break;
    }

        Base::clear ();
      }

#if YYDEBUG || 0
      /// The user-facing name of this symbol.
      const char *name () const YY_NOEXCEPT
      {
        return  Parser ::symbol_name (this->kind ());
      }
#endif // #if YYDEBUG || 0


      /// Backward compatibility (Bison 3.6).
      symbol_kind_type type_get () const YY_NOEXCEPT;

      /// Whether empty.
      bool empty () const YY_NOEXCEPT;

      /// Destructive move, \a s is emptied into this.
      void move (basic_symbol& s);

      /// The semantic value.
      value_type value;

      /// The location.
      location_type location;

    private:
#if YY_CPLUSPLUS < 201103L
      /// Assignment operator.
      basic_symbol& operator= (const basic_symbol& that);
#endif
    };

    /// Type access provider for token (enum) based symbols.
    struct by_kind
    {
      /// The symbol kind as needed by the constructor.
      typedef token_kind_type kind_type;

      /// Default constructor.
      by_kind () YY_NOEXCEPT;

#if 201103L <= YY_CPLUSPLUS
      /// Move constructor.
      by_kind (by_kind&& that) YY_NOEXCEPT;
#endif

      /// Copy constructor.
      by_kind (const by_kind& that) YY_NOEXCEPT;

      /// Constructor from (external) token numbers.
      by_kind (kind_type t) YY_NOEXCEPT;



      /// Record that this symbol is empty.
      void clear () YY_NOEXCEPT;

      /// Steal the symbol kind from \a that.
      void move (by_kind& that);

      /// The (internal) type number (corresponding to \a type).
      /// \a empty when empty.
      symbol_kind_type kind () const YY_NOEXCEPT;

      /// Backward compatibility (Bison 3.6).
      symbol_kind_type type_get () const YY_NOEXCEPT;

      /// The symbol kind.
      /// \a S_YYEMPTY when empty.
      symbol_kind_type kind_;
    };

    /// Backward compatibility for a private implementation detail (Bison 3.6).
    typedef by_kind by_type;

    /// "External" symbols: returned by the scanner.
    struct symbol_type : basic_symbol<by_kind>
    {
      /// Superclass.
      typedef basic_symbol<by_kind> super_type;

      /// Empty symbol.
      symbol_type () YY_NOEXCEPT {}

      /// Constructor for valueless symbols, and symbols from each type.
#if 201103L <= YY_CPLUSPLUS
      symbol_type (int tok, location_type l)
        : super_type (token_kind_type (tok), std::move (l))
#else
      symbol_type (int tok, const location_type& l)
        : super_type (token_kind_type (tok), l)
#endif
      {
#if !defined _MSC_VER || defined __clang__
        YY_ASSERT (tok == token::YYEOF
                   || (token::YYerror <= tok && tok <= token::OU)
                   || tok == token::NEG);
#endif
      }
#if 201103L <= YY_CPLUSPLUS
      symbol_type (int tok, double v, location_type l)
        : super_type (token_kind_type (tok), std::move (v), std::move (l))
#else
      symbol_type (int tok, const double& v, const location_type& l)
        : super_type (token_kind_type (tok), v, l)
#endif
      {
#if !defined _MSC_VER || defined __clang__
        YY_ASSERT (tok == token::NUMBER);
#endif
      }
#if 201103L <= YY_CPLUSPLUS
      symbol_type (int tok, std::string v, location_type l)
        : super_type (token_kind_type (tok), std::move (v), std::move (l))
#else
      symbol_type (int tok, const std::string& v, const location_type& l)
        : super_type (token_kind_type (tok), v, l)
#endif
      {
#if !defined _MSC_VER || defined __clang__
        YY_ASSERT (tok == token::VAR_NAME);
#endif
      }
#if 201103L <= YY_CPLUSPLUS
      symbol_type (int tok, std::vector<double> v, location_type l)
        : super_type (token_kind_type (tok), std::move (v), std::move (l))
#else
      symbol_type (int tok, const std::vector<double>& v, const location_type& l)
        : super_type (token_kind_type (tok), v, l)
#endif
      {
#if !defined _MSC_VER || defined __clang__
        YY_ASSERT (tok == token::COLOR_HEX);
#endif
      }
    };

    /// Build a parser object.
     Parser  (Scanner &scanner_yyarg, Driver &driver_yyarg);
    virtual ~ Parser  ();

#if 201103L <= YY_CPLUSPLUS
    /// Non copyable.
     Parser  (const  Parser &) = delete;
    /// Non copyable.
     Parser & operator= (const  Parser &) = delete;
#endif

    /// Parse.  An alias for parse ().
    /// \returns  0 iff parsing succeeded.
    int operator() ();

    /// Parse.
    /// \returns  0 iff parsing succeeded.
    virtual int parse ();

#if YYDEBUG
    /// The current debugging stream.
    std::ostream& debug_stream () const YY_ATTRIBUTE_PURE;
    /// Set the current debugging stream.
    void set_debug_stream (std::ostream &);

    /// Type for debugging levels.
    typedef int debug_level_type;
    /// The current debugging level.
    debug_level_type debug_level () const YY_ATTRIBUTE_PURE;
    /// Set the current debugging level.
    void set_debug_level (debug_level_type l);
#endif

    /// Report a syntax error.
    /// \param loc    where the syntax error is found.
    /// \param msg    a description of the syntax error.
    virtual void error (const location_type& loc, const std::string& msg);

    /// Report a syntax error.
    void error (const syntax_error& err);

#if YYDEBUG || 0
    /// The user-facing name of the symbol whose (internal) number is
    /// YYSYMBOL.  No bounds checking.
    static const char *symbol_name (symbol_kind_type yysymbol);
#endif // #if YYDEBUG || 0


    // Implementation of make_symbol for each token kind.
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_YYEOF (location_type l)
      {
        return symbol_type (token::YYEOF, std::move (l));
      }
#else
      static
      symbol_type
      make_YYEOF (const location_type& l)
      {
        return symbol_type (token::YYEOF, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_YYerror (location_type l)
      {
        return symbol_type (token::YYerror, std::move (l));
      }
#else
      static
      symbol_type
      make_YYerror (const location_type& l)
      {
        return symbol_type (token::YYerror, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_YYUNDEF (location_type l)
      {
        return symbol_type (token::YYUNDEF, std::move (l));
      }
#else
      static
      symbol_type
      make_YYUNDEF (const location_type& l)
      {
        return symbol_type (token::YYUNDEF, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_NL (location_type l)
      {
        return symbol_type (token::NL, std::move (l));
      }
#else
      static
      symbol_type
      make_NL (const location_type& l)
      {
        return symbol_type (token::NL, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_END (location_type l)
      {
        return symbol_type (token::END, std::move (l));
      }
#else
      static
      symbol_type
      make_END (const location_type& l)
      {
        return symbol_type (token::END, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_END_OF_FILE (location_type l)
      {
        return symbol_type (token::END_OF_FILE, std::move (l));
      }
#else
      static
      symbol_type
      make_END_OF_FILE (const location_type& l)
      {
        return symbol_type (token::END_OF_FILE, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_AVANCE (location_type l)
      {
        return symbol_type (token::AVANCE, std::move (l));
      }
#else
      static
      symbol_type
      make_AVANCE (const location_type& l)
      {
        return symbol_type (token::AVANCE, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_RECULE (location_type l)
      {
        return symbol_type (token::RECULE, std::move (l));
      }
#else
      static
      symbol_type
      make_RECULE (const location_type& l)
      {
        return symbol_type (token::RECULE, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_TOURNE (location_type l)
      {
        return symbol_type (token::TOURNE, std::move (l));
      }
#else
      static
      symbol_type
      make_TOURNE (const location_type& l)
      {
        return symbol_type (token::TOURNE, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_SAUTE (location_type l)
      {
        return symbol_type (token::SAUTE, std::move (l));
      }
#else
      static
      symbol_type
      make_SAUTE (const location_type& l)
      {
        return symbol_type (token::SAUTE, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_COULEUR (location_type l)
      {
        return symbol_type (token::COULEUR, std::move (l));
      }
#else
      static
      symbol_type
      make_COULEUR (const location_type& l)
      {
        return symbol_type (token::COULEUR, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_TORTUES (location_type l)
      {
        return symbol_type (token::TORTUES, std::move (l));
      }
#else
      static
      symbol_type
      make_TORTUES (const location_type& l)
      {
        return symbol_type (token::TORTUES, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_JARDIN (location_type l)
      {
        return symbol_type (token::JARDIN, std::move (l));
      }
#else
      static
      symbol_type
      make_JARDIN (const location_type& l)
      {
        return symbol_type (token::JARDIN, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_FONCTION (location_type l)
      {
        return symbol_type (token::FONCTION, std::move (l));
      }
#else
      static
      symbol_type
      make_FONCTION (const location_type& l)
      {
        return symbol_type (token::FONCTION, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_SI (location_type l)
      {
        return symbol_type (token::SI, std::move (l));
      }
#else
      static
      symbol_type
      make_SI (const location_type& l)
      {
        return symbol_type (token::SI, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_SINON (location_type l)
      {
        return symbol_type (token::SINON, std::move (l));
      }
#else
      static
      symbol_type
      make_SINON (const location_type& l)
      {
        return symbol_type (token::SINON, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_TANT (location_type l)
      {
        return symbol_type (token::TANT, std::move (l));
      }
#else
      static
      symbol_type
      make_TANT (const location_type& l)
      {
        return symbol_type (token::TANT, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_QUE (location_type l)
      {
        return symbol_type (token::QUE, std::move (l));
      }
#else
      static
      symbol_type
      make_QUE (const location_type& l)
      {
        return symbol_type (token::QUE, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_REPETE (location_type l)
      {
        return symbol_type (token::REPETE, std::move (l));
      }
#else
      static
      symbol_type
      make_REPETE (const location_type& l)
      {
        return symbol_type (token::REPETE, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_MUR (location_type l)
      {
        return symbol_type (token::MUR, std::move (l));
      }
#else
      static
      symbol_type
      make_MUR (const location_type& l)
      {
        return symbol_type (token::MUR, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_VIDE (location_type l)
      {
        return symbol_type (token::VIDE, std::move (l));
      }
#else
      static
      symbol_type
      make_VIDE (const location_type& l)
      {
        return symbol_type (token::VIDE, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_PAS (location_type l)
      {
        return symbol_type (token::PAS, std::move (l));
      }
#else
      static
      symbol_type
      make_PAS (const location_type& l)
      {
        return symbol_type (token::PAS, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_DEVANT (location_type l)
      {
        return symbol_type (token::DEVANT, std::move (l));
      }
#else
      static
      symbol_type
      make_DEVANT (const location_type& l)
      {
        return symbol_type (token::DEVANT, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_DERRIERE (location_type l)
      {
        return symbol_type (token::DERRIERE, std::move (l));
      }
#else
      static
      symbol_type
      make_DERRIERE (const location_type& l)
      {
        return symbol_type (token::DERRIERE, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_GAUCHE (location_type l)
      {
        return symbol_type (token::GAUCHE, std::move (l));
      }
#else
      static
      symbol_type
      make_GAUCHE (const location_type& l)
      {
        return symbol_type (token::GAUCHE, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_DROITE (location_type l)
      {
        return symbol_type (token::DROITE, std::move (l));
      }
#else
      static
      symbol_type
      make_DROITE (const location_type& l)
      {
        return symbol_type (token::DROITE, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_DP (location_type l)
      {
        return symbol_type (token::DP, std::move (l));
      }
#else
      static
      symbol_type
      make_DP (const location_type& l)
      {
        return symbol_type (token::DP, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_AROBASE (location_type l)
      {
        return symbol_type (token::AROBASE, std::move (l));
      }
#else
      static
      symbol_type
      make_AROBASE (const location_type& l)
      {
        return symbol_type (token::AROBASE, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_DOLLAR (location_type l)
      {
        return symbol_type (token::DOLLAR, std::move (l));
      }
#else
      static
      symbol_type
      make_DOLLAR (const location_type& l)
      {
        return symbol_type (token::DOLLAR, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_PLUS (location_type l)
      {
        return symbol_type (token::PLUS, std::move (l));
      }
#else
      static
      symbol_type
      make_PLUS (const location_type& l)
      {
        return symbol_type (token::PLUS, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_MOINS (location_type l)
      {
        return symbol_type (token::MOINS, std::move (l));
      }
#else
      static
      symbol_type
      make_MOINS (const location_type& l)
      {
        return symbol_type (token::MOINS, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_MULT (location_type l)
      {
        return symbol_type (token::MULT, std::move (l));
      }
#else
      static
      symbol_type
      make_MULT (const location_type& l)
      {
        return symbol_type (token::MULT, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_DIV (location_type l)
      {
        return symbol_type (token::DIV, std::move (l));
      }
#else
      static
      symbol_type
      make_DIV (const location_type& l)
      {
        return symbol_type (token::DIV, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_LPAR (location_type l)
      {
        return symbol_type (token::LPAR, std::move (l));
      }
#else
      static
      symbol_type
      make_LPAR (const location_type& l)
      {
        return symbol_type (token::LPAR, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_RPAR (location_type l)
      {
        return symbol_type (token::RPAR, std::move (l));
      }
#else
      static
      symbol_type
      make_RPAR (const location_type& l)
      {
        return symbol_type (token::RPAR, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_EGAL (location_type l)
      {
        return symbol_type (token::EGAL, std::move (l));
      }
#else
      static
      symbol_type
      make_EGAL (const location_type& l)
      {
        return symbol_type (token::EGAL, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_DIFFERENT (location_type l)
      {
        return symbol_type (token::DIFFERENT, std::move (l));
      }
#else
      static
      symbol_type
      make_DIFFERENT (const location_type& l)
      {
        return symbol_type (token::DIFFERENT, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_INF (location_type l)
      {
        return symbol_type (token::INF, std::move (l));
      }
#else
      static
      symbol_type
      make_INF (const location_type& l)
      {
        return symbol_type (token::INF, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_SUP (location_type l)
      {
        return symbol_type (token::SUP, std::move (l));
      }
#else
      static
      symbol_type
      make_SUP (const location_type& l)
      {
        return symbol_type (token::SUP, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_ET (location_type l)
      {
        return symbol_type (token::ET, std::move (l));
      }
#else
      static
      symbol_type
      make_ET (const location_type& l)
      {
        return symbol_type (token::ET, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_OU (location_type l)
      {
        return symbol_type (token::OU, std::move (l));
      }
#else
      static
      symbol_type
      make_OU (const location_type& l)
      {
        return symbol_type (token::OU, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_NUMBER (double v, location_type l)
      {
        return symbol_type (token::NUMBER, std::move (v), std::move (l));
      }
#else
      static
      symbol_type
      make_NUMBER (const double& v, const location_type& l)
      {
        return symbol_type (token::NUMBER, v, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_VAR_NAME (std::string v, location_type l)
      {
        return symbol_type (token::VAR_NAME, std::move (v), std::move (l));
      }
#else
      static
      symbol_type
      make_VAR_NAME (const std::string& v, const location_type& l)
      {
        return symbol_type (token::VAR_NAME, v, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_COLOR_HEX (std::vector<double> v, location_type l)
      {
        return symbol_type (token::COLOR_HEX, std::move (v), std::move (l));
      }
#else
      static
      symbol_type
      make_COLOR_HEX (const std::vector<double>& v, const location_type& l)
      {
        return symbol_type (token::COLOR_HEX, v, l);
      }
#endif
#if 201103L <= YY_CPLUSPLUS
      static
      symbol_type
      make_NEG (location_type l)
      {
        return symbol_type (token::NEG, std::move (l));
      }
#else
      static
      symbol_type
      make_NEG (const location_type& l)
      {
        return symbol_type (token::NEG, l);
      }
#endif


  private:
#if YY_CPLUSPLUS < 201103L
    /// Non copyable.
     Parser  (const  Parser &);
    /// Non copyable.
     Parser & operator= (const  Parser &);
#endif


    /// Stored state numbers (used for stacks).
    typedef signed char state_type;

    /// Compute post-reduction state.
    /// \param yystate   the current state
    /// \param yysym     the nonterminal to push on the stack
    static state_type yy_lr_goto_state_ (state_type yystate, int yysym);

    /// Whether the given \c yypact_ value indicates a defaulted state.
    /// \param yyvalue   the value to check
    static bool yy_pact_value_is_default_ (int yyvalue) YY_NOEXCEPT;

    /// Whether the given \c yytable_ value indicates a syntax error.
    /// \param yyvalue   the value to check
    static bool yy_table_value_is_error_ (int yyvalue) YY_NOEXCEPT;

    static const signed char yypact_ninf_;
    static const signed char yytable_ninf_;

    /// Convert a scanner token kind \a t to a symbol kind.
    /// In theory \a t should be a token_kind_type, but character literals
    /// are valid, yet not members of the token_kind_type enum.
    static symbol_kind_type yytranslate_ (int t) YY_NOEXCEPT;

#if YYDEBUG || 0
    /// For a symbol, its name in clear.
    static const char* const yytname_[];
#endif // #if YYDEBUG || 0


    // Tables.
    // YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
    // STATE-NUM.
    static const short yypact_[];

    // YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
    // Performed when YYTABLE does not specify something else to do.  Zero
    // means the default is an error.
    static const signed char yydefact_[];

    // YYPGOTO[NTERM-NUM].
    static const signed char yypgoto_[];

    // YYDEFGOTO[NTERM-NUM].
    static const signed char yydefgoto_[];

    // YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
    // positive, shift that token.  If negative, reduce the rule whose
    // number is the opposite.  If YYTABLE_NINF, syntax error.
    static const signed char yytable_[];

    static const signed char yycheck_[];

    // YYSTOS[STATE-NUM] -- The symbol kind of the accessing symbol of
    // state STATE-NUM.
    static const signed char yystos_[];

    // YYR1[RULE-NUM] -- Symbol kind of the left-hand side of rule RULE-NUM.
    static const signed char yyr1_[];

    // YYR2[RULE-NUM] -- Number of symbols on the right-hand side of rule RULE-NUM.
    static const signed char yyr2_[];


#if YYDEBUG
    // YYRLINE[YYN] -- Source line where rule number YYN was defined.
    static const unsigned char yyrline_[];
    /// Report on the debug stream that the rule \a r is going to be reduced.
    virtual void yy_reduce_print_ (int r) const;
    /// Print the state stack on the debug stream.
    virtual void yy_stack_print_ () const;

    /// Debugging level.
    int yydebug_;
    /// Debug stream.
    std::ostream* yycdebug_;

    /// \brief Display a symbol kind, value and location.
    /// \param yyo    The output stream.
    /// \param yysym  The symbol.
    template <typename Base>
    void yy_print_ (std::ostream& yyo, const basic_symbol<Base>& yysym) const;
#endif

    /// \brief Reclaim the memory associated to a symbol.
    /// \param yymsg     Why this token is reclaimed.
    ///                  If null, print nothing.
    /// \param yysym     The symbol.
    template <typename Base>
    void yy_destroy_ (const char* yymsg, basic_symbol<Base>& yysym) const;

  private:
    /// Type access provider for state based symbols.
    struct by_state
    {
      /// Default constructor.
      by_state () YY_NOEXCEPT;

      /// The symbol kind as needed by the constructor.
      typedef state_type kind_type;

      /// Constructor.
      by_state (kind_type s) YY_NOEXCEPT;

      /// Copy constructor.
      by_state (const by_state& that) YY_NOEXCEPT;

      /// Record that this symbol is empty.
      void clear () YY_NOEXCEPT;

      /// Steal the symbol kind from \a that.
      void move (by_state& that);

      /// The symbol kind (corresponding to \a state).
      /// \a symbol_kind::S_YYEMPTY when empty.
      symbol_kind_type kind () const YY_NOEXCEPT;

      /// The state number used to denote an empty symbol.
      /// We use the initial state, as it does not have a value.
      enum { empty_state = 0 };

      /// The state.
      /// \a empty when empty.
      state_type state;
    };

    /// "Internal" symbol: element of the stack.
    struct stack_symbol_type : basic_symbol<by_state>
    {
      /// Superclass.
      typedef basic_symbol<by_state> super_type;
      /// Construct an empty symbol.
      stack_symbol_type ();
      /// Move or copy construction.
      stack_symbol_type (YY_RVREF (stack_symbol_type) that);
      /// Steal the contents from \a sym to build this.
      stack_symbol_type (state_type s, YY_MOVE_REF (symbol_type) sym);
#if YY_CPLUSPLUS < 201103L
      /// Assignment, needed by push_back by some old implementations.
      /// Moves the contents of that.
      stack_symbol_type& operator= (stack_symbol_type& that);

      /// Assignment, needed by push_back by other implementations.
      /// Needed by some other old implementations.
      stack_symbol_type& operator= (const stack_symbol_type& that);
#endif
    };

    /// A stack with random access from its top.
    template <typename T, typename S = std::vector<T> >
    class stack
    {
    public:
      // Hide our reversed order.
      typedef typename S::iterator iterator;
      typedef typename S::const_iterator const_iterator;
      typedef typename S::size_type size_type;
      typedef typename std::ptrdiff_t index_type;

      stack (size_type n = 200) YY_NOEXCEPT
        : seq_ (n)
      {}

#if 201103L <= YY_CPLUSPLUS
      /// Non copyable.
      stack (const stack&) = delete;
      /// Non copyable.
      stack& operator= (const stack&) = delete;
#endif

      /// Random access.
      ///
      /// Index 0 returns the topmost element.
      const T&
      operator[] (index_type i) const
      {
        return seq_[size_type (size () - 1 - i)];
      }

      /// Random access.
      ///
      /// Index 0 returns the topmost element.
      T&
      operator[] (index_type i)
      {
        return seq_[size_type (size () - 1 - i)];
      }

      /// Steal the contents of \a t.
      ///
      /// Close to move-semantics.
      void
      push (YY_MOVE_REF (T) t)
      {
        seq_.push_back (T ());
        operator[] (0).move (t);
      }

      /// Pop elements from the stack.
      void
      pop (std::ptrdiff_t n = 1) YY_NOEXCEPT
      {
        for (; 0 < n; --n)
          seq_.pop_back ();
      }

      /// Pop all elements from the stack.
      void
      clear () YY_NOEXCEPT
      {
        seq_.clear ();
      }

      /// Number of elements on the stack.
      index_type
      size () const YY_NOEXCEPT
      {
        return index_type (seq_.size ());
      }

      /// Iterator on top of the stack (going downwards).
      const_iterator
      begin () const YY_NOEXCEPT
      {
        return seq_.begin ();
      }

      /// Bottom of the stack.
      const_iterator
      end () const YY_NOEXCEPT
      {
        return seq_.end ();
      }

      /// Present a slice of the top of a stack.
      class slice
      {
      public:
        slice (const stack& stack, index_type range) YY_NOEXCEPT
          : stack_ (stack)
          , range_ (range)
        {}

        const T&
        operator[] (index_type i) const
        {
          return stack_[range_ - i];
        }

      private:
        const stack& stack_;
        index_type range_;
      };

    private:
#if YY_CPLUSPLUS < 201103L
      /// Non copyable.
      stack (const stack&);
      /// Non copyable.
      stack& operator= (const stack&);
#endif
      /// The wrapped container.
      S seq_;
    };


    /// Stack type.
    typedef stack<stack_symbol_type> stack_type;

    /// The stack.
    stack_type yystack_;

    /// Push a new state on the stack.
    /// \param m    a debug message to display
    ///             if null, no trace is output.
    /// \param sym  the symbol
    /// \warning the contents of \a s.value is stolen.
    void yypush_ (const char* m, YY_MOVE_REF (stack_symbol_type) sym);

    /// Push a new look ahead token on the state on the stack.
    /// \param m    a debug message to display
    ///             if null, no trace is output.
    /// \param s    the state
    /// \param sym  the symbol (for its value and location).
    /// \warning the contents of \a sym.value is stolen.
    void yypush_ (const char* m, state_type s, YY_MOVE_REF (symbol_type) sym);

    /// Pop \a n symbols from the stack.
    void yypop_ (int n = 1) YY_NOEXCEPT;

    /// Constants.
    enum
    {
      yylast_ = 267,     ///< Last index in yytable_.
      yynnts_ = 13,  ///< Number of nonterminal symbols.
      yyfinal_ = 3 ///< Termination state number.
    };


    // User arguments.
    Scanner &scanner;
    Driver &driver;

  };


} // parser
#line 2102 "parser.tab.hh"




#endif // !YY_PARSER_PARSER_TAB_HH_INCLUDED



==================================================
FICHIER : ./position.hh
==================================================
// A Bison parser, made by GNU Bison 3.8.2.

// Starting with Bison 3.2, this file is useless: the structure it
// used to define is now defined in "location.hh".
//
// To get rid of this file:
// 1. add '%require "3.2"' (or newer) to your grammar file
// 2. remove references to this file from your build system
// 3. if you used to include it, include "location.hh" instead.

#include "location.hh"



==================================================
FICHIER : ./projet.pro
==================================================
TEMPLATE = subdirs 
SUBDIRS += expressions
SUBDIRS += tortue.pro

tortue.file = tortue.pro # This specifies the .pro file to use
tortue.depends = expressions/expressions.pro 



==================================================
FICHIER : ./scanner.cc
==================================================
#line 2 "scanner.cc"

#line 4 "scanner.cc"

#define  YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 6
#define YY_FLEX_SUBMINOR_VERSION 4
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

    /* The c++ scanner is a mess. The FlexLexer.h header file relies on the
     * following macro. This is required in order to pass the c++-multiple-scanners
     * test in the regression suite. We get reports that it breaks inheritance.
     * We will address this in a future release of flex, or omit the C++ scanner
     * altogether.
     */
    #define yyFlexLexer yyFlexLexer

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types. 
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t; 
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN               (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN              (-32767-1)
#endif
#ifndef INT32_MIN
#define INT32_MIN              (-2147483647-1)
#endif
#ifndef INT8_MAX
#define INT8_MAX               (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX              (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX              (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX              (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX             (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX             (4294967295U)
#endif

#ifndef SIZE_MAX
#define SIZE_MAX               (~(size_t)0)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

/* begin standard C++ headers. */
#include <iostream>
#include <errno.h>
#include <cstdlib>
#include <cstdio>
#include <cstring>
/* end standard C++ headers. */

/* TODO: this is always defined, so inline it */
#define yyconst const

#if defined(__GNUC__) && __GNUC__ >= 3
#define yynoreturn __attribute__((__noreturn__))
#else
#define yynoreturn
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an
 *   integer in range [0..255] for use as an array index.
 */
#define YY_SC_TO_UI(c) ((YY_CHAR) (c))

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN (yy_start) = 1 + 2 *
/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START (((yy_start) - 1) / 2)
#define YYSTATE YY_START
/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( yyin  )
#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define YY_BUF_SIZE 32768
#else
#define YY_BUF_SIZE 16384
#endif /* __ia64__ */
#endif

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

extern int yyleng;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2
    
    #define YY_LESS_LINENO(n)
    #define YY_LINENO_REWIND_TO(ptr)
    
/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		*yy_cp = (yy_hold_char); \
		YY_RESTORE_YY_MORE_OFFSET \
		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )
#define unput(c) yyunput( c, (yytext_ptr)  )

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
	{

	std::streambuf* yy_input_file;

	char *yy_ch_buf;		/* input buffer */
	char *yy_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	int yy_buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	int yy_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yy_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yy_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yy_at_bol;

    int yy_bs_lineno; /**< The line count. */
    int yy_bs_column; /**< The column count. */

	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yy_fill_buffer;

	int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via yyrestart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */
#define YY_BUFFER_EOF_PENDING 2

	};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
                          : NULL)
/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]

void *yyalloc ( yy_size_t  );
void *yyrealloc ( void *, yy_size_t  );
void yyfree ( void *  );

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){ \
        yyensure_buffer_stack (); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer( yyin, YY_BUF_SIZE ); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
	}
#define yy_set_bol(at_bol) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){\
        yyensure_buffer_stack (); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer( yyin, YY_BUF_SIZE ); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
	}
#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* Begin user sect3 */
#define YY_SKIP_YYWRAP
typedef flex_uint8_t YY_CHAR;

#define yytext_ptr yytext
#define YY_INTERACTIVE

#include <FlexLexer.h>

int yyFlexLexer::yywrap() { return 1; }
int yyFlexLexer::yylex()
	{
	LexerError( "yyFlexLexer::yylex invoked but %option yyclass used" );
	return 0;
	}

#define YY_DECL int Scanner::yylex()

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
	(yytext_ptr) = yy_bp; \
	yyleng = (int) (yy_cp - yy_bp); \
	(yy_hold_char) = *yy_cp; \
	*yy_cp = '\0'; \
	(yy_c_buf_p) = yy_cp;
#define YY_NUM_RULES 47
#define YY_END_OF_BUFFER 48
/* This struct is not used in this scanner,
   but its presence is necessary. */
struct yy_trans_info
	{
	flex_int32_t yy_verify;
	flex_int32_t yy_nxt;
	};
static const flex_int16_t yy_accept[144] =
    {   0,
        0,    0,   48,   46,    2,    3,   46,   46,   30,   38,
       39,   36,   34,   35,   37,   32,   28,   42,   46,   43,
       29,   31,   31,   31,   31,   31,   31,   31,   31,   31,
       31,   31,   31,   31,   31,   31,   31,   46,   41,    0,
        1,    0,   32,   40,   31,   31,   31,   19,   31,   31,
       31,   31,   31,   31,   31,   31,   31,   31,   31,   31,
       10,   31,   31,   31,   24,    0,    1,   32,   31,   31,
       31,   31,   31,    4,   31,   31,   31,   31,   16,   18,
       13,   31,   31,   31,   31,   31,   31,   31,   31,    0,
       31,   31,   31,   31,   31,    9,   31,   31,   31,   31,

       31,   31,   31,   12,   31,   31,   17,    0,   31,   31,
       31,   31,   31,   31,   31,   31,   31,   31,    8,   11,
       31,   31,    0,    5,   31,   31,   20,   23,   31,   22,
       27,    6,   14,   31,    7,   33,   25,   31,   31,   26,
       21,   15,    0
    } ;

static const YY_CHAR yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    4,    1,    5,    6,    1,    1,    1,    7,
        8,    9,   10,    1,   11,   12,   13,   14,   14,   14,
       14,   14,   14,   14,   14,   14,   14,   15,    1,   16,
       17,   18,    1,   19,   20,   20,   20,   20,   20,   20,
       21,   21,   21,   21,   21,   21,   21,   21,   21,   21,
       21,   21,   21,   21,   21,   21,   21,   21,   21,   21,
        1,    1,    1,    1,   21,    1,   22,   20,   23,   24,

       25,   26,   27,   28,   29,   30,   21,   31,   32,   33,
       34,   35,   36,   37,   38,   39,   40,   41,   21,   21,
       21,   21,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,   42,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,   43,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static const YY_CHAR yy_meta[44] =
    {   0,
        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    3,    1,    1,    1,    1,    1,    3,
        4,    3,    3,    3,    3,    3,    4,    4,    4,    4,
        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
        4,    1,    1
    } ;

static const flex_int16_t yy_base[152] =
    {   0,
        0,    0,  154,  155,  155,  155,  136,    0,  155,  155,
      155,  155,  155,  141,  155,   32,  155,  155,  134,  155,
      155,    0,  109,  115,   20,  109,   18,  125,  124,  105,
      104,  121,  102,  116,   26,   27,  111,   97,  155,    0,
        0,  124,   39,  155,    0,  115,   96,   13,  101,    0,
      101,   27,   93,   95,   94,    0,   92,  104,   35,   88,
       94,   93,   22,  101,  155,    0,    0,  110,   90,   91,
       84,   98,   90,    0,   80,   94,   93,   91,    0,    0,
        0,   74,   88,   73,   77,   71,   70,   71,   82,    0,
       83,   80,   75,   70,   63,    0,   62,   72,   70,   67,

       58,   71,   62,    0,   54,   60,    0,    0,   67,   51,
       65,   50,   63,   58,   61,   52,   59,   58,    0,    0,
       57,   56,    0,    0,   43,   42,    0,    0,   44,    0,
        0,    0,    0,   39,    0,  155,    0,   49,   36,    0,
        0,    0,  155,   65,   68,   64,   72,   63,   62,   61,
       60
    } ;

static const flex_int16_t yy_def[152] =
    {   0,
      143,    1,  143,  143,  143,  143,  143,  144,  143,  143,
      143,  143,  143,  143,  143,  143,  143,  143,  143,  143,
      143,  145,  145,  145,  145,  145,  145,  145,  145,  145,
      145,  145,  145,  145,  145,  145,  145,  143,  143,  146,
      147,  143,  143,  143,  145,  145,  145,  145,  145,  145,
      145,  145,  145,  145,  145,  145,  145,  145,  145,  145,
      145,  145,  145,  145,  143,  148,  147,  143,  145,  145,
      145,  145,  145,  145,  145,  145,  145,  145,  145,  145,
      145,  145,  145,  145,  145,  145,  145,  145,  145,  149,
      145,  145,  145,  145,  145,  145,  145,  145,  145,  145,

      145,  145,  145,  145,  145,  145,  145,  150,  145,  145,
      145,  145,  145,  145,  145,  145,  145,  145,  145,  145,
      145,  145,  151,  145,  145,  145,  145,  145,  145,  145,
      145,  145,  145,  145,  145,  143,  145,  145,  145,  145,
      145,  145,    0,  143,  143,  143,  143,  143,  143,  143,
      143
    } ;

static const flex_int16_t yy_nxt[199] =
    {   0,
        4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
       14,    4,   15,   16,   17,   18,   19,   20,   21,   22,
       22,   23,   24,   25,   26,   27,   28,   22,   22,   29,
       22,   30,   22,   31,   32,   33,   34,   35,   36,   22,
       37,    4,   38,   42,   48,   43,   51,   60,   62,   71,
       42,   52,   43,   72,   61,   75,   49,   82,   87,   76,
       63,   88,  136,  123,  108,   90,   66,   40,  142,   83,
       45,   45,   67,  141,   67,   67,  140,  139,  138,  137,
      135,  134,  133,  132,  131,  130,  129,  128,  127,  126,
      125,  124,  122,  121,  120,  119,  118,  117,  116,  115,

      114,  113,  112,  111,  110,  109,  107,  106,  105,  104,
      103,  102,  101,  100,   99,   98,   97,   96,   95,   94,
       93,   92,   91,   68,   89,   86,   85,   84,   81,   80,
       79,   78,   77,   74,   73,   70,   69,   68,   65,   64,
       59,   58,   57,   56,   55,   54,   53,   50,   47,   46,
       44,   41,   39,  143,    3,  143,  143,  143,  143,  143,
      143,  143,  143,  143,  143,  143,  143,  143,  143,  143,
      143,  143,  143,  143,  143,  143,  143,  143,  143,  143,
      143,  143,  143,  143,  143,  143,  143,  143,  143,  143,
      143,  143,  143,  143,  143,  143,  143,  143

    } ;

static const flex_int16_t yy_chk[199] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,   16,   25,   16,   27,   35,   36,   48,
       43,   27,   43,   48,   35,   52,   25,   59,   63,   52,
       36,   63,  151,  150,  149,  148,  146,  144,  139,   59,
      145,  145,  147,  138,  147,  147,  134,  129,  126,  125,
      122,  121,  118,  117,  116,  115,  114,  113,  112,  111,
      110,  109,  106,  105,  103,  102,  101,  100,   99,   98,

       97,   95,   94,   93,   92,   91,   89,   88,   87,   86,
       85,   84,   83,   82,   78,   77,   76,   75,   73,   72,
       71,   70,   69,   68,   64,   62,   61,   60,   58,   57,
       55,   54,   53,   51,   49,   47,   46,   42,   38,   37,
       34,   33,   32,   31,   30,   29,   28,   26,   24,   23,
       19,   14,    7,    3,  143,  143,  143,  143,  143,  143,
      143,  143,  143,  143,  143,  143,  143,  143,  143,  143,
      143,  143,  143,  143,  143,  143,  143,  143,  143,  143,
      143,  143,  143,  143,  143,  143,  143,  143,  143,  143,
      143,  143,  143,  143,  143,  143,  143,  143

    } ;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
#line 1 "parser/scanner.ll"
#line 2 "parser/scanner.ll"
#include "scanner.hh"
#include <cstdlib>
#include <iostream>

#define YY_NO_UNISTD_H

using token = yy::Parser::token;
#undef  YY_DECL
#define YY_DECL int Scanner::yylex( yy::Parser::semantic_type * const lval, yy::Parser::location_type *loc )

#define YY_USER_ACTION loc->step(); loc->columns(yyleng);
#line 509 "scanner.cc"
#line 510 "scanner.cc"

#define INITIAL 0

#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#include <unistd.h>
#endif

#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void *
#endif

#ifndef yytext_ptr
static void yy_flex_strncpy ( char *, const char *, int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen ( const char * );
#endif

#ifndef YY_NO_INPUT

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
#define ECHO LexerOutput( yytext, yyleng )
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
\
	if ( (int)(result = LexerInput( (char *) buf, max_size )) < 0 ) \
		YY_FATAL_ERROR( "input in flex scanner failed" );

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) LexerError( msg )
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1
#define YY_DECL int yyFlexLexer::yylex()
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
	yy_state_type yy_current_state;
	char *yy_cp, *yy_bp;
	int yy_act;
    
	if ( !(yy_init) )
		{
		(yy_init) = 1;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! (yy_start) )
			(yy_start) = 1;	/* first start state */

		if ( ! yyin )
			yyin.rdbuf(std::cin.rdbuf());

		if ( ! yyout )
			yyout.rdbuf(std::cout.rdbuf());

		if ( ! YY_CURRENT_BUFFER ) {
			yyensure_buffer_stack ();
			YY_CURRENT_BUFFER_LVALUE =
				yy_create_buffer( yyin, YY_BUF_SIZE );
		}

		yy_load_buffer_state(  );
		}

	{
#line 19 "parser/scanner.ll"



#line 23 "parser/scanner.ll"
    yylval = lval;


#line 650 "scanner.cc"

	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
		{
		yy_cp = (yy_c_buf_p);

		/* Support of yytext. */
		*yy_cp = (yy_hold_char);

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = (yy_start);
yy_match:
		do
			{
			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
			if ( yy_accept[yy_current_state] )
				{
				(yy_last_accepting_state) = yy_current_state;
				(yy_last_accepting_cpos) = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 144 )
					yy_c = yy_meta[yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 155 );

yy_find_action:
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ /* have to back up */
			yy_cp = (yy_last_accepting_cpos);
			yy_current_state = (yy_last_accepting_state);
			yy_act = yy_accept[yy_current_state];
			}

		YY_DO_BEFORE_ACTION;

do_action:	/* This label is used only to access EOF actions. */

		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = (yy_hold_char);
			yy_cp = (yy_last_accepting_cpos);
			yy_current_state = (yy_last_accepting_state);
			goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 26 "parser/scanner.ll"
{ /* Commentaire : on ignore */ }
	YY_BREAK
case 2:
YY_RULE_SETUP
#line 27 "parser/scanner.ll"
{ /* Espaces : on ignore */ }
	YY_BREAK
case 3:
/* rule 3 can match eol */
YY_RULE_SETUP
#line 28 "parser/scanner.ll"
{ loc->lines(); return token::NL; }
	YY_BREAK
case 4:
YY_RULE_SETUP
#line 30 "parser/scanner.ll"
{ return token::END; }
	YY_BREAK
case 5:
YY_RULE_SETUP
#line 32 "parser/scanner.ll"
{ return token::AVANCE; }
	YY_BREAK
case 6:
YY_RULE_SETUP
#line 33 "parser/scanner.ll"
{ return token::RECULE; }
	YY_BREAK
case 7:
YY_RULE_SETUP
#line 34 "parser/scanner.ll"
{ return token::TOURNE; }
	YY_BREAK
case 8:
YY_RULE_SETUP
#line 35 "parser/scanner.ll"
{ return token::SAUTE; }
	YY_BREAK
case 9:
YY_RULE_SETUP
#line 36 "parser/scanner.ll"
{ /* Ignorer */ }
	YY_BREAK
case 10:
YY_RULE_SETUP
#line 38 "parser/scanner.ll"
{ return token::SI; }
	YY_BREAK
case 11:
YY_RULE_SETUP
#line 39 "parser/scanner.ll"
{ return token::SINON; }
	YY_BREAK
case 12:
YY_RULE_SETUP
#line 40 "parser/scanner.ll"
{ return token::TANT; }
	YY_BREAK
case 13:
YY_RULE_SETUP
#line 41 "parser/scanner.ll"
{ return token::QUE; }
	YY_BREAK
case 14:
YY_RULE_SETUP
#line 42 "parser/scanner.ll"
{ return token::REPETE; }
	YY_BREAK
case 15:
YY_RULE_SETUP
#line 44 "parser/scanner.ll"
{ return token::FONCTION; }
	YY_BREAK
case 16:
YY_RULE_SETUP
#line 46 "parser/scanner.ll"
{ return token::MUR; }
	YY_BREAK
case 17:
YY_RULE_SETUP
#line 47 "parser/scanner.ll"
{ return token::VIDE; }
	YY_BREAK
case 18:
YY_RULE_SETUP
#line 48 "parser/scanner.ll"
{ return token::PAS; }
	YY_BREAK
case 19:
YY_RULE_SETUP
#line 49 "parser/scanner.ll"
{ /* Ignorer "de" dans "pas de" */ }
	YY_BREAK
case 20:
YY_RULE_SETUP
#line 51 "parser/scanner.ll"
{ return token::DEVANT; }
	YY_BREAK
case 21:
YY_RULE_SETUP
#line 52 "parser/scanner.ll"
{ return token::DERRIERE; }
	YY_BREAK
case 22:
YY_RULE_SETUP
#line 53 "parser/scanner.ll"
{ /* Gère "à gauche" */ return token::GAUCHE; }
	YY_BREAK
case 23:
YY_RULE_SETUP
#line 54 "parser/scanner.ll"
{ /* Gère "à droite" */ return token::DROITE; }
	YY_BREAK
case 24:
YY_RULE_SETUP
#line 55 "parser/scanner.ll"
{ /* Ignorer */ }
	YY_BREAK
case 25:
YY_RULE_SETUP
#line 57 "parser/scanner.ll"
{ return token::COULEUR; }
	YY_BREAK
case 26:
YY_RULE_SETUP
#line 58 "parser/scanner.ll"
{ return token::TORTUES; }
	YY_BREAK
case 27:
YY_RULE_SETUP
#line 59 "parser/scanner.ll"
{ return token::JARDIN; }
	YY_BREAK
case 28:
YY_RULE_SETUP
#line 61 "parser/scanner.ll"
{ return token::DP; }
	YY_BREAK
case 29:
YY_RULE_SETUP
#line 62 "parser/scanner.ll"
{ return token::AROBASE; }
	YY_BREAK
case 30:
YY_RULE_SETUP
#line 63 "parser/scanner.ll"
{ return token::DOLLAR; }
	YY_BREAK
case 31:
YY_RULE_SETUP
#line 65 "parser/scanner.ll"
{
    yylval->build<std::string>(YYText());
    return token::VAR_NAME;
}
	YY_BREAK
case 32:
YY_RULE_SETUP
#line 70 "parser/scanner.ll"
{
    yylval->build<double>(std::atof(YYText()));
    return token::NUMBER;
}
	YY_BREAK
case 33:
YY_RULE_SETUP
#line 75 "parser/scanner.ll"
{
    // Gestion couleur hexadécimale
    std::string s = YYText();
    unsigned int r, g, b;
    std::sscanf(s.c_str(), "#%02x%02x%02x", &r, &g, &b);
    yylval->build<std::vector<double>>({(double)r, (double)g, (double)b});
    return token::COLOR_HEX;
}
	YY_BREAK
case 34:
YY_RULE_SETUP
#line 84 "parser/scanner.ll"
{ return token::PLUS; }
	YY_BREAK
case 35:
YY_RULE_SETUP
#line 85 "parser/scanner.ll"
{ return token::MOINS; }
	YY_BREAK
case 36:
YY_RULE_SETUP
#line 86 "parser/scanner.ll"
{ return token::MULT; }
	YY_BREAK
case 37:
YY_RULE_SETUP
#line 87 "parser/scanner.ll"
{ return token::DIV; }
	YY_BREAK
case 38:
YY_RULE_SETUP
#line 88 "parser/scanner.ll"
{ return token::LPAR; }
	YY_BREAK
case 39:
YY_RULE_SETUP
#line 89 "parser/scanner.ll"
{ return token::RPAR; }
	YY_BREAK
case 40:
YY_RULE_SETUP
#line 90 "parser/scanner.ll"
{ return token::EGAL; }
	YY_BREAK
case 41:
YY_RULE_SETUP
#line 91 "parser/scanner.ll"
{ return token::DIFFERENT; }
	YY_BREAK
case 42:
YY_RULE_SETUP
#line 92 "parser/scanner.ll"
{ return token::INF; }
	YY_BREAK
case 43:
YY_RULE_SETUP
#line 93 "parser/scanner.ll"
{ return token::SUP; }
	YY_BREAK
case 44:
YY_RULE_SETUP
#line 94 "parser/scanner.ll"
{ return token::ET; }
	YY_BREAK
case 45:
YY_RULE_SETUP
#line 95 "parser/scanner.ll"
{ return token::OU; }
	YY_BREAK
case YY_STATE_EOF(INITIAL):
#line 97 "parser/scanner.ll"
{ return token::END_OF_FILE; }
	YY_BREAK
case 46:
YY_RULE_SETUP
#line 98 "parser/scanner.ll"
{ std::cerr << "Caractère inconnu: " << YYText() << std::endl; }
	YY_BREAK
case 47:
YY_RULE_SETUP
#line 100 "parser/scanner.ll"
ECHO;
	YY_BREAK
#line 960 "scanner.cc"

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = (yy_hold_char);
		YY_RESTORE_YY_MORE_OFFSET

		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * yylex().  If so, then we have to assure
			 * consistency between YY_CURRENT_BUFFER and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin.rdbuf();
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state(  );

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state );

			yy_bp = (yytext_ptr) + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++(yy_c_buf_p);
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = (yy_c_buf_p);
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer(  ) )
			{
			case EOB_ACT_END_OF_FILE:
				{
				(yy_did_buffer_switch_on_eof) = 0;

				if ( yywrap(  ) )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! (yy_did_buffer_switch_on_eof) )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				(yy_c_buf_p) =
					(yytext_ptr) + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state(  );

				yy_cp = (yy_c_buf_p);
				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				(yy_c_buf_p) =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];

				yy_current_state = yy_get_previous_state(  );

				yy_cp = (yy_c_buf_p);
				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			"fatal flex scanner internal error--no action found" );
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of user's declarations */
} /* end of yylex */

/* The contents of this function are C++ specific, so the () macro is not used.
 * This constructor simply maintains backward compatibility.
 * DEPRECATED
 */
yyFlexLexer::yyFlexLexer( std::istream* arg_yyin, std::ostream* arg_yyout ):
	yyin(arg_yyin ? arg_yyin->rdbuf() : std::cin.rdbuf()),
	yyout(arg_yyout ? arg_yyout->rdbuf() : std::cout.rdbuf())
{
	ctor_common();
}

/* The contents of this function are C++ specific, so the () macro is not used.
 */
yyFlexLexer::yyFlexLexer( std::istream& arg_yyin, std::ostream& arg_yyout ):
	yyin(arg_yyin.rdbuf()),
	yyout(arg_yyout.rdbuf())
{
	ctor_common();
}

/* The contents of this function are C++ specific, so the () macro is not used.
 */
void yyFlexLexer::ctor_common()
{
	yy_c_buf_p = 0;
	yy_init = 0;
	yy_start = 0;
	yy_flex_debug = 0;
	yylineno = 1;	// this will only get updated if %option yylineno

	yy_did_buffer_switch_on_eof = 0;

	yy_looking_for_trail_begin = 0;
	yy_more_flag = 0;
	yy_more_len = 0;
	yy_more_offset = yy_prev_more_offset = 0;

	yy_start_stack_ptr = yy_start_stack_depth = 0;
	yy_start_stack = NULL;

	yy_buffer_stack = NULL;
	yy_buffer_stack_top = 0;
	yy_buffer_stack_max = 0;

	yy_state_buf = 0;

}

/* The contents of this function are C++ specific, so the () macro is not used.
 */
yyFlexLexer::~yyFlexLexer()
{
	delete [] yy_state_buf;
	yyfree( yy_start_stack  );
	yy_delete_buffer( YY_CURRENT_BUFFER );
	yyfree( yy_buffer_stack  );
}

/* The contents of this function are C++ specific, so the () macro is not used.
 */
void yyFlexLexer::switch_streams( std::istream& new_in, std::ostream& new_out )
{
	// was if( new_in )
	yy_delete_buffer( YY_CURRENT_BUFFER );
	yy_switch_to_buffer( yy_create_buffer( new_in, YY_BUF_SIZE  ) );

	// was if( new_out )
	yyout.rdbuf(new_out.rdbuf());
}

/* The contents of this function are C++ specific, so the () macro is not used.
 */
void yyFlexLexer::switch_streams( std::istream* new_in, std::ostream* new_out )
{
	if( ! new_in ) {
		new_in = &yyin;
	}

	if ( ! new_out ) {
		new_out = &yyout;
	}

	switch_streams(*new_in, *new_out);
}

#ifdef YY_INTERACTIVE
int yyFlexLexer::LexerInput( char* buf, int /* max_size */ )
#else
int yyFlexLexer::LexerInput( char* buf, int max_size )
#endif
{
	if ( yyin.eof() || yyin.fail() )
		return 0;

#ifdef YY_INTERACTIVE
	yyin.get( buf[0] );

	if ( yyin.eof() )
		return 0;

	if ( yyin.bad() )
		return -1;

	return 1;

#else
	(void) yyin.read( buf, max_size );

	if ( yyin.bad() )
		return -1;
	else
		return yyin.gcount();
#endif
}

void yyFlexLexer::LexerOutput( const char* buf, int size )
{
	(void) yyout.write( buf, size );
}

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
int yyFlexLexer::yy_get_next_buffer()
{
    	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
	char *source = (yytext_ptr);
	int number_to_move, i;
	int ret_val;

	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
		YY_FATAL_ERROR(
		"fatal flex scanner internal error--end of buffer missed" );

	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
			{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;

	else
		{
			int num_to_read =
			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

			int yy_c_buf_p_offset =
				(int) ((yy_c_buf_p) - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					yyrealloc( (void *) b->yy_ch_buf,
							 (yy_size_t) (b->yy_buf_size + 2)  );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = NULL;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
				"fatal error - scanner input buffer overflow" );

			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
						number_to_move - 1;

			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
			(yy_n_chars), num_to_read );

		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	if ( (yy_n_chars) == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			yyrestart( yyin  );
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
		/* Extend the array by 50%, plus the number we really need. */
		int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );
		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
		/* "- 2" to take care of EOB's */
		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
	}

	(yy_n_chars) += number_to_move;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;

	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

	return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    yy_state_type yyFlexLexer::yy_get_previous_state()
{
	yy_state_type yy_current_state;
	char *yy_cp;
    
	yy_current_state = (yy_start);

	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
		{
		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			(yy_last_accepting_state) = yy_current_state;
			(yy_last_accepting_cpos) = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 144 )
				yy_c = yy_meta[yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
		}

	return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
    yy_state_type yyFlexLexer::yy_try_NUL_trans( yy_state_type yy_current_state )
{
	int yy_is_jam;
    	char *yy_cp = (yy_c_buf_p);

	YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		(yy_last_accepting_state) = yy_current_state;
		(yy_last_accepting_cpos) = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 144 )
			yy_c = yy_meta[yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
	yy_is_jam = (yy_current_state == 143);

		return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT
    void yyFlexLexer::yyunput( int c, char* yy_bp)
{
	char *yy_cp;
    
    yy_cp = (yy_c_buf_p);

	/* undo effects of setting up yytext */
	*yy_cp = (yy_hold_char);

	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
		{ /* need to shift things up to make room */
		/* +2 for EOB chars. */
		int number_to_move = (yy_n_chars) + 2;
		char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
		char *source =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			*--dest = *--source;

		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
			(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
			YY_FATAL_ERROR( "flex scanner push-back overflow" );
		}

	*--yy_cp = (char) c;

	(yytext_ptr) = yy_bp;
	(yy_hold_char) = *yy_cp;
	(yy_c_buf_p) = yy_cp;
}
#endif

    int yyFlexLexer::yyinput()
{
	int c;
    
	*(yy_c_buf_p) = (yy_hold_char);

	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
		{
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
			/* This was really a NUL. */
			*(yy_c_buf_p) = '\0';

		else
			{ /* need more input */
			int offset = (int) ((yy_c_buf_p) - (yytext_ptr));
			++(yy_c_buf_p);

			switch ( yy_get_next_buffer(  ) )
				{
				case EOB_ACT_LAST_MATCH:
					/* This happens because yy_g_n_b()
					 * sees that we've accumulated a
					 * token and flags that we need to
					 * try matching the token before
					 * proceeding.  But for input(),
					 * there's no matching to consider.
					 * So convert the EOB_ACT_LAST_MATCH
					 * to EOB_ACT_END_OF_FILE.
					 */

					/* Reset buffer status. */
					yyrestart( yyin );

					/*FALLTHROUGH*/

				case EOB_ACT_END_OF_FILE:
					{
					if ( yywrap(  ) )
						return 0;

					if ( ! (yy_did_buffer_switch_on_eof) )
						YY_NEW_FILE;
#ifdef __cplusplus
					return yyinput();
#else
					return input();
#endif
					}

				case EOB_ACT_CONTINUE_SCAN:
					(yy_c_buf_p) = (yytext_ptr) + offset;
					break;
				}
			}
		}

	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
	*(yy_c_buf_p) = '\0';	/* preserve yytext */
	(yy_hold_char) = *++(yy_c_buf_p);

	return c;
}

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 * 
 * @note This function does not reset the start condition to @c INITIAL .
 */
    void yyFlexLexer::yyrestart( std::istream& input_file )
{
    
	if ( ! YY_CURRENT_BUFFER ){
        yyensure_buffer_stack ();
		YY_CURRENT_BUFFER_LVALUE =
            yy_create_buffer( yyin, YY_BUF_SIZE );
	}

	yy_init_buffer( YY_CURRENT_BUFFER, input_file );
	yy_load_buffer_state(  );
}

/** Delegate to the new version that takes an istream reference.
 * @param input_file A readable stream.
 * 
 * @note This function does not reset the start condition to @c INITIAL .
 */
void yyFlexLexer::yyrestart( std::istream* input_file )
{
	if( ! input_file ) {
		input_file = &yyin;
	}
	yyrestart( *input_file );
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 * 
 */
    void yyFlexLexer::yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
{
    
	/* TODO. We should be able to replace this entire function body
	 * with
	 *		yypop_buffer_state();
	 *		yypush_buffer_state(new_buffer);
     */
	yyensure_buffer_stack ();
	if ( YY_CURRENT_BUFFER == new_buffer )
		return;

	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*(yy_c_buf_p) = (yy_hold_char);
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	YY_CURRENT_BUFFER_LVALUE = new_buffer;
	yy_load_buffer_state(  );

	/* We don't actually know whether we did this switch during
	 * EOF (yywrap()) processing, but the only time this flag
	 * is looked at is after yywrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	(yy_did_buffer_switch_on_eof) = 1;
}

    void yyFlexLexer::yy_load_buffer_state()
{
    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
	yyin.rdbuf(YY_CURRENT_BUFFER_LVALUE->yy_input_file);
	(yy_hold_char) = *(yy_c_buf_p);
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 * 
 * @return the allocated buffer state.
 */
    YY_BUFFER_STATE yyFlexLexer::yy_create_buffer( std::istream& file, int size )
{
	YY_BUFFER_STATE b;
    
	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_buf_size = size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2)  );
	if ( ! b->yy_ch_buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_is_our_buffer = 1;

	yy_init_buffer( b, file );

	return b;
}

/** Delegate creation of buffers to the new version that takes an istream reference.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 * 
 * @return the allocated buffer state.
 */
	YY_BUFFER_STATE yyFlexLexer::yy_create_buffer( std::istream* file, int size )
{
	return yy_create_buffer( *file, size );
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 * 
 */
    void yyFlexLexer::yy_delete_buffer( YY_BUFFER_STATE b )
{
    
	if ( ! b )
		return;

	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;

	if ( b->yy_is_our_buffer )
		yyfree( (void *) b->yy_ch_buf  );

	yyfree( (void *) b  );
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
    void yyFlexLexer::yy_init_buffer( YY_BUFFER_STATE b, std::istream& file )

{
	int oerrno = errno;
    
	yy_flush_buffer( b );

	b->yy_input_file = file.rdbuf();
	b->yy_fill_buffer = 1;

    /* If b is the current buffer, then yy_init_buffer was _probably_
     * called from yyrestart() or through yy_get_next_buffer.
     * In that case, we don't want to reset the lineno or column.
     */
    if (b != YY_CURRENT_BUFFER){
        b->yy_bs_lineno = 1;
        b->yy_bs_column = 0;
    }

	b->yy_is_interactive = 0;
	errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 * 
 */
    void yyFlexLexer::yy_flush_buffer( YY_BUFFER_STATE b )
{
    	if ( ! b )
		return;

	b->yy_n_chars = 0;

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

	b->yy_buf_pos = &b->yy_ch_buf[0];

	b->yy_at_bol = 1;
	b->yy_buffer_status = YY_BUFFER_NEW;

	if ( b == YY_CURRENT_BUFFER )
		yy_load_buffer_state(  );
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *  
 */
void yyFlexLexer::yypush_buffer_state (YY_BUFFER_STATE new_buffer)
{
    	if (new_buffer == NULL)
		return;

	yyensure_buffer_stack();

	/* This block is copied from yy_switch_to_buffer. */
	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*(yy_c_buf_p) = (yy_hold_char);
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	/* Only push if top exists. Otherwise, replace top. */
	if (YY_CURRENT_BUFFER)
		(yy_buffer_stack_top)++;
	YY_CURRENT_BUFFER_LVALUE = new_buffer;

	/* copied from yy_switch_to_buffer. */
	yy_load_buffer_state(  );
	(yy_did_buffer_switch_on_eof) = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *  
 */
void yyFlexLexer::yypop_buffer_state (void)
{
    	if (!YY_CURRENT_BUFFER)
		return;

	yy_delete_buffer(YY_CURRENT_BUFFER );
	YY_CURRENT_BUFFER_LVALUE = NULL;
	if ((yy_buffer_stack_top) > 0)
		--(yy_buffer_stack_top);

	if (YY_CURRENT_BUFFER) {
		yy_load_buffer_state(  );
		(yy_did_buffer_switch_on_eof) = 1;
	}
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
void yyFlexLexer::yyensure_buffer_stack(void)
{
	yy_size_t num_to_alloc;
    
	if (!(yy_buffer_stack)) {

		/* First allocation is just for 2 elements, since we don't know if this
		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
		 * immediate realloc on the next call.
         */
      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
								(num_to_alloc * sizeof(struct yy_buffer_state*)
								);
		if ( ! (yy_buffer_stack) )
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );

		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));

		(yy_buffer_stack_max) = num_to_alloc;
		(yy_buffer_stack_top) = 0;
		return;
	}

	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){

		/* Increase the buffer to prepare for a possible push. */
		yy_size_t grow_size = 8 /* arbitrary grow size */;

		num_to_alloc = (yy_buffer_stack_max) + grow_size;
		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
								((yy_buffer_stack),
								num_to_alloc * sizeof(struct yy_buffer_state*)
								);
		if ( ! (yy_buffer_stack) )
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );

		/* zero only the new slots.*/
		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
		(yy_buffer_stack_max) = num_to_alloc;
	}
}

    void yyFlexLexer::yy_push_state( int _new_state )
{
    	if ( (yy_start_stack_ptr) >= (yy_start_stack_depth) )
		{
		yy_size_t new_size;

		(yy_start_stack_depth) += YY_START_STACK_INCR;
		new_size = (yy_size_t) (yy_start_stack_depth) * sizeof( int );

		if ( ! (yy_start_stack) )
			(yy_start_stack) = (int *) yyalloc( new_size  );

		else
			(yy_start_stack) = (int *) yyrealloc(
					(void *) (yy_start_stack), new_size  );

		if ( ! (yy_start_stack) )
			YY_FATAL_ERROR( "out of memory expanding start-condition stack" );
		}

	(yy_start_stack)[(yy_start_stack_ptr)++] = YY_START;

	BEGIN(_new_state);
}

    void yyFlexLexer::yy_pop_state()
{
    	if ( --(yy_start_stack_ptr) < 0 )
		YY_FATAL_ERROR( "start-condition stack underflow" );

	BEGIN((yy_start_stack)[(yy_start_stack_ptr)]);
}

    int yyFlexLexer::yy_top_state()
{
    	return (yy_start_stack)[(yy_start_stack_ptr) - 1];
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

void yyFlexLexer::LexerError( const char* msg )
{
    	std::cerr << msg << std::endl;
	exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		yytext[yyleng] = (yy_hold_char); \
		(yy_c_buf_p) = yytext + yyless_macro_arg; \
		(yy_hold_char) = *(yy_c_buf_p); \
		*(yy_c_buf_p) = '\0'; \
		yyleng = yyless_macro_arg; \
		} \
	while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy (char* s1, const char * s2, int n )
{
		
	int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (const char * s )
{
	int n;
	for ( n = 0; s[n]; ++n )
		;

	return n;
}
#endif

void *yyalloc (yy_size_t  size )
{
			return malloc(size);
}

void *yyrealloc  (void * ptr, yy_size_t  size )
{
		
	/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */
	return realloc(ptr, size);
}

void yyfree (void * ptr )
{
			free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
}

#define YYTABLES_NAME "yytables"

#line 100 "parser/scanner.ll"





==================================================
FICHIER : ./stack.hh
==================================================
// A Bison parser, made by GNU Bison 3.8.2.

// Starting with Bison 3.2, this file is useless: the structure it
// used to define is now defined with the parser itself.
//
// To get rid of this file:
// 1. add '%require "3.2"' (or newer) to your grammar file
// 2. remove references to this file from your build system.



==================================================
FICHIER : ./test_carre.txt
==================================================
couleur #FF0000
avance 2
tourne 90
avance 2
tourne 90
avance 2
tourne 90
avance 2



==================================================
FICHIER : ./test_visuel.txt
==================================================
couleur rouge
avance 100
tourne 90
avance 100
tourne 90
avance 100
tourne 90
avance 100
tourne 90



==================================================
FICHIER : ./tortue.pro
==================================================
TEMPLATE = app
TARGET = tortue
QT += widgets

CONFIG += c++17 console
QMAKE_CXXFLAGS += -std=c++17

INCLUDEPATH += $$PWD/expressions $$PWD/parser $$PWD/GUI .

# --- SOURCES (.cc) ---
SOURCES += parser/main.cc \
           parser/driver.cc \
           parser/parser.cc \
           parser/scanner.cc \
           GUI/tortue.cc \
           GUI/jardinHandler.cc \
           GUI/jardinRendering.cc \
           GUI/jardin.cc \
           expressions/capteurs.cc \
           expressions/contexte.cc \
           expressions/constante.cc \
           expressions/variable.cc \
           expressions/expressionBinaire.cc \
           expressions/expressionUnaire.cc \
           expressions/expressionTernaire.cc \
           expressions/conditionBinaire.cc \
           expressions/testBinaire.cc

# --- HEADERS (.hh) ---
HEADERS += parser/scanner.hh \
           parser/driver.hh \
           parser/parser.hh \
           GUI/tortue.hh \
           GUI/jardinHandler.hh \
           GUI/jardinRendering.hh \
           GUI/jardin.hh \
           expressions/instructions.hh \
           expressions/capteurs.hh \
           expressions/types.hh \
           expressions/contexte.hh \
           expressions/expression.hh \
           expressions/expressionBinaire.hh \
           expressions/constante.hh \
           expressions/variable.hh \
           expressions/condition.hh \
           expressions/conditionBinaire.hh \
           expressions/testBinaire.hh \
           expressions/expressionUnaire.hh \
           expressions/expressionTernaire.hh



